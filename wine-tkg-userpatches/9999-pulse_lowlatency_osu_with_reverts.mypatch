diff --git a/dlls/mmdevapi/Makefile.in b/dlls/mmdevapi/Makefile.in
index 11111111111..11111111111 100644
--- a/dlls/mmdevapi/Makefile.in
+++ b/dlls/mmdevapi/Makefile.in
@@ -1,13 +1,9 @@
 MODULE    = mmdevapi.dll
-IMPORTS   = ole32 oleaut32 user32 advapi32 version
+IMPORTS   = uuid ole32 oleaut32 user32 advapi32
 
-C_SRCS = \
-	audiosessionmanager.c \
+SOURCES = \
 	audiovolume.c \
-	client.c \
 	devenum.c \
 	main.c \
-	session.c \
+	mmdevapi_classes.idl \
 	spatialaudio.c
-
-IDL_SRCS = mmdevapi_classes.idl
diff --git a/dlls/mmdevapi/audiosessionmanager.c b/dlls/mmdevapi/audiosessionmanager.c
deleted file mode 100644
index 11111111111..11111111111
--- a/dlls/mmdevapi/audiosessionmanager.c
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#define COBJMACROS
-
-#include <audiopolicy.h>
-#include <mmdeviceapi.h>
-
-#include <wine/debug.h>
-#include <wine/list.h>
-
-#include "mmdevapi_private.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(mmdevapi);
-
-extern HRESULT get_audio_session_wrapper(const GUID *guid, IMMDevice *device,
-                                         struct audio_session_wrapper **out);
-
-static CRITICAL_SECTION g_sessions_lock;
-static CRITICAL_SECTION_DEBUG g_sessions_lock_debug =
-{
-    0, 0, &g_sessions_lock,
-    { &g_sessions_lock_debug.ProcessLocksList, &g_sessions_lock_debug.ProcessLocksList },
-    0, 0, { (DWORD_PTR)(__FILE__ ": g_sessions_lock") }
-};
-static CRITICAL_SECTION g_sessions_lock = { &g_sessions_lock_debug, -1, 0, 0, 0, 0 };
-
-void sessions_lock(void)
-{
-    EnterCriticalSection(&g_sessions_lock);
-}
-
-void sessions_unlock(void)
-{
-    LeaveCriticalSection(&g_sessions_lock);
-}
-
-static inline struct session_mgr *impl_from_IAudioSessionManager2(IAudioSessionManager2 *iface)
-{
-    return CONTAINING_RECORD(iface, struct session_mgr, IAudioSessionManager2_iface);
-}
-
-static HRESULT WINAPI ASM_QueryInterface(IAudioSessionManager2 *iface, REFIID riid, void **ppv)
-{
-    struct session_mgr *This = impl_from_IAudioSessionManager2(iface);
-    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), ppv);
-
-    if (!ppv)
-        return E_POINTER;
-
-    if (IsEqualIID(riid, &IID_IUnknown) ||
-        IsEqualIID(riid, &IID_IAudioSessionManager) ||
-        IsEqualIID(riid, &IID_IAudioSessionManager2))
-        *ppv = &This->IAudioSessionManager2_iface;
-    else {
-        *ppv = NULL;
-        return E_NOINTERFACE;
-    }
-
-    IUnknown_AddRef((IUnknown *)*ppv);
-
-    return S_OK;
-}
-
-static ULONG WINAPI ASM_AddRef(IAudioSessionManager2 *iface)
-{
-    struct session_mgr *This = impl_from_IAudioSessionManager2(iface);
-    ULONG ref = InterlockedIncrement(&This->ref);
-    TRACE("(%p) new ref %lu\n", This, ref);
-    return ref;
-}
-
-static ULONG WINAPI ASM_Release(IAudioSessionManager2 *iface)
-{
-    struct session_mgr *This = impl_from_IAudioSessionManager2(iface);
-    ULONG ref = InterlockedDecrement(&This->ref);
-    TRACE("(%p) new ref %lu\n", This, ref);
-
-    if (!ref)
-        free(This);
-
-    return ref;
-}
-
-static HRESULT WINAPI ASM_GetAudioSessionControl(IAudioSessionManager2 *iface,
-                                                 const GUID *guid, DWORD flags,
-                                                 IAudioSessionControl **out)
-{
-    struct session_mgr *This = impl_from_IAudioSessionManager2(iface);
-    AudioSessionWrapper *wrapper;
-    HRESULT hr;
-
-    TRACE("(%p)->(%s, %lx, %p)\n", This, debugstr_guid(guid), flags, out);
-
-    hr = get_audio_session_wrapper(guid, This->device, &wrapper);
-    if (FAILED(hr))
-        return hr;
-
-    *out = (IAudioSessionControl*)&wrapper->IAudioSessionControl2_iface;
-
-    return S_OK;
-}
-
-static HRESULT WINAPI ASM_GetSimpleAudioVolume(IAudioSessionManager2 *iface,
-                                               const GUID *guid, DWORD flags,
-                                               ISimpleAudioVolume **out)
-{
-    struct session_mgr *This = impl_from_IAudioSessionManager2(iface);
-    AudioSessionWrapper *wrapper;
-    HRESULT hr;
-
-    TRACE("(%p)->(%s, %lx, %p)\n", This, debugstr_guid(guid), flags, out);
-
-    hr = get_audio_session_wrapper(guid, This->device, &wrapper);
-    if (FAILED(hr))
-        return hr;
-
-    *out = &wrapper->ISimpleAudioVolume_iface;
-
-    return S_OK;
-}
-
-static HRESULT WINAPI ASM_GetSessionEnumerator(IAudioSessionManager2 *iface,
-                                               IAudioSessionEnumerator **out)
-{
-    struct session_mgr *This = impl_from_IAudioSessionManager2(iface);
-    FIXME("(%p)->(%p) - stub\n", This, out);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI ASM_RegisterSessionNotification(IAudioSessionManager2 *iface,
-                                                      IAudioSessionNotification *notification)
-{
-    struct session_mgr *This = impl_from_IAudioSessionManager2(iface);
-    FIXME("(%p)->(%p) - stub\n", This, notification);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI ASM_UnregisterSessionNotification(IAudioSessionManager2 *iface,
-                                                        IAudioSessionNotification *notification)
-{
-    struct session_mgr *This = impl_from_IAudioSessionManager2(iface);
-    FIXME("(%p)->(%p) - stub\n", This, notification);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI ASM_RegisterDuckNotification(IAudioSessionManager2 *iface,
-                                                   const WCHAR *session_id,
-                                                   IAudioVolumeDuckNotification *notification)
-{
-    struct session_mgr *This = impl_from_IAudioSessionManager2(iface);
-    FIXME("(%p)->(%s, %p) - stub\n", This, debugstr_w(session_id), notification);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI ASM_UnregisterDuckNotification(IAudioSessionManager2 *iface,
-                                                     IAudioVolumeDuckNotification *notification)
-{
-    struct session_mgr *This = impl_from_IAudioSessionManager2(iface);
-    FIXME("(%p)->(%p) - stub\n", This, notification);
-    return E_NOTIMPL;
-}
-
-static const IAudioSessionManager2Vtbl AudioSessionManager2_Vtbl =
-{
-    ASM_QueryInterface,
-    ASM_AddRef,
-    ASM_Release,
-    ASM_GetAudioSessionControl,
-    ASM_GetSimpleAudioVolume,
-    ASM_GetSessionEnumerator,
-    ASM_RegisterSessionNotification,
-    ASM_UnregisterSessionNotification,
-    ASM_RegisterDuckNotification,
-    ASM_UnregisterDuckNotification
-};
-
-HRESULT AudioSessionManager_Create(IMMDevice *device, IAudioSessionManager2 **ppv)
-{
-    struct session_mgr *This;
-
-    This = calloc(1, sizeof(*This));
-    if (!This)
-        return E_OUTOFMEMORY;
-
-    This->IAudioSessionManager2_iface.lpVtbl = &AudioSessionManager2_Vtbl;
-    This->device = device;
-    This->ref = 1;
-
-    *ppv = &This->IAudioSessionManager2_iface;
-
-    return S_OK;
-}
diff --git a/dlls/mmdevapi/audiovolume.c b/dlls/mmdevapi/audiovolume.c
index 11111111111..11111111111 100644
--- a/dlls/mmdevapi/audiovolume.c
+++ b/dlls/mmdevapi/audiovolume.c
@@ -35,7 +35,7 @@
 #include "audiopolicy.h"
 #include "spatialaudioclient.h"
 
-#include "mmdevapi_private.h"
+#include "mmdevapi.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(mmdevapi);
 
@@ -53,7 +53,7 @@ static inline AEVImpl *impl_from_IAudioEndpointVolumeEx(IAudioEndpointVolumeEx *
 
 static void AudioEndpointVolume_Destroy(AEVImpl *This)
 {
-    free(This);
+    HeapFree(GetProcessHeap(), 0, This);
 }
 
 static HRESULT WINAPI AEV_QueryInterface(IAudioEndpointVolumeEx *iface, REFIID riid, void **ppv)
@@ -309,7 +309,7 @@ HRESULT AudioEndpointVolume_Create(MMDevice *parent, IAudioEndpointVolumeEx **pp
     AEVImpl *This;
 
     *ppv = NULL;
-    This = calloc(1, sizeof(*This));
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*This));
     if (!This)
         return E_OUTOFMEMORY;
     This->IAudioEndpointVolumeEx_iface.lpVtbl = &AEVImpl_Vtbl;
diff --git a/dlls/mmdevapi/client.c b/dlls/mmdevapi/client.c
deleted file mode 100644
index 11111111111..11111111111
--- a/dlls/mmdevapi/client.c
+++ /dev/null
@@ -1,1438 +0,0 @@
-/*
- * Copyright 2011-2012 Maarten Lankhorst
- * Copyright 2010-2011 Maarten Lankhorst for CodeWeavers
- * Copyright 2011 Andrew Eikum for CodeWeavers
- * Copyright 2022 Huw Davies
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#define COBJMACROS
-
-#include <wchar.h>
-
-#include <audiopolicy.h>
-#include <mmdeviceapi.h>
-#include <winternl.h>
-
-#include <wine/debug.h>
-#include <wine/unixlib.h>
-
-#include "mmdevapi_private.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(mmdevapi);
-
-typedef struct tagLANGANDCODEPAGE
-{
-    WORD wLanguage;
-    WORD wCodePage;
-} LANGANDCODEPAGE;
-
-extern void sessions_lock(void) DECLSPEC_HIDDEN;
-extern void sessions_unlock(void) DECLSPEC_HIDDEN;
-
-extern HRESULT get_audio_session(const GUID *sessionguid, IMMDevice *device, UINT channels,
-                                 struct audio_session **out) DECLSPEC_HIDDEN;
-extern struct audio_session_wrapper *session_wrapper_create(struct audio_client *client) DECLSPEC_HIDDEN;
-
-static HANDLE main_loop_thread;
-
-void main_loop_stop(void)
-{
-    if (main_loop_thread) {
-        WaitForSingleObject(main_loop_thread, INFINITE);
-        CloseHandle(main_loop_thread);
-    }
-}
-
-void set_stream_volumes(struct audio_client *This)
-{
-    struct set_volumes_params params;
-
-    params.stream          = This->stream;
-    params.master_volume   = (This->session->mute ? 0.0f : This->session->master_vol);
-    params.volumes         = This->vols;
-    params.session_volumes = This->session->channel_vols;
-
-    wine_unix_call(set_volumes, &params);
-}
-
-static inline struct audio_client *impl_from_IAudioCaptureClient(IAudioCaptureClient *iface)
-{
-    return CONTAINING_RECORD(iface, struct audio_client, IAudioCaptureClient_iface);
-}
-
-static inline struct audio_client *impl_from_IAudioClient3(IAudioClient3 *iface)
-{
-    return CONTAINING_RECORD(iface, struct audio_client, IAudioClient3_iface);
-}
-
-static inline struct audio_client *impl_from_IAudioClock(IAudioClock *iface)
-{
-    return CONTAINING_RECORD(iface, struct audio_client, IAudioClock_iface);
-}
-
-static inline struct audio_client *impl_from_IAudioClock2(IAudioClock2 *iface)
-{
-    return CONTAINING_RECORD(iface, struct audio_client, IAudioClock2_iface);
-}
-
-static inline struct audio_client *impl_from_IAudioRenderClient(IAudioRenderClient *iface)
-{
-    return CONTAINING_RECORD(iface, struct audio_client, IAudioRenderClient_iface);
-}
-
-static inline struct audio_client *impl_from_IAudioStreamVolume(IAudioStreamVolume *iface)
-{
-    return CONTAINING_RECORD(iface, struct audio_client, IAudioStreamVolume_iface);
-}
-
-static void dump_fmt(const WAVEFORMATEX *fmt)
-{
-    TRACE("wFormatTag: 0x%x (", fmt->wFormatTag);
-    switch (fmt->wFormatTag) {
-        case WAVE_FORMAT_PCM:
-            TRACE("WAVE_FORMAT_PCM");
-            break;
-        case WAVE_FORMAT_IEEE_FLOAT:
-            TRACE("WAVE_FORMAT_IEEE_FLOAT");
-            break;
-        case WAVE_FORMAT_EXTENSIBLE:
-            TRACE("WAVE_FORMAT_EXTENSIBLE");
-            break;
-        default:
-            TRACE("Unknown");
-            break;
-    }
-    TRACE(")\n");
-
-    TRACE("nChannels: %u\n", fmt->nChannels);
-    TRACE("nSamplesPerSec: %lu\n", fmt->nSamplesPerSec);
-    TRACE("nAvgBytesPerSec: %lu\n", fmt->nAvgBytesPerSec);
-    TRACE("nBlockAlign: %u\n", fmt->nBlockAlign);
-    TRACE("wBitsPerSample: %u\n", fmt->wBitsPerSample);
-    TRACE("cbSize: %u\n", fmt->cbSize);
-
-    if (fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
-        WAVEFORMATEXTENSIBLE *fmtex = (void *)fmt;
-        TRACE("dwChannelMask: %08lx\n", fmtex->dwChannelMask);
-        TRACE("Samples: %04x\n", fmtex->Samples.wReserved);
-        TRACE("SubFormat: %s\n", wine_dbgstr_guid(&fmtex->SubFormat));
-    }
-}
-
-static DWORD CALLBACK main_loop_func(void *event)
-{
-    struct main_loop_params params;
-
-    SetThreadDescription(GetCurrentThread(), L"audio_client_main");
-
-    params.event = event;
-
-    wine_unix_call(main_loop, &params);
-
-    return 0;
-}
-
-HRESULT main_loop_start(void)
-{
-    if (!main_loop_thread) {
-        HANDLE event = CreateEventW(NULL, TRUE, FALSE, NULL);
-        if (!(main_loop_thread = CreateThread(NULL, 0, main_loop_func, event, 0, NULL))) {
-            ERR("Failed to create main loop thread\n");
-            CloseHandle(event);
-            return E_FAIL;
-        }
-
-        SetThreadPriority(main_loop_thread, THREAD_PRIORITY_TIME_CRITICAL);
-        WaitForSingleObject(event, INFINITE);
-        CloseHandle(event);
-    }
-
-    return S_OK;
-}
-
-static DWORD CALLBACK timer_loop_func(void *user)
-{
-    struct timer_loop_params params;
-    struct audio_client *This = user;
-
-    SetThreadDescription(GetCurrentThread(), L"audio_client_timer");
-
-    params.stream = This->stream;
-
-    wine_unix_call(timer_loop, &params);
-
-    return 0;
-}
-
-HRESULT stream_release(stream_handle stream, HANDLE timer_thread)
-{
-    struct release_stream_params params;
-
-    params.stream       = stream;
-    params.timer_thread = timer_thread;
-
-    wine_unix_call(release_stream, &params);
-
-    return params.result;
-}
-
-static BOOL query_productname(void *data, LANGANDCODEPAGE *lang, LPVOID *buffer, UINT *len)
-{
-    WCHAR pn[37];
-    swprintf(pn, ARRAY_SIZE(pn), L"\\StringFileInfo\\%04x%04x\\ProductName", lang->wLanguage, lang->wCodePage);
-    return VerQueryValueW(data, pn, buffer, len) && *len;
-}
-
-WCHAR *get_application_name(void)
-{
-    WCHAR path[MAX_PATH], *name;
-    UINT translate_size, productname_size;
-    LANGANDCODEPAGE *translate;
-    LPVOID productname;
-    BOOL found = FALSE;
-    void *data = NULL;
-    unsigned int i;
-    LCID locale;
-    DWORD size;
-
-    GetModuleFileNameW(NULL, path, ARRAY_SIZE(path));
-
-    size = GetFileVersionInfoSizeW(path, NULL);
-    if (!size)
-        goto skip;
-
-    data = malloc(size);
-    if (!data)
-        goto skip;
-
-    if (!GetFileVersionInfoW(path, 0, size, data))
-        goto skip;
-
-    if (!VerQueryValueW(data, L"\\VarFileInfo\\Translation", (LPVOID *)&translate, &translate_size))
-        goto skip;
-
-    /* No translations found. */
-    if (translate_size < sizeof(LANGANDCODEPAGE))
-        goto skip;
-
-    /* The following code will try to find the best translation. We first search for an
-     * exact match of the language, then a match of the language PRIMARYLANGID, then we
-     * search for a LANG_NEUTRAL match, and if that still doesn't work we pick the
-     * first entry which contains a proper productname. */
-    locale = GetThreadLocale();
-
-    for (i = 0; i < translate_size / sizeof(LANGANDCODEPAGE); i++) {
-        if (translate[i].wLanguage == locale &&
-            query_productname(data, &translate[i], &productname, &productname_size)) {
-            found = TRUE;
-            break;
-        }
-    }
-
-    if (!found) {
-        for (i = 0; i < translate_size / sizeof(LANGANDCODEPAGE); i++) {
-            if (PRIMARYLANGID(translate[i].wLanguage) == PRIMARYLANGID(locale) &&
-                query_productname(data, &translate[i], &productname, &productname_size)) {
-                found = TRUE;
-                break;
-            }
-        }
-    }
-
-    if (!found) {
-        for (i = 0; i < translate_size / sizeof(LANGANDCODEPAGE); i++) {
-            if (PRIMARYLANGID(translate[i].wLanguage) == LANG_NEUTRAL &&
-                query_productname(data, &translate[i], &productname, &productname_size)) {
-                found = TRUE;
-                break;
-            }
-        }
-    }
-
-    if (!found) {
-        for (i = 0; i < translate_size / sizeof(LANGANDCODEPAGE); i++) {
-            if (query_productname(data, &translate[i], &productname, &productname_size)) {
-                found = TRUE;
-                break;
-            }
-        }
-    }
-skip:
-    if (found) {
-        name = wcsdup(productname);
-        free(data);
-        return name;
-    }
-
-    free(data);
-
-    name = wcsrchr(path, '\\');
-    if (!name)
-        name = path;
-    else
-        name++;
-
-    return wcsdup(name);
-}
-
-static HRESULT WINAPI capture_QueryInterface(IAudioCaptureClient *iface, REFIID riid, void **ppv)
-{
-    struct audio_client *This = impl_from_IAudioCaptureClient(iface);
-
-    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
-
-    if (!ppv)
-        return E_POINTER;
-
-    if (IsEqualIID(riid, &IID_IUnknown) ||
-        IsEqualIID(riid, &IID_IAudioCaptureClient))
-        *ppv = iface;
-    else if (IsEqualIID(riid, &IID_IMarshal)) {
-        return IUnknown_QueryInterface(This->marshal, riid, ppv);
-    } else {
-        *ppv = NULL;
-        return E_NOINTERFACE;
-    }
-
-    IUnknown_AddRef((IUnknown *)*ppv);
-
-    return S_OK;
-}
-
-static ULONG WINAPI capture_AddRef(IAudioCaptureClient *iface)
-{
-    struct audio_client *This = impl_from_IAudioCaptureClient(iface);
-    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
-}
-
-static ULONG WINAPI capture_Release(IAudioCaptureClient *iface)
-{
-    struct audio_client *This = impl_from_IAudioCaptureClient(iface);
-    return IAudioClient3_Release(&This->IAudioClient3_iface);
-}
-
-static HRESULT WINAPI capture_GetBuffer(IAudioCaptureClient *iface, BYTE **data, UINT32 *frames,
-                                        DWORD *flags, UINT64 *devpos, UINT64 *qpcpos)
-{
-    struct audio_client *This = impl_from_IAudioCaptureClient(iface);
-    struct get_capture_buffer_params params;
-
-    TRACE("(%p)->(%p, %p, %p, %p, %p)\n", This, data, frames, flags, devpos, qpcpos);
-
-    if (!data)
-        return E_POINTER;
-
-    *data = NULL;
-
-    if (!frames || !flags)
-        return E_POINTER;
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    params.stream = This->stream;
-    params.data   = data;
-    params.frames = frames;
-    params.flags  = (UINT *)flags;
-    params.devpos = devpos;
-    params.qpcpos = qpcpos;
-
-    wine_unix_call(get_capture_buffer, &params);
-
-    return params.result;
-}
-
-static HRESULT WINAPI capture_ReleaseBuffer(IAudioCaptureClient *iface, UINT32 done)
-{
-    struct audio_client *This = impl_from_IAudioCaptureClient(iface);
-    struct release_capture_buffer_params params;
-
-    TRACE("(%p)->(%u)\n", This, done);
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    params.stream = This->stream;
-    params.done   = done;
-
-    wine_unix_call(release_capture_buffer, &params);
-
-    return params.result;
-}
-
-static HRESULT WINAPI capture_GetNextPacketSize(IAudioCaptureClient *iface, UINT32 *frames)
-{
-    struct audio_client *This = impl_from_IAudioCaptureClient(iface);
-    struct get_next_packet_size_params params;
-
-    TRACE("(%p)->(%p)\n", This, frames);
-
-    if (!frames)
-        return E_POINTER;
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    params.stream = This->stream;
-    params.frames = frames;
-
-    wine_unix_call(get_next_packet_size, &params);
-
-    return params.result;
-}
-
-const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl =
-{
-    capture_QueryInterface,
-    capture_AddRef,
-    capture_Release,
-    capture_GetBuffer,
-    capture_ReleaseBuffer,
-    capture_GetNextPacketSize
-};
-
-static HRESULT WINAPI client_QueryInterface(IAudioClient3 *iface, REFIID riid, void **ppv)
-{
-    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
-
-    if (!ppv)
-        return E_POINTER;
-
-    if (IsEqualIID(riid, &IID_IUnknown) ||
-        IsEqualIID(riid, &IID_IAudioClient) ||
-        IsEqualIID(riid, &IID_IAudioClient2) ||
-        IsEqualIID(riid, &IID_IAudioClient3))
-        *ppv = iface;
-    else if(IsEqualIID(riid, &IID_IMarshal)) {
-        struct audio_client *This = impl_from_IAudioClient3(iface);
-        return IUnknown_QueryInterface(This->marshal, riid, ppv);
-    } else {
-        *ppv = NULL;
-        return E_NOINTERFACE;
-    }
-
-    IUnknown_AddRef((IUnknown *)*ppv);
-
-    return S_OK;
-}
-
-static ULONG WINAPI client_AddRef(IAudioClient3 *iface)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    ULONG ref = InterlockedIncrement(&This->ref);
-    TRACE("(%p) Refcount now %lu\n", This, ref);
-    return ref;
-}
-
-static ULONG WINAPI client_Release(IAudioClient3 *iface)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    ULONG ref = InterlockedDecrement(&This->ref);
-    TRACE("(%p) Refcount now %lu\n", This, ref);
-
-    if (!ref) {
-        IAudioClient3_Stop(iface);
-        IMMDevice_Release(This->parent);
-        IUnknown_Release(This->marshal);
-
-        if (This->session) {
-            sessions_lock();
-            list_remove(&This->entry);
-            sessions_unlock();
-        }
-
-        free(This->vols);
-
-        if (This->stream)
-            stream_release(This->stream, This->timer_thread);
-
-        free(This);
-    }
-
-    return ref;
-}
-
-static HRESULT WINAPI client_Initialize(IAudioClient3 *iface, AUDCLNT_SHAREMODE mode, DWORD flags,
-                                 REFERENCE_TIME duration, REFERENCE_TIME period,
-                                 const WAVEFORMATEX *fmt, const GUID *sessionguid)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    struct create_stream_params params;
-    UINT32 i, channel_count;
-    stream_handle stream;
-    WCHAR *name;
-
-    TRACE("(%p)->(%x, %lx, %s, %s, %p, %s)\n", This, mode, flags, wine_dbgstr_longlong(duration),
-                                               wine_dbgstr_longlong(period), fmt,
-                                               debugstr_guid(sessionguid));
-
-    if (!fmt)
-        return E_POINTER;
-
-    dump_fmt(fmt);
-
-    if (mode != AUDCLNT_SHAREMODE_SHARED && mode != AUDCLNT_SHAREMODE_EXCLUSIVE)
-        return E_INVALIDARG;
-
-    if (flags & ~(AUDCLNT_STREAMFLAGS_CROSSPROCESS |
-                  AUDCLNT_STREAMFLAGS_LOOPBACK |
-                  AUDCLNT_STREAMFLAGS_EVENTCALLBACK |
-                  AUDCLNT_STREAMFLAGS_NOPERSIST |
-                  AUDCLNT_STREAMFLAGS_RATEADJUST |
-                  AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED |
-                  AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE |
-                  AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED |
-                  AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY |
-                  AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM)) {
-        FIXME("Unknown flags: %08lx\n", flags);
-        return E_INVALIDARG;
-    }
-
-    sessions_lock();
-
-    if (This->stream) {
-        sessions_unlock();
-        return AUDCLNT_E_ALREADY_INITIALIZED;
-    }
-
-    if (FAILED(params.result = main_loop_start())) {
-        sessions_unlock();
-        return params.result;
-    }
-
-    params.name = name   = get_application_name();
-    params.device        = This->device_name;
-    params.flow          = This->dataflow;
-    params.share         = mode;
-    params.flags         = flags;
-    params.duration      = duration;
-    params.period        = period;
-    params.fmt           = fmt;
-    params.channel_count = &channel_count;
-    params.stream        = &stream;
-
-    wine_unix_call(create_stream, &params);
-
-    free(name);
-
-    if (FAILED(params.result)) {
-        sessions_unlock();
-        return params.result;
-    }
-
-    if (!(This->vols = malloc(channel_count * sizeof(*This->vols)))) {
-        params.result = E_OUTOFMEMORY;
-        goto exit;
-    }
-
-    for (i = 0; i < channel_count; i++)
-        This->vols[i] = 1.f;
-
-    params.result = get_audio_session(sessionguid, This->parent, channel_count, &This->session);
-
-exit:
-    if (FAILED(params.result)) {
-        stream_release(stream, NULL);
-        free(This->vols);
-        This->vols = NULL;
-    } else {
-        list_add_tail(&This->session->clients, &This->entry);
-        This->stream = stream;
-        This->channel_count = channel_count;
-        set_stream_volumes(This);
-    }
-
-    sessions_unlock();
-
-    return params.result;
-}
-
-static HRESULT WINAPI client_GetBufferSize(IAudioClient3 *iface, UINT32 *out)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    struct get_buffer_size_params params;
-
-    TRACE("(%p)->(%p)\n", This, out);
-
-    if (!out)
-        return E_POINTER;
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    params.stream = This->stream;
-    params.frames = out;
-
-    wine_unix_call(get_buffer_size, &params);
-
-    return params.result;
-}
-
-static HRESULT WINAPI client_GetStreamLatency(IAudioClient3 *iface, REFERENCE_TIME *latency)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    struct get_latency_params params;
-
-    TRACE("(%p)->(%p)\n", This, latency);
-
-    if (!latency)
-        return E_POINTER;
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    params.stream  = This->stream;
-    params.latency = latency;
-
-    wine_unix_call(get_latency, &params);
-
-    return params.result;
-}
-
-static HRESULT WINAPI client_GetCurrentPadding(IAudioClient3 *iface, UINT32 *out)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    struct get_current_padding_params params;
-
-    TRACE("(%p)->(%p)\n", This, out);
-
-    if (!out)
-        return E_POINTER;
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    params.stream  = This->stream;
-    params.padding = out;
-
-    wine_unix_call(get_current_padding, &params);
-
-    return params.result;
-}
-
-static HRESULT WINAPI client_IsFormatSupported(IAudioClient3 *iface, AUDCLNT_SHAREMODE mode,
-                                        const WAVEFORMATEX *fmt, WAVEFORMATEX **out)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    struct is_format_supported_params params;
-
-    TRACE("(%p)->(%x, %p, %p)\n", This, mode, fmt, out);
-
-    if (fmt)
-        dump_fmt(fmt);
-
-    params.device  = This->device_name;
-    params.flow    = This->dataflow;
-    params.share   = mode;
-    params.fmt_in  = fmt;
-    params.fmt_out = NULL;
-
-    if (out) {
-        *out = NULL;
-        if (mode == AUDCLNT_SHAREMODE_SHARED)
-            params.fmt_out = CoTaskMemAlloc(sizeof(*params.fmt_out));
-    }
-
-    wine_unix_call(is_format_supported, &params);
-
-    if (params.result == S_FALSE)
-        *out = &params.fmt_out->Format;
-    else
-        CoTaskMemFree(params.fmt_out);
-
-    return params.result;
-}
-
-static HRESULT WINAPI client_GetMixFormat(IAudioClient3 *iface, WAVEFORMATEX **pwfx)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    struct get_mix_format_params params;
-
-    TRACE("(%p)->(%p)\n", This, pwfx);
-
-    if (!pwfx)
-        return E_POINTER;
-
-    *pwfx = NULL;
-
-    params.device = This->device_name;
-    params.flow   = This->dataflow;
-    params.fmt    = CoTaskMemAlloc(sizeof(WAVEFORMATEXTENSIBLE));
-    if (!params.fmt)
-        return E_OUTOFMEMORY;
-
-    wine_unix_call(get_mix_format, &params);
-
-    if (SUCCEEDED(params.result)) {
-        *pwfx = &params.fmt->Format;
-        dump_fmt(*pwfx);
-    } else
-        CoTaskMemFree(params.fmt);
-
-    return params.result;
-}
-
-static HRESULT WINAPI client_GetDevicePeriod(IAudioClient3 *iface, REFERENCE_TIME *defperiod,
-                                      REFERENCE_TIME *minperiod)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    struct get_device_period_params params;
-
-    TRACE("(%p)->(%p, %p)\n", This, defperiod, minperiod);
-
-    if (!defperiod && !minperiod)
-        return E_POINTER;
-
-    params.device     = This->device_name;
-    params.flow       = This->dataflow;
-    params.def_period = defperiod;
-    params.min_period = minperiod;
-
-    wine_unix_call(get_device_period, &params);
-
-    return params.result;
-}
-
-static HRESULT WINAPI client_Start(IAudioClient3 *iface)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    struct start_params params;
-
-    TRACE("(%p)\n", This);
-
-    sessions_lock();
-
-    if (!This->stream) {
-        sessions_unlock();
-        return AUDCLNT_E_NOT_INITIALIZED;
-    }
-
-    params.stream = This->stream;
-    wine_unix_call(start, &params);
-
-    if (SUCCEEDED(params.result) && !This->timer_thread) {
-        if ((This->timer_thread = CreateThread(NULL, 0, timer_loop_func, This, 0, NULL)))
-            SetThreadPriority(This->timer_thread, THREAD_PRIORITY_TIME_CRITICAL);
-        else {
-            IAudioClient3_Stop(&This->IAudioClient3_iface);
-            params.result = E_FAIL;
-        }
-    }
-
-    sessions_unlock();
-
-    return params.result;
-}
-
-static HRESULT WINAPI client_Stop(IAudioClient3 *iface)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    struct stop_params params;
-
-    TRACE("(%p)\n", This);
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    params.stream = This->stream;
-
-    wine_unix_call(stop, &params);
-
-    return params.result;
-}
-
-static HRESULT WINAPI client_Reset(IAudioClient3 *iface)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    struct reset_params params;
-
-    TRACE("(%p)\n", This);
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    params.stream = This->stream;
-
-    wine_unix_call(reset, &params);
-
-    return params.result;
-}
-
-static HRESULT WINAPI client_SetEventHandle(IAudioClient3 *iface, HANDLE event)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    struct set_event_handle_params params;
-
-    TRACE("(%p)->(%p)\n", This, event);
-
-    if (!event)
-        return E_INVALIDARG;
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    params.stream = This->stream;
-    params.event  = event;
-
-    wine_unix_call(set_event_handle, &params);
-
-    return params.result;
-}
-
-static HRESULT WINAPI client_GetService(IAudioClient3 *iface, REFIID riid, void **ppv)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    HRESULT hr;
-
-    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), ppv);
-
-    if (!ppv)
-        return E_POINTER;
-
-    *ppv = NULL;
-
-    sessions_lock();
-
-    if (!This->stream) {
-        hr = AUDCLNT_E_NOT_INITIALIZED;
-        goto exit;
-    }
-
-    if (IsEqualIID(riid, &IID_IAudioRenderClient)) {
-        if (This->dataflow != eRender) {
-            hr = AUDCLNT_E_WRONG_ENDPOINT_TYPE;
-            goto exit;
-        }
-
-        IAudioRenderClient_AddRef(&This->IAudioRenderClient_iface);
-        *ppv = &This->IAudioRenderClient_iface;
-    } else if (IsEqualIID(riid, &IID_IAudioCaptureClient)) {
-        if (This->dataflow != eCapture) {
-            hr = AUDCLNT_E_WRONG_ENDPOINT_TYPE;
-            goto exit;
-        }
-
-        IAudioCaptureClient_AddRef(&This->IAudioCaptureClient_iface);
-        *ppv = &This->IAudioCaptureClient_iface;
-    } else if (IsEqualIID(riid, &IID_IAudioClock)) {
-        IAudioClock_AddRef(&This->IAudioClock_iface);
-        *ppv = &This->IAudioClock_iface;
-    } else if (IsEqualIID(riid, &IID_IAudioStreamVolume)) {
-        IAudioStreamVolume_AddRef(&This->IAudioStreamVolume_iface);
-        *ppv = &This->IAudioStreamVolume_iface;
-    } else if (IsEqualIID(riid, &IID_IAudioSessionControl) ||
-               IsEqualIID(riid, &IID_IChannelAudioVolume) ||
-               IsEqualIID(riid, &IID_ISimpleAudioVolume)) {
-        const BOOLEAN new_session = !This->session_wrapper;
-        if (new_session) {
-            This->session_wrapper = session_wrapper_create(This);
-            if (!This->session_wrapper) {
-                hr = E_OUTOFMEMORY;
-                goto exit;
-            }
-        }
-
-        if (IsEqualIID(riid, &IID_IAudioSessionControl))
-            *ppv = &This->session_wrapper->IAudioSessionControl2_iface;
-        else if (IsEqualIID(riid, &IID_IChannelAudioVolume))
-            *ppv = &This->session_wrapper->IChannelAudioVolume_iface;
-        else if (IsEqualIID(riid, &IID_ISimpleAudioVolume))
-            *ppv = &This->session_wrapper->ISimpleAudioVolume_iface;
-
-        if (!new_session)
-            IUnknown_AddRef((IUnknown *)*ppv);
-    } else {
-            FIXME("stub %s\n", debugstr_guid(riid));
-            hr = E_NOINTERFACE;
-            goto exit;
-    }
-
-    hr = S_OK;
-exit:
-    sessions_unlock();
-
-    return hr;
-}
-
-static HRESULT WINAPI client_IsOffloadCapable(IAudioClient3 *iface, AUDIO_STREAM_CATEGORY category,
-                                       BOOL *offload_capable)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-
-    TRACE("(%p)->(0x%x, %p)\n", This, category, offload_capable);
-
-    if (!offload_capable)
-        return E_INVALIDARG;
-
-    *offload_capable = FALSE;
-
-    return S_OK;
-}
-
-static HRESULT WINAPI client_SetClientProperties(IAudioClient3 *iface,
-                                          const AudioClientProperties *prop)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    const Win8AudioClientProperties *legacy_prop = (const Win8AudioClientProperties *)prop;
-
-    TRACE("(%p)->(%p)\n", This, prop);
-
-    if (!legacy_prop)
-        return E_POINTER;
-
-    if (legacy_prop->cbSize == sizeof(AudioClientProperties)) {
-        TRACE("{ bIsOffload: %u, eCategory: 0x%x, Options: 0x%x }\n", legacy_prop->bIsOffload,
-                                                                      legacy_prop->eCategory,
-                                                                      prop->Options);
-    } else if(legacy_prop->cbSize == sizeof(Win8AudioClientProperties)) {
-        TRACE("{ bIsOffload: %u, eCategory: 0x%x }\n", legacy_prop->bIsOffload,
-                                                       legacy_prop->eCategory);
-    } else {
-        WARN("Unsupported Size = %d\n", legacy_prop->cbSize);
-        return E_INVALIDARG;
-    }
-
-    if (legacy_prop->bIsOffload)
-        return AUDCLNT_E_ENDPOINT_OFFLOAD_NOT_CAPABLE;
-
-    return S_OK;
-}
-
-static HRESULT WINAPI client_GetBufferSizeLimits(IAudioClient3 *iface, const WAVEFORMATEX *format,
-                                          BOOL event_driven, REFERENCE_TIME *min_duration,
-                                          REFERENCE_TIME *max_duration)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    FIXME("(%p)->(%p, %u, %p, %p) - stub\n", This, format, event_driven, min_duration, max_duration);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI client_GetSharedModeEnginePeriod(IAudioClient3 *iface,
-                                                const WAVEFORMATEX *format,
-                                                UINT32 *default_period_frames,
-                                                UINT32 *unit_period_frames,
-                                                UINT32 *min_period_frames,
-                                                UINT32 *max_period_frames)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    FIXME("(%p)->(%p, %p, %p, %p, %p) - stub\n", This, format, default_period_frames,
-                                                 unit_period_frames, min_period_frames,
-                                                 max_period_frames);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI client_GetCurrentSharedModeEnginePeriod(IAudioClient3 *iface,
-                                                       WAVEFORMATEX **cur_format,
-                                                       UINT32 *cur_period_frames)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    FIXME("(%p)->(%p, %p) - stub\n", This, cur_format, cur_period_frames);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI client_InitializeSharedAudioStream(IAudioClient3 *iface, DWORD flags,
-                                                  UINT32 period_frames,
-                                                  const WAVEFORMATEX *format,
-                                                  const GUID *session_guid)
-{
-    struct audio_client *This = impl_from_IAudioClient3(iface);
-    FIXME("(%p)->(0x%lx, %u, %p, %s) - stub\n", This, flags, period_frames, format, debugstr_guid(session_guid));
-    return E_NOTIMPL;
-}
-
-const IAudioClient3Vtbl AudioClient3_Vtbl =
-{
-    client_QueryInterface,
-    client_AddRef,
-    client_Release,
-    client_Initialize,
-    client_GetBufferSize,
-    client_GetStreamLatency,
-    client_GetCurrentPadding,
-    client_IsFormatSupported,
-    client_GetMixFormat,
-    client_GetDevicePeriod,
-    client_Start,
-    client_Stop,
-    client_Reset,
-    client_SetEventHandle,
-    client_GetService,
-    client_IsOffloadCapable,
-    client_SetClientProperties,
-    client_GetBufferSizeLimits,
-    client_GetSharedModeEnginePeriod,
-    client_GetCurrentSharedModeEnginePeriod,
-    client_InitializeSharedAudioStream,
-};
-
-static HRESULT WINAPI clock_QueryInterface(IAudioClock *iface, REFIID riid, void **ppv)
-{
-    struct audio_client *This = impl_from_IAudioClock(iface);
-
-    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
-
-    if (!ppv)
-        return E_POINTER;
-
-    if (IsEqualIID(riid, &IID_IUnknown) ||
-        IsEqualIID(riid, &IID_IAudioClock))
-        *ppv = iface;
-    else if (IsEqualIID(riid, &IID_IAudioClock2))
-        *ppv = &This->IAudioClock2_iface;
-    else if (IsEqualIID(riid, &IID_IMarshal)) {
-        return IUnknown_QueryInterface(This->marshal, riid, ppv);
-    } else {
-        *ppv = NULL;
-        return E_NOINTERFACE;
-    }
-
-    IUnknown_AddRef((IUnknown *)*ppv);
-
-    return S_OK;
-}
-
-static ULONG WINAPI clock_AddRef(IAudioClock *iface)
-{
-    struct audio_client *This = impl_from_IAudioClock(iface);
-    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
-}
-
-static ULONG WINAPI clock_Release(IAudioClock *iface)
-{
-    struct audio_client *This = impl_from_IAudioClock(iface);
-    return IAudioClient3_Release(&This->IAudioClient3_iface);
-}
-
-static HRESULT WINAPI clock_GetFrequency(IAudioClock *iface, UINT64 *freq)
-{
-    struct audio_client *This = impl_from_IAudioClock(iface);
-    struct get_frequency_params params;
-
-    TRACE("(%p)->(%p)\n", This, freq);
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    params.stream = This->stream;
-    params.freq   = freq;
-
-    wine_unix_call(get_frequency, &params);
-
-    return params.result;
-}
-
-static HRESULT WINAPI clock_GetPosition(IAudioClock *iface, UINT64 *pos, UINT64 *qpctime)
-{
-    struct audio_client *This = impl_from_IAudioClock(iface);
-    struct get_position_params params;
-
-    TRACE("(%p)->(%p, %p)\n", This, pos, qpctime);
-
-    if (!pos)
-        return E_POINTER;
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    params.stream  = This->stream;
-    params.device  = FALSE;
-    params.pos     = pos;
-    params.qpctime = qpctime;
-
-    wine_unix_call(get_position, &params);
-
-    return params.result;
-}
-
-static HRESULT WINAPI clock_GetCharacteristics(IAudioClock *iface, DWORD *chars)
-{
-    struct audio_client *This = impl_from_IAudioClock(iface);
-
-    TRACE("(%p)->(%p)\n", This, chars);
-
-    if (!chars)
-        return E_POINTER;
-
-    *chars = AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ;
-
-    return S_OK;
-}
-
-const IAudioClockVtbl AudioClock_Vtbl =
-{
-    clock_QueryInterface,
-    clock_AddRef,
-    clock_Release,
-    clock_GetFrequency,
-    clock_GetPosition,
-    clock_GetCharacteristics
-};
-
-static HRESULT WINAPI clock2_QueryInterface(IAudioClock2 *iface, REFIID riid, void **ppv)
-{
-    struct audio_client *This = impl_from_IAudioClock2(iface);
-    return IAudioClock_QueryInterface(&This->IAudioClock_iface, riid, ppv);
-}
-
-static ULONG WINAPI clock2_AddRef(IAudioClock2 *iface)
-{
-    struct audio_client *This = impl_from_IAudioClock2(iface);
-    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
-}
-
-static ULONG WINAPI clock2_Release(IAudioClock2 *iface)
-{
-    struct audio_client *This = impl_from_IAudioClock2(iface);
-    return IAudioClient3_Release(&This->IAudioClient3_iface);
-}
-
-static HRESULT WINAPI clock2_GetDevicePosition(IAudioClock2 *iface, UINT64 *pos, UINT64 *qpctime)
-{
-    struct audio_client *This = impl_from_IAudioClock2(iface);
-    struct get_position_params params;
-
-    TRACE("(%p)->(%p, %p)\n", This, pos, qpctime);
-
-    if (!pos)
-        return E_POINTER;
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    params.stream  = This->stream;
-    params.device  = TRUE;
-    params.pos     = pos;
-    params.qpctime = qpctime;
-
-    wine_unix_call(get_position, &params);
-
-    return params.result;
-}
-
-const IAudioClock2Vtbl AudioClock2_Vtbl =
-{
-    clock2_QueryInterface,
-    clock2_AddRef,
-    clock2_Release,
-    clock2_GetDevicePosition
-};
-
-static HRESULT WINAPI render_QueryInterface(IAudioRenderClient *iface, REFIID riid, void **ppv)
-{
-    struct audio_client *This = impl_from_IAudioRenderClient(iface);
-
-    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
-
-    if (!ppv)
-        return E_POINTER;
-
-    if (IsEqualIID(riid, &IID_IUnknown) ||
-        IsEqualIID(riid, &IID_IAudioRenderClient))
-        *ppv = iface;
-    else if (IsEqualIID(riid, &IID_IMarshal)) {
-        return IUnknown_QueryInterface(This->marshal, riid, ppv);
-    } else {
-        *ppv = NULL;
-        return E_NOINTERFACE;
-    }
-
-    IUnknown_AddRef((IUnknown *)*ppv);
-
-    return S_OK;
-}
-
-static ULONG WINAPI render_AddRef(IAudioRenderClient *iface)
-{
-    struct audio_client *This = impl_from_IAudioRenderClient(iface);
-    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
-}
-
-static ULONG WINAPI render_Release(IAudioRenderClient *iface)
-{
-    struct audio_client *This = impl_from_IAudioRenderClient(iface);
-    return IAudioClient3_Release(&This->IAudioClient3_iface);
-}
-
-static HRESULT WINAPI render_GetBuffer(IAudioRenderClient *iface, UINT32 frames, BYTE **data)
-{
-    struct audio_client *This = impl_from_IAudioRenderClient(iface);
-    struct get_render_buffer_params params;
-
-    TRACE("(%p)->(%u, %p)\n", This, frames, data);
-
-    if (!data)
-        return E_POINTER;
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    *data = NULL;
-
-    params.stream = This->stream;
-    params.frames = frames;
-    params.data   = data;
-
-    wine_unix_call(get_render_buffer, &params);
-
-    return params.result;
-}
-
-static HRESULT WINAPI render_ReleaseBuffer(IAudioRenderClient *iface, UINT32 written_frames,
-                                           DWORD flags)
-{
-    struct audio_client *This = impl_from_IAudioRenderClient(iface);
-    struct release_render_buffer_params params;
-
-    TRACE("(%p)->(%u, %lx)\n", This, written_frames, flags);
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    params.stream         = This->stream;
-    params.written_frames = written_frames;
-    params.flags          = flags;
-
-    wine_unix_call(release_render_buffer, &params);
-
-    return params.result;
-}
-
-const IAudioRenderClientVtbl AudioRenderClient_Vtbl = {
-    render_QueryInterface,
-    render_AddRef,
-    render_Release,
-    render_GetBuffer,
-    render_ReleaseBuffer
-};
-
-static HRESULT WINAPI streamvolume_QueryInterface(IAudioStreamVolume *iface, REFIID riid,
-                                                  void **ppv)
-{
-    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
-
-    if (!ppv)
-        return E_POINTER;
-
-    if (IsEqualIID(riid, &IID_IUnknown) ||
-        IsEqualIID(riid, &IID_IAudioStreamVolume))
-        *ppv = iface;
-    else if (IsEqualIID(riid, &IID_IMarshal)) {
-        struct audio_client *This = impl_from_IAudioStreamVolume(iface);
-        return IUnknown_QueryInterface(This->marshal, riid, ppv);
-    } else {
-        *ppv = NULL;
-        return E_NOINTERFACE;
-    }
-
-    IUnknown_AddRef((IUnknown *)*ppv);
-
-    return S_OK;
-}
-
-static ULONG WINAPI streamvolume_AddRef(IAudioStreamVolume *iface)
-{
-    struct audio_client *This = impl_from_IAudioStreamVolume(iface);
-    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
-}
-
-static ULONG WINAPI streamvolume_Release(IAudioStreamVolume *iface)
-{
-    struct audio_client *This = impl_from_IAudioStreamVolume(iface);
-    return IAudioClient3_Release(&This->IAudioClient3_iface);
-}
-
-static HRESULT WINAPI streamvolume_GetChannelCount(IAudioStreamVolume *iface, UINT32 *out)
-{
-    struct audio_client *This = impl_from_IAudioStreamVolume(iface);
-
-    TRACE("(%p)->(%p)\n", This, out);
-
-    if (!out)
-        return E_POINTER;
-
-    *out = This->channel_count;
-
-    return S_OK;
-}
-
-static HRESULT WINAPI streamvolume_SetChannelVolume(IAudioStreamVolume *iface, UINT32 index,
-                                                    float level)
-{
-    struct audio_client *This = impl_from_IAudioStreamVolume(iface);
-
-    TRACE("(%p)->(%d, %f)\n", This, index, level);
-
-    if (level < 0.f || level > 1.f)
-        return E_INVALIDARG;
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    if (index >= This->channel_count)
-        return E_INVALIDARG;
-
-    sessions_lock();
-
-    This->vols[index] = level;
-    set_stream_volumes(This);
-
-    sessions_unlock();
-
-    return S_OK;
-}
-
-static HRESULT WINAPI streamvolume_GetChannelVolume(IAudioStreamVolume *iface, UINT32 index,
-                                                    float *level)
-{
-    struct audio_client *This = impl_from_IAudioStreamVolume(iface);
-
-    TRACE("(%p)->(%d, %p)\n", This, index, level);
-
-    if (!level)
-        return E_POINTER;
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    if (index >= This->channel_count)
-        return E_INVALIDARG;
-
-    *level = This->vols[index];
-
-    return S_OK;
-}
-
-static HRESULT WINAPI streamvolume_SetAllVolumes(IAudioStreamVolume *iface, UINT32 count,
-                                                 const float *levels)
-{
-    struct audio_client *This = impl_from_IAudioStreamVolume(iface);
-    unsigned int i;
-
-    TRACE("(%p)->(%d, %p)\n", This, count, levels);
-
-    if (!levels)
-        return E_POINTER;
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    if (count != This->channel_count)
-        return E_INVALIDARG;
-
-    sessions_lock();
-
-    for (i = 0; i < count; ++i)
-        This->vols[i] = levels[i];
-    set_stream_volumes(This);
-
-    sessions_unlock();
-
-    return S_OK;
-}
-
-static HRESULT WINAPI streamvolume_GetAllVolumes(IAudioStreamVolume *iface, UINT32 count,
-                                                 float *levels)
-{
-    struct audio_client *This = impl_from_IAudioStreamVolume(iface);
-    unsigned int i;
-
-    TRACE("(%p)->(%d, %p)\n", This, count, levels);
-
-    if (!levels)
-        return E_POINTER;
-
-    if (!This->stream)
-        return AUDCLNT_E_NOT_INITIALIZED;
-
-    if (count != This->channel_count)
-        return E_INVALIDARG;
-
-    sessions_lock();
-
-    for (i = 0; i < count; ++i)
-        levels[i] = This->vols[i];
-
-    sessions_unlock();
-
-    return S_OK;
-}
-
-const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl =
-{
-    streamvolume_QueryInterface,
-    streamvolume_AddRef,
-    streamvolume_Release,
-    streamvolume_GetChannelCount,
-    streamvolume_SetChannelVolume,
-    streamvolume_GetChannelVolume,
-    streamvolume_SetAllVolumes,
-    streamvolume_GetAllVolumes
-};
-
-HRESULT AudioClient_Create(GUID *guid, IMMDevice *device, IAudioClient **out)
-{
-    struct audio_client *This;
-    char *name;
-    EDataFlow dataflow;
-    size_t size;
-    HRESULT hr;
-
-    TRACE("%s %p %p\n", debugstr_guid(guid), device, out);
-
-    *out = NULL;
-
-    if (!drvs.pget_device_name_from_guid(guid, &name, &dataflow))
-        return AUDCLNT_E_DEVICE_INVALIDATED;
-
-    if (dataflow != eRender && dataflow != eCapture) {
-        free(name);
-        return E_UNEXPECTED;
-    }
-
-    size = strlen(name) + 1;
-    This = calloc(1, FIELD_OFFSET(struct audio_client, device_name[size]));
-    if (!This) {
-        free(name);
-        return E_OUTOFMEMORY;
-    }
-
-    memcpy(This->device_name, name, size);
-    free(name);
-
-    This->IAudioCaptureClient_iface.lpVtbl = &AudioCaptureClient_Vtbl;
-    This->IAudioClient3_iface.lpVtbl       = &AudioClient3_Vtbl;
-    This->IAudioClock_iface.lpVtbl         = &AudioClock_Vtbl;
-    This->IAudioClock2_iface.lpVtbl        = &AudioClock2_Vtbl;
-    This->IAudioRenderClient_iface.lpVtbl  = &AudioRenderClient_Vtbl;
-    This->IAudioStreamVolume_iface.lpVtbl  = &AudioStreamVolume_Vtbl;
-
-    This->dataflow = dataflow;
-    This->parent   = device;
-
-    hr = CoCreateFreeThreadedMarshaler((IUnknown *)&This->IAudioClient3_iface, &This->marshal);
-    if (FAILED(hr)) {
-        free(This);
-        return hr;
-    }
-
-    IMMDevice_AddRef(This->parent);
-
-    *out = (IAudioClient *)&This->IAudioClient3_iface;
-    IAudioClient3_AddRef(&This->IAudioClient3_iface);
-
-    return S_OK;
-}
diff --git a/dlls/mmdevapi/devenum.c b/dlls/mmdevapi/devenum.c
index 11111111111..11111111111 100644
--- a/dlls/mmdevapi/devenum.c
+++ b/dlls/mmdevapi/devenum.c
@@ -17,8 +17,8 @@
  */
 
 #include <stdarg.h>
-#include <wchar.h>
 
+#define NONAMELESSUNION
 #define COBJMACROS
 #include "windef.h"
 #include "winbase.h"
@@ -37,13 +37,11 @@
 #include "audiopolicy.h"
 #include "spatialaudioclient.h"
 
-#include "mmdevapi_private.h"
+#include "mmdevapi.h"
 #include "devpkey.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(mmdevapi);
 
-DEFINE_GUID(GUID_NULL,0,0,0,0,0,0,0,0,0,0,0);
-
 static HKEY key_render;
 static HKEY key_capture;
 
@@ -191,41 +189,6 @@ static HRESULT MMDevice_GetPropValue(const GUID *devguid, DWORD flow, REFPROPERT
             break;
     }
     RegCloseKey(regkey);
-
-    /* Special case ContainerID as CLSID */
-    if(pv->vt == VT_BLOB && pv->blob.pBlobData && pv->blob.cbSize == 24 && pv->blob.pBlobData[0] == VT_CLSID && IsEqualPropertyKey(*key, DEVPKEY_Device_ContainerId)) {
-        GUID *guid = CoTaskMemAlloc(sizeof(GUID));
-        if (!guid) {
-            PropVariantClear(pv);
-            hr = E_OUTOFMEMORY;
-        } else {
-            memcpy(guid, pv->blob.pBlobData + 8, sizeof(GUID));
-            CoTaskMemFree(pv->blob.pBlobData);
-            pv->vt = VT_CLSID;
-            pv->puuid = guid;
-        }
-    }
-
-    return hr;
-}
-
-static HRESULT MMDevice_DeletePropValue(const GUID *devguid, DWORD flow, REFPROPERTYKEY key)
-{
-    WCHAR buffer[80];
-    const GUID *id = &key->fmtid;
-    HRESULT hr;
-    HKEY regkey;
-    LONG ret;
-
-    hr = MMDevPropStore_OpenPropKey(devguid, flow, &regkey);
-    if (FAILED(hr))
-        return hr;
-    wsprintfW( buffer, propkey_formatW, id->Data1, id->Data2, id->Data3,
-               id->Data4[0], id->Data4[1], id->Data4[2], id->Data4[3],
-               id->Data4[4], id->Data4[5], id->Data4[6], id->Data4[7], key->pid );
-    ret = RegDeleteValueW(regkey, buffer);
-    RegCloseKey(regkey);
-    TRACE("Deleting %s returned %lu\n", debugstr_w(buffer), ret);
     return hr;
 }
 
@@ -262,18 +225,6 @@ static HRESULT MMDevice_SetPropValue(const GUID *devguid, DWORD flow, REFPROPERT
             ret = RegSetValueExW(regkey, buffer, 0, REG_SZ, (const BYTE*)pv->pwszVal, sizeof(WCHAR)*(1+lstrlenW(pv->pwszVal)));
             break;
         }
-        case VT_CLSID:
-        {
-            if (IsEqualPropertyKey(*key, DEVPKEY_Device_ContainerId)) {
-                BYTE value[24] = { VT_CLSID, 0, 0, 0, 1, 0, 0, 0 };
-                memcpy(value + 8, pv->puuid, sizeof(GUID));
-
-                ret = RegSetValueExW(regkey, buffer, 0, REG_BINARY, (const BYTE*)value, 24);
-                break;
-            }
-            /* If it's not containerId, fall through the default unsupported case as we can't
-               ensure it will be decoded as CLSID. */
-        }
         default:
             ret = 0;
             FIXME("Unhandled type %u\n", pv->vt);
@@ -287,48 +238,21 @@ static HRESULT MMDevice_SetPropValue(const GUID *devguid, DWORD flow, REFPROPERT
 
 static HRESULT set_driver_prop_value(GUID *id, const EDataFlow flow, const PROPERTYKEY *prop)
 {
-    struct get_prop_value_params params;
+    HRESULT hr;
     PROPVARIANT pv;
-    char *dev_name;
-    unsigned int size = 0;
-
-    TRACE("%s, (%s,%lu)\n", wine_dbgstr_guid(id), wine_dbgstr_guid(&prop->fmtid), prop->pid);
-
-    if (!drvs.pget_device_name_from_guid(id, &dev_name, &params.flow))
-        return E_FAIL;
-
-    params.device      = dev_name;
-    params.guid        = id;
-    params.prop        = prop;
-    params.value       = &pv;
-    params.buffer      = NULL;
-    params.buffer_size = &size;
-
-    while (1) {
-        __wine_unix_call(drvs.module_unixlib, get_prop_value, &params);
-
-        if (params.result != E_NOT_SUFFICIENT_BUFFER)
-            break;
-
-        CoTaskMemFree(params.buffer);
-        params.buffer = CoTaskMemAlloc(*params.buffer_size);
-        if (!params.buffer) {
-            free(dev_name);
-            return E_OUTOFMEMORY;
-        }
-    }
 
-    if (FAILED(params.result))
-        CoTaskMemFree(params.buffer);
+    if (!drvs.pGetPropValue)
+        return E_NOTIMPL;
 
-    free(dev_name);
+    hr = drvs.pGetPropValue(id, prop, &pv);
 
-    if (SUCCEEDED(params.result)) {
+    if (SUCCEEDED(hr))
+    {
         MMDevice_SetPropValue(id, flow, prop, &pv);
         PropVariantClear(&pv);
     }
 
-    return params.result;
+    return hr;
 }
 
 struct product_name_overrides
@@ -359,7 +283,7 @@ static const WCHAR *find_product_name_override(const WCHAR *device_id)
  * If GUID is null, a random guid will be assigned
  * and the device will be created
  */
-static MMDevice *MMDevice_Create(const WCHAR *name, GUID *id, EDataFlow flow, DWORD state, BOOL setdefault)
+static MMDevice *MMDevice_Create(WCHAR *name, GUID *id, EDataFlow flow, DWORD state, BOOL setdefault)
 {
     HKEY key, root;
     MMDevice *device, *cur = NULL;
@@ -383,7 +307,7 @@ static MMDevice *MMDevice_Create(const WCHAR *name, GUID *id, EDataFlow flow, DW
 
     if(!cur){
         /* No device found, allocate new one */
-        cur = calloc(1, sizeof(*cur));
+        cur = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*cur));
         if (!cur)
             return NULL;
 
@@ -397,8 +321,8 @@ static MMDevice *MMDevice_Create(const WCHAR *name, GUID *id, EDataFlow flow, DW
     }else if(cur->ref > 0)
         WARN("Modifying an MMDevice with postitive reference count!\n");
 
-    free(cur->drv_id);
-    cur->drv_id = wcsdup(name);
+    HeapFree(GetProcessHeap(), 0, cur->drv_id);
+    cur->drv_id = name;
 
     cur->flow = flow;
     cur->state = state;
@@ -420,7 +344,7 @@ static MMDevice *MMDevice_Create(const WCHAR *name, GUID *id, EDataFlow flow, DW
             PROPVARIANT pv;
 
             pv.vt = VT_LPWSTR;
-            pv.pwszVal = cur->drv_id;
+            pv.pwszVal = name;
 
             if (SUCCEEDED(set_driver_prop_value(id, flow, &devicepath_key))) {
                 PROPVARIANT pv2;
@@ -440,15 +364,6 @@ static MMDevice *MMDevice_Create(const WCHAR *name, GUID *id, EDataFlow flow, DW
             MMDevice_SetPropValue(id, flow, (const PROPERTYKEY*)&DEVPKEY_DeviceInterface_FriendlyName, &pv);
             MMDevice_SetPropValue(id, flow, (const PROPERTYKEY*)&DEVPKEY_Device_DeviceDesc, &pv);
 
-            /* The mechanism we use to attribute Container IDs is not very robust and could end up making
-               an active device share a ContainerID with inactive devices, and some games enumerate even
-               inactive devices, stopping at the first matching one.
-               To avoid issues, invalidate the ContainerID of devices that are not present. */
-            if (state & DEVICE_STATE_ACTIVE)
-                set_driver_prop_value(id, flow, (const PROPERTYKEY*)&DEVPKEY_Device_ContainerId);
-            else if (state & DEVICE_STATE_NOTPRESENT)
-                MMDevice_DeletePropValue(id, flow, (const PROPERTYKEY*)&DEVPKEY_Device_ContainerId);
-
             pv.pwszVal = guidstr;
             MMDevice_SetPropValue(id, flow, &deviceinterface_key, &pv);
 
@@ -538,7 +453,10 @@ HRESULT load_devices_from_reg(void)
             && SUCCEEDED(MMDevice_GetPropValue(&guid, curflow, (const PROPERTYKEY*)&DEVPKEY_Device_FriendlyName, &pv))
             && pv.vt == VT_LPWSTR)
         {
-            MMDevice_Create(pv.pwszVal, &guid, curflow,
+            DWORD size_bytes = (lstrlenW(pv.pwszVal) + 1) * sizeof(WCHAR);
+            WCHAR *name = HeapAlloc(GetProcessHeap(), 0, size_bytes);
+            memcpy(name, pv.pwszVal, size_bytes);
+            MMDevice_Create(name, &guid, curflow,
                     DEVICE_STATE_NOTPRESENT, FALSE);
             CoTaskMemFree(pv.pwszVal);
         }
@@ -554,7 +472,7 @@ static HRESULT set_format(MMDevice *dev)
     WAVEFORMATEX *fmt;
     PROPVARIANT pv = { VT_EMPTY };
 
-    hr = AudioClient_Create(&dev->devguid, &dev->IMMDevice_iface, &client);
+    hr = drvs.pGetAudioEndpoint(&dev->devguid, &dev->IMMDevice_iface, &client);
     if(FAILED(hr))
         return hr;
 
@@ -580,37 +498,29 @@ static HRESULT set_format(MMDevice *dev)
 
 HRESULT load_driver_devices(EDataFlow flow)
 {
-    struct get_endpoint_ids_params params;
-    UINT i;
+    WCHAR **ids;
+    GUID *guids;
+    UINT num, def, i;
+    HRESULT hr;
 
-    params.flow = flow;
-    params.size = 1024;
-    params.endpoints = NULL;
-    do {
-        free(params.endpoints);
-        params.endpoints = malloc(params.size);
-        __wine_unix_call(drvs.module_unixlib, get_endpoint_ids, &params);
-    } while (params.result == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
+    if(!drvs.pGetEndpointIDs)
+        return S_OK;
 
-    if (FAILED(params.result))
-        goto end;
+    hr = drvs.pGetEndpointIDs(flow, &ids, &guids, &num, &def);
+    if(FAILED(hr))
+        return hr;
 
-    for (i = 0; i < params.num; i++) {
-        GUID guid;
+    for(i = 0; i < num; ++i){
         MMDevice *dev;
-        const WCHAR *name = (WCHAR *)((char *)params.endpoints + params.endpoints[i].name);
-        const char *dev_name = (char *)params.endpoints + params.endpoints[i].device;
-
-        drvs.pget_device_guid(flow, dev_name, &guid);
-
-        dev = MMDevice_Create(name, &guid, flow, DEVICE_STATE_ACTIVE, params.default_idx == i);
+        dev = MMDevice_Create(ids[i], &guids[i], flow, DEVICE_STATE_ACTIVE,
+                def == i);
         set_format(dev);
     }
 
-end:
-    free(params.endpoints);
+    HeapFree(GetProcessHeap(), 0, guids);
+    HeapFree(GetProcessHeap(), 0, ids);
 
-    return params.result;
+    return S_OK;
 }
 
 static void MMDevice_Destroy(MMDevice *This)
@@ -619,8 +529,8 @@ static void MMDevice_Destroy(MMDevice *This)
     list_remove(&This->entry);
     This->crst.DebugInfo->Spare[0] = 0;
     DeleteCriticalSection(&This->crst);
-    free(This->drv_id);
-    free(This);
+    HeapFree(GetProcessHeap(), 0, This->drv_id);
+    HeapFree(GetProcessHeap(), 0, This);
 }
 
 static inline MMDevice *impl_from_IMMDevice(IMMDevice *iface)
@@ -683,14 +593,14 @@ static HRESULT WINAPI MMDevice_Activate(IMMDevice *iface, REFIID riid, DWORD cls
     if (IsEqualIID(riid, &IID_IAudioClient) ||
             IsEqualIID(riid, &IID_IAudioClient2) ||
             IsEqualIID(riid, &IID_IAudioClient3)){
-        hr = AudioClient_Create(&This->devguid, iface, (IAudioClient**)ppv);
+        hr = drvs.pGetAudioEndpoint(&This->devguid, iface, (IAudioClient**)ppv);
     }else if (IsEqualIID(riid, &IID_IAudioEndpointVolume) ||
             IsEqualIID(riid, &IID_IAudioEndpointVolumeEx))
         hr = AudioEndpointVolume_Create(This, (IAudioEndpointVolumeEx**)ppv);
     else if (IsEqualIID(riid, &IID_IAudioSessionManager)
              || IsEqualIID(riid, &IID_IAudioSessionManager2))
     {
-        hr = AudioSessionManager_Create(iface, (IAudioSessionManager2**)ppv);
+        hr = drvs.pGetAudioSessionManager(iface, (IAudioSessionManager2**)ppv);
     }
     else if (IsEqualIID(riid, &IID_IBaseFilter))
     {
@@ -861,7 +771,7 @@ static HRESULT MMDevCol_Create(IMMDeviceCollection **ppv, EDataFlow flow, DWORD
 {
     MMDevColImpl *This;
 
-    This = malloc(sizeof(*This));
+    This = HeapAlloc(GetProcessHeap(), 0, sizeof(*This));
     *ppv = NULL;
     if (!This)
         return E_OUTOFMEMORY;
@@ -875,7 +785,7 @@ static HRESULT MMDevCol_Create(IMMDeviceCollection **ppv, EDataFlow flow, DWORD
 
 static void MMDevCol_Destroy(MMDevColImpl *This)
 {
-    free(This);
+    HeapFree(GetProcessHeap(), 0, This);
 }
 
 static HRESULT WINAPI MMDevCol_QueryInterface(IMMDeviceCollection *iface, REFIID riid, void **ppv)
@@ -1321,7 +1231,7 @@ static HRESULT WINAPI MMDevEnum_RegisterEndpointNotificationCallback(IMMDeviceEn
     if(!client)
         return E_POINTER;
 
-    wrapper = malloc(sizeof(*wrapper));
+    wrapper = HeapAlloc(GetProcessHeap(), 0, sizeof(*wrapper));
     if(!wrapper)
         return E_OUTOFMEMORY;
 
@@ -1357,7 +1267,7 @@ static HRESULT WINAPI MMDevEnum_UnregisterEndpointNotificationCallback(IMMDevice
     LIST_FOR_EACH_ENTRY(wrapper, &g_notif_clients, struct NotificationClientWrapper, entry){
         if(wrapper->client == client){
             list_remove(&wrapper->entry);
-            free(wrapper);
+            HeapFree(GetProcessHeap(), 0, wrapper);
             LeaveCriticalSection(&g_notif_lock);
             return S_OK;
         }
@@ -1396,7 +1306,7 @@ static HRESULT MMDevPropStore_Create(MMDevice *parent, DWORD access, IPropertySt
         WARN("Invalid access %08lx\n", access);
         return E_INVALIDARG;
     }
-    This = malloc(sizeof(*This));
+    This = HeapAlloc(GetProcessHeap(), 0, sizeof(*This));
     *ppv = &This->IPropertyStore_iface;
     if (!This)
         return E_OUTOFMEMORY;
@@ -1409,7 +1319,7 @@ static HRESULT MMDevPropStore_Create(MMDevice *parent, DWORD access, IPropertySt
 
 static void MMDevPropStore_Destroy(MMDevPropStore *This)
 {
-    free(This);
+    HeapFree(GetProcessHeap(), 0, This);
 }
 
 static HRESULT WINAPI MMDevPropStore_QueryInterface(IPropertyStore *iface, REFIID riid, void **ppv)
@@ -1607,13 +1517,13 @@ static ULONG WINAPI PB_Release(IPropertyBag *iface)
 static HRESULT WINAPI PB_Read(IPropertyBag *iface, LPCOLESTR name, VARIANT *var, IErrorLog *log)
 {
     IPropertyBagImpl *This = impl_from_IPropertyBag(iface);
-    TRACE("Trying to read %s, type %u\n", debugstr_w(name), var->vt);
+    TRACE("Trying to read %s, type %u\n", debugstr_w(name), var->n1.n2.vt);
     if (!lstrcmpW(name, L"DSGuid"))
     {
         WCHAR guidstr[39];
         StringFromGUID2(&This->devguid, guidstr,ARRAY_SIZE(guidstr));
-        var->vt = VT_BSTR;
-        var->bstrVal = SysAllocString(guidstr);
+        var->n1.n2.vt = VT_BSTR;
+        var->n1.n2.n3.bstrVal = SysAllocString(guidstr);
         return S_OK;
     }
     ERR("Unknown property '%s' queried\n", debugstr_w(name));
diff --git a/dlls/mmdevapi/main.c b/dlls/mmdevapi/main.c
index 11111111111..11111111111 100644
--- a/dlls/mmdevapi/main.c
+++ b/dlls/mmdevapi/main.c
@@ -18,11 +18,8 @@
  */
 
 #include <stdarg.h>
-#include <wchar.h>
 
-#include "ntstatus.h"
 #define COBJMACROS
-#define WIN32_NO_STATUS
 #include "windef.h"
 #include "winbase.h"
 #include "wingdi.h"
@@ -42,7 +39,7 @@
 #include "winreg.h"
 #include "spatialaudioclient.h"
 
-#include "mmdevapi_private.h"
+#include "mmdevapi.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(mmdevapi);
@@ -68,9 +65,7 @@ static const char *get_priority_string(int prio)
 
 static BOOL load_driver(const WCHAR *name, DriverFuncs *driver)
 {
-    NTSTATUS status;
-    WCHAR driver_module[264], path[MAX_PATH];
-    struct test_connect_params params;
+    WCHAR driver_module[264];
 
     lstrcpyW(driver_module, L"wine");
     lstrcatW(driver_module, name);
@@ -85,44 +80,24 @@ static BOOL load_driver(const WCHAR *name, DriverFuncs *driver)
         return FALSE;
     }
 
-    if ((status = NtQueryVirtualMemory(GetCurrentProcess(), driver->module, MemoryWineUnixFuncs,
-        &driver->module_unixlib, sizeof(driver->module_unixlib), NULL))) {
-        ERR("Unable to load UNIX functions: %lx\n", status);
-        goto fail;
-    }
-
-    if ((status = __wine_unix_call(driver->module_unixlib, process_attach, NULL))) {
-        ERR("Unable to initialize library: %lx\n", status);
-        goto fail;
-    }
-
 #define LDFC(n) do { driver->p##n = (void*)GetProcAddress(driver->module, #n);\
-        if(!driver->p##n) { goto fail; } } while(0)
-    LDFC(get_device_guid);
-    LDFC(get_device_name_from_guid);
+        if(!driver->p##n) { FreeLibrary(driver->module); return FALSE; } } while(0)
+    LDFC(GetPriority);
+    LDFC(GetEndpointIDs);
+    LDFC(GetAudioEndpoint);
+    LDFC(GetAudioSessionManager);
 #undef LDFC
 
-    GetModuleFileNameW(NULL, path, ARRAY_SIZE(path));
-    params.name     = wcsrchr(path, '\\');
-    params.name     = params.name ? params.name + 1 : path;
-    params.priority = Priority_Neutral;
-
-    if ((status = __wine_unix_call(driver->module_unixlib, test_connect, &params))) {
-        ERR("Unable to retrieve driver priority: %lx\n", status);
-        goto fail;
-    }
-
-    driver->priority = params.priority;
+    /* optional - do not fail if not found */
+    driver->pGetPropValue = (void*)GetProcAddress(driver->module, "GetPropValue");
 
+    driver->priority = driver->pGetPriority();
     lstrcpyW(driver->module_name, driver_module);
 
     TRACE("Successfully loaded %s with priority %s\n",
             wine_dbgstr_w(driver_module), get_priority_string(driver->priority));
 
     return TRUE;
-fail:
-    FreeLibrary(driver->module);
-    return FALSE;
 }
 
 static BOOL WINAPI init_driver(INIT_ONCE *once, void *param, void **context)
@@ -135,20 +110,19 @@ static BOOL WINAPI init_driver(INIT_ONCE *once, void *param, void **context)
     if(RegOpenKeyW(HKEY_CURRENT_USER, drv_keyW, &key) == ERROR_SUCCESS){
         DWORD size = sizeof(reg_list);
 
-        if(RegQueryValueExW(key, L"Audio", 0, NULL, (BYTE*)reg_list, &size) == ERROR_SUCCESS)
+        if(RegQueryValueExW(key, L"Audio", 0, NULL, (BYTE*)reg_list, &size) == ERROR_SUCCESS){
+            if(reg_list[0] == '\0'){
+                TRACE("User explicitly chose no driver\n");
+                RegCloseKey(key);
+                return TRUE;
+            }
+
             driver_list = reg_list;
+        }
 
         RegCloseKey(key);
     }
 
-    if ((p = _wgetenv(L"STAGING_AUDIO_DRIVER")))
-        driver_list = p;
-
-    if(driver_list[0] == '\0'){
-        TRACE("User explicitly chose no driver\n");
-        return TRUE;
-    }
-
     TRACE("Loading driver list %s\n", wine_dbgstr_w(driver_list));
     for(next = p = driver_list; next; p = next + 1){
         next = wcschr(p, ',');
@@ -193,16 +167,9 @@ BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
             DisableThreadLibraryCalls(hinstDLL);
             break;
         case DLL_PROCESS_DETACH:
-            if (drvs.module_unixlib) {
-                const NTSTATUS status = __wine_unix_call(drvs.module_unixlib, process_detach, NULL);
-                if (status)
-                    WARN("Unable to deinitialize library: %lx\n", status);
-            }
-
-            main_loop_stop();
-
-            if (!lpvReserved)
-                MMDevEnum_Free();
+            if(lpvReserved)
+                break;
+            MMDevEnum_Free();
             break;
     }
 
@@ -296,7 +263,10 @@ HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
     unsigned int i = 0;
     TRACE("(%s, %s, %p)\n", debugstr_guid(rclsid), debugstr_guid(riid), ppv);
 
-    InitOnceExecuteOnce(&init_once, init_driver, NULL, NULL);
+    if(!InitOnceExecuteOnce(&init_once, init_driver, NULL, NULL)) {
+        ERR("Driver initialization failed\n");
+        return E_FAIL;
+    }
 
     if (ppv == NULL) {
         WARN("invalid parameter\n");
@@ -378,7 +348,7 @@ static ULONG WINAPI activate_async_op_Release(IActivateAudioInterfaceAsyncOperat
         if(This->result_iface)
             IUnknown_Release(This->result_iface);
         IActivateAudioInterfaceCompletionHandler_Release(This->callback);
-        free(This);
+        HeapFree(GetProcessHeap(), 0, This);
     }
     return ref;
 }
@@ -475,7 +445,7 @@ HRESULT WINAPI ActivateAudioInterfaceAsync(const WCHAR *path, REFIID riid,
     TRACE("(%s, %s, %p, %p, %p)\n", debugstr_w(path), debugstr_guid(riid),
             params, done_handler, op_out);
 
-    op = malloc(sizeof(*op));
+    op = HeapAlloc(GetProcessHeap(), 0, sizeof(*op));
     if (!op)
         return E_OUTOFMEMORY;
 
diff --git a/dlls/mmdevapi/mmdevapi_private.h b/dlls/mmdevapi/mmdevapi.h
similarity index 11111111111..11111111111
rename from dlls/mmdevapi/mmdevapi_private.h
rename to dlls/mmdevapi/mmdevapi.h
index 11111111111..11111111111 100644
--- a/dlls/mmdevapi/mmdevapi_private.h
+++ b/dlls/mmdevapi/mmdevapi.h
@@ -16,37 +16,40 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include <assert.h>
-
-#include <endpointvolume.h>
-#include <spatialaudioclient.h>
-#include <winternl.h>
-
-#include <wine/list.h>
-#include <wine/unixlib.h>
-
 #include "unixlib.h"
-#include "mmdevdrv.h"
+#include <wine/unixlib.h>
+#include <wine/list.h>
 
-extern HRESULT MMDevEnum_Create(REFIID riid, void **ppv) DECLSPEC_HIDDEN;
-extern void MMDevEnum_Free(void) DECLSPEC_HIDDEN;
+extern HRESULT MMDevEnum_Create(REFIID riid, void **ppv);
+extern void MMDevEnum_Free(void);
 
 typedef struct _DriverFuncs {
     HMODULE module;
-    unixlib_handle_t module_unixlib;
     WCHAR module_name[64];
+    int priority;
 
-    /* Highest priority wins.
+    /* Returns a "priority" value for the driver. Highest priority wins.
      * If multiple drivers think they are valid, they will return a
      * priority value reflecting the likelihood that they are actually
      * valid. See enum _DriverPriority. */
-    int priority;
-
-    void (WINAPI *pget_device_guid)(EDataFlow flow, const char *name, GUID *guid);
-    BOOL (WINAPI *pget_device_name_from_guid)(GUID *guid, char **name, EDataFlow *flow);
+    int (WINAPI *pGetPriority)(void);
+
+    /* ids gets an array of human-friendly endpoint names
+     * keys gets an array of driver-specific stuff that is used
+     *   in GetAudioEndpoint to identify the endpoint
+     * it is the caller's responsibility to free both arrays, and
+     *   all of the elements in both arrays with HeapFree() */
+    HRESULT (WINAPI *pGetEndpointIDs)(EDataFlow flow, WCHAR ***ids,
+            GUID **guids, UINT *num, UINT *default_index);
+    HRESULT (WINAPI *pGetAudioEndpoint)(void *key, IMMDevice *dev,
+            IAudioClient **out);
+    HRESULT (WINAPI *pGetAudioSessionManager)(IMMDevice *device,
+            IAudioSessionManager2 **out);
+    HRESULT (WINAPI *pGetPropValue)(GUID *guid,
+            const PROPERTYKEY *prop, PROPVARIANT *out);
 } DriverFuncs;
 
-extern DriverFuncs drvs DECLSPEC_HIDDEN;
+extern DriverFuncs drvs;
 
 typedef struct MMDevice {
     IMMDevice IMMDevice_iface;
@@ -63,20 +66,11 @@ typedef struct MMDevice {
     struct list entry;
 } MMDevice;
 
-static inline void wine_unix_call(const unsigned int code, void *args)
-{
-    const NTSTATUS status = __wine_unix_call(drvs.module_unixlib, code, args);
-    assert(!status);
-}
-
-extern HRESULT AudioClient_Create(GUID *guid, IMMDevice *device, IAudioClient **out) DECLSPEC_HIDDEN;
-extern HRESULT AudioEndpointVolume_Create(MMDevice *parent, IAudioEndpointVolumeEx **ppv) DECLSPEC_HIDDEN;
-extern HRESULT AudioSessionManager_Create(IMMDevice *device, IAudioSessionManager2 **ppv) DECLSPEC_HIDDEN;
-extern HRESULT SpatialAudioClient_Create(IMMDevice *device, ISpatialAudioClient **out) DECLSPEC_HIDDEN;
-
-extern HRESULT load_devices_from_reg(void) DECLSPEC_HIDDEN;
-extern HRESULT load_driver_devices(EDataFlow flow) DECLSPEC_HIDDEN;
+extern HRESULT AudioClient_Create(MMDevice *parent, IAudioClient **ppv);
+extern HRESULT AudioEndpointVolume_Create(MMDevice *parent, IAudioEndpointVolumeEx **ppv);
+extern HRESULT SpatialAudioClient_Create(IMMDevice *device, ISpatialAudioClient **out);
 
-extern void main_loop_stop(void) DECLSPEC_HIDDEN;
+extern HRESULT load_devices_from_reg(void);
+extern HRESULT load_driver_devices(EDataFlow flow);
 
-extern const WCHAR drv_keyW[] DECLSPEC_HIDDEN;
+extern const WCHAR drv_keyW[];
diff --git a/dlls/mmdevapi/mmdevdrv.h b/dlls/mmdevapi/mmdevdrv.h
deleted file mode 100644
index df21859..0000000
--- a/dlls/mmdevapi/mmdevdrv.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include <audiopolicy.h>
-#include <mmdeviceapi.h>
-
-#include <wine/list.h>
-
-typedef struct audio_client ACImpl;
-
-typedef struct audio_session {
-    GUID guid;
-    struct list clients;
-
-    IMMDevice *device;
-
-    float master_vol;
-    UINT32 channel_count;
-    float *channel_vols;
-    BOOL mute;
-
-    struct list entry;
-} AudioSession;
-
-typedef struct audio_session_wrapper {
-    IAudioSessionControl2 IAudioSessionControl2_iface;
-    IChannelAudioVolume IChannelAudioVolume_iface;
-    ISimpleAudioVolume ISimpleAudioVolume_iface;
-
-    LONG ref;
-
-    struct audio_client *client;
-    struct audio_session *session;
-} AudioSessionWrapper;
-
-typedef struct session_mgr {
-    IAudioSessionManager2 IAudioSessionManager2_iface;
-
-    LONG ref;
-
-    IMMDevice *device;
-} SessionMgr;
-
-struct audio_client {
-    IAudioClient3 IAudioClient3_iface;
-    IAudioRenderClient IAudioRenderClient_iface;
-    IAudioCaptureClient IAudioCaptureClient_iface;
-    IAudioClock IAudioClock_iface;
-    IAudioClock2 IAudioClock2_iface;
-    IAudioStreamVolume IAudioStreamVolume_iface;
-
-    LONG ref;
-
-    IMMDevice *parent;
-    IUnknown *marshal;
-
-    EDataFlow dataflow;
-    float *vols;
-    UINT32 channel_count;
-    stream_handle stream;
-
-    HANDLE timer_thread;
-
-    struct audio_session *session;
-    struct audio_session_wrapper *session_wrapper;
-
-    struct list entry;
-
-    /* Keep at end */
-    char device_name[0];
-};
diff --git a/dlls/mmdevapi/session.c b/dlls/mmdevapi/session.c
deleted file mode 100644
index 112c0c5..0000000
--- a/dlls/mmdevapi/session.c
+++ /dev/null
@@ -1,666 +0,0 @@
-/*
- * Copyright 2011-2012 Maarten Lankhorst
- * Copyright 2010-2011 Maarten Lankhorst for CodeWeavers
- * Copyright 2011 Andrew Eikum for CodeWeavers
- * Copyright 2022 Huw Davies
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#define COBJMACROS
-
-#include <audiopolicy.h>
-#include <mmdeviceapi.h>
-#include <winternl.h>
-
-#include <wine/debug.h>
-#include <wine/unixlib.h>
-
-#include "mmdevapi_private.h"
-
-#define NULL_PTR_ERR MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER)
-
-WINE_DEFAULT_DEBUG_CHANNEL(mmdevapi);
-
-extern void sessions_lock(void) DECLSPEC_HIDDEN;
-extern void sessions_unlock(void) DECLSPEC_HIDDEN;
-
-extern void set_stream_volumes(struct audio_client *This) DECLSPEC_HIDDEN;
-
-static struct list sessions = LIST_INIT(sessions);
-
-static inline struct audio_session_wrapper *impl_from_IAudioSessionControl2(IAudioSessionControl2 *iface)
-{
-    return CONTAINING_RECORD(iface, struct audio_session_wrapper, IAudioSessionControl2_iface);
-}
-
-static inline struct audio_session_wrapper *impl_from_IChannelAudioVolume(IChannelAudioVolume *iface)
-{
-    return CONTAINING_RECORD(iface, struct audio_session_wrapper, IChannelAudioVolume_iface);
-}
-
-static inline struct audio_session_wrapper *impl_from_ISimpleAudioVolume(ISimpleAudioVolume *iface)
-{
-    return CONTAINING_RECORD(iface, struct audio_session_wrapper, ISimpleAudioVolume_iface);
-}
-
-static HRESULT WINAPI control_QueryInterface(IAudioSessionControl2 *iface, REFIID riid, void **ppv)
-{
-    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
-
-    if (!ppv)
-        return E_POINTER;
-
-    if (IsEqualIID(riid, &IID_IUnknown) ||
-        IsEqualIID(riid, &IID_IAudioSessionControl) ||
-        IsEqualIID(riid, &IID_IAudioSessionControl2))
-        *ppv = iface;
-    else {
-        *ppv = NULL;
-        return E_NOINTERFACE;
-    }
-
-    IUnknown_AddRef((IUnknown *)*ppv);
-
-    return S_OK;
-}
-
-static ULONG WINAPI control_AddRef(IAudioSessionControl2 *iface)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    ULONG ref = InterlockedIncrement(&This->ref);
-    TRACE("(%p) Refcount now %lu\n", This, ref);
-    return ref;
-}
-
-static ULONG WINAPI control_Release(IAudioSessionControl2 *iface)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    ULONG ref = InterlockedDecrement(&This->ref);
-    TRACE("(%p) Refcount now %lu\n", This, ref);
-
-    if (!ref) {
-        if (This->client) {
-            sessions_lock();
-            This->client->session_wrapper = NULL;
-            sessions_unlock();
-            IAudioClient3_Release(&This->client->IAudioClient3_iface);
-        }
-
-        free(This);
-    }
-
-    return ref;
-}
-
-static HRESULT WINAPI control_GetState(IAudioSessionControl2 *iface, AudioSessionState *state)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    struct is_started_params params;
-    struct audio_client *client;
-
-    TRACE("(%p)->(%p)\n", This, state);
-
-    if (!state)
-        return NULL_PTR_ERR;
-
-    sessions_lock();
-
-    if (list_empty(&This->session->clients)) {
-        *state = AudioSessionStateExpired;
-        sessions_unlock();
-        return S_OK;
-    }
-
-    LIST_FOR_EACH_ENTRY(client, &This->session->clients, struct audio_client, entry) {
-        params.stream = client->stream;
-        wine_unix_call(is_started, &params);
-        if (params.result == S_OK) {
-            *state = AudioSessionStateActive;
-            sessions_unlock();
-            return S_OK;
-        }
-    }
-
-    sessions_unlock();
-
-    *state = AudioSessionStateInactive;
-
-    return S_OK;
-}
-
-static HRESULT WINAPI control_GetDisplayName(IAudioSessionControl2 *iface, WCHAR **name)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%p) - stub\n", This, name);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI control_SetDisplayName(IAudioSessionControl2 *iface, const WCHAR *name,
-                                         const GUID *session)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%p, %s) - stub\n", This, name, debugstr_guid(session));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI control_GetIconPath(IAudioSessionControl2 *iface, WCHAR **path)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%p) - stub\n", This, path);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI control_SetIconPath(IAudioSessionControl2 *iface, const WCHAR *path,
-                                      const GUID *session)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%s, %s) - stub\n", This, debugstr_w(path), debugstr_guid(session));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI control_GetGroupingParam(IAudioSessionControl2 *iface, GUID *group)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%p) - stub\n", This, group);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI control_SetGroupingParam(IAudioSessionControl2 *iface, const GUID *group,
-                                           const GUID *session)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%s, %s) - stub\n", This, debugstr_guid(group), debugstr_guid(session));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI control_RegisterAudioSessionNotification(IAudioSessionControl2 *iface,
-                                                           IAudioSessionEvents *events)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%p) - stub\n", This, events);
-    return S_OK;
-}
-
-static HRESULT WINAPI control_UnregisterAudioSessionNotification(IAudioSessionControl2 *iface,
-                                                             IAudioSessionEvents *events)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%p) - stub\n", This, events);
-    return S_OK;
-}
-
-static HRESULT WINAPI control_GetSessionIdentifier(IAudioSessionControl2 *iface, WCHAR **id)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%p) - stub\n", This, id);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI control_GetSessionInstanceIdentifier(IAudioSessionControl2 *iface, WCHAR **id)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%p) - stub\n", This, id);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI control_GetProcessId(IAudioSessionControl2 *iface, DWORD *pid)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-
-    TRACE("(%p)->(%p)\n", This, pid);
-
-    if (!pid)
-        return E_POINTER;
-
-    *pid = GetCurrentProcessId();
-
-    return S_OK;
-}
-
-static HRESULT WINAPI control_IsSystemSoundsSession(IAudioSessionControl2 *iface)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    TRACE("(%p)\n", This);
-    return S_FALSE;
-}
-
-static HRESULT WINAPI control_SetDuckingPreference(IAudioSessionControl2 *iface, BOOL optout)
-{
-    struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    TRACE("(%p)->(%d)\n", This, optout);
-    return S_OK;
-}
-
-static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl =
-{
-    control_QueryInterface,
-    control_AddRef,
-    control_Release,
-    control_GetState,
-    control_GetDisplayName,
-    control_SetDisplayName,
-    control_GetIconPath,
-    control_SetIconPath,
-    control_GetGroupingParam,
-    control_SetGroupingParam,
-    control_RegisterAudioSessionNotification,
-    control_UnregisterAudioSessionNotification,
-    control_GetSessionIdentifier,
-    control_GetSessionInstanceIdentifier,
-    control_GetProcessId,
-    control_IsSystemSoundsSession,
-    control_SetDuckingPreference
-};
-
-static HRESULT WINAPI channelvolume_QueryInterface(IChannelAudioVolume *iface, REFIID riid,
-                                                   void **ppv)
-{
-    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
-
-    if (!ppv)
-        return E_POINTER;
-
-    if (IsEqualIID(riid, &IID_IUnknown) ||
-        IsEqualIID(riid, &IID_IChannelAudioVolume))
-        *ppv = iface;
-    else {
-        *ppv = NULL;
-        return E_NOINTERFACE;
-    }
-
-    IUnknown_AddRef((IUnknown *)*ppv);
-
-    return S_OK;
-}
-
-static ULONG WINAPI channelvolume_AddRef(IChannelAudioVolume *iface)
-{
-    struct audio_session_wrapper *This = impl_from_IChannelAudioVolume(iface);
-    return IAudioSessionControl2_AddRef(&This->IAudioSessionControl2_iface);
-}
-
-static ULONG WINAPI channelvolume_Release(IChannelAudioVolume *iface)
-{
-    struct audio_session_wrapper *This = impl_from_IChannelAudioVolume(iface);
-    return IAudioSessionControl2_Release(&This->IAudioSessionControl2_iface);
-}
-
-static HRESULT WINAPI channelvolume_GetChannelCount(IChannelAudioVolume *iface, UINT32 *out)
-{
-    struct audio_session_wrapper *This = impl_from_IChannelAudioVolume(iface);
-    struct audio_session *session = This->session;
-
-    TRACE("(%p)->(%p)\n", session, out);
-
-    if (!out)
-        return NULL_PTR_ERR;
-
-    *out = session->channel_count;
-
-    return S_OK;
-}
-
-static HRESULT WINAPI channelvolume_SetChannelVolume(IChannelAudioVolume *iface, UINT32 index,
-                                                     float level, const GUID *context)
-{
-    struct audio_session_wrapper *This = impl_from_IChannelAudioVolume(iface);
-    struct audio_session *session = This->session;
-    struct audio_client *client;
-
-    TRACE("(%p)->(%d, %f, %s)\n", session, index, level, wine_dbgstr_guid(context));
-
-    if (level < 0.f || level > 1.f)
-        return E_INVALIDARG;
-
-    if (index >= session->channel_count)
-        return E_INVALIDARG;
-
-    if (context)
-        FIXME("Notifications not supported yet\n");
-
-    sessions_lock();
-
-    session->channel_vols[index] = level;
-
-    LIST_FOR_EACH_ENTRY(client, &session->clients, struct audio_client, entry)
-        set_stream_volumes(client);
-
-    sessions_unlock();
-
-    return S_OK;
-}
-
-static HRESULT WINAPI channelvolume_GetChannelVolume(IChannelAudioVolume *iface, UINT32 index,
-                                                     float *level)
-{
-    struct audio_session_wrapper *This = impl_from_IChannelAudioVolume(iface);
-    struct audio_session *session = This->session;
-
-    TRACE("(%p)->(%d, %p)\n", session, index, level);
-
-    if (!level)
-        return NULL_PTR_ERR;
-
-    if (index >= session->channel_count)
-        return E_INVALIDARG;
-
-    *level = session->channel_vols[index];
-
-    return S_OK;
-}
-
-static HRESULT WINAPI channelvolume_SetAllVolumes(IChannelAudioVolume *iface, UINT32 count,
-                                                  const float *levels, const GUID *context)
-{
-    struct audio_session_wrapper *This = impl_from_IChannelAudioVolume(iface);
-    struct audio_session *session = This->session;
-    struct audio_client *client;
-    unsigned int i;
-
-    TRACE("(%p)->(%d, %p, %s)\n", session, count, levels, wine_dbgstr_guid(context));
-
-    if (!levels)
-        return NULL_PTR_ERR;
-
-    if (count != session->channel_count)
-        return E_INVALIDARG;
-
-    if (context)
-        FIXME("Notifications not supported yet\n");
-
-    sessions_lock();
-
-    for (i = 0; i < count; ++i)
-        session->channel_vols[i] = levels[i];
-
-    LIST_FOR_EACH_ENTRY(client, &session->clients, struct audio_client, entry)
-        set_stream_volumes(client);
-
-    sessions_unlock();
-
-    return S_OK;
-}
-
-static HRESULT WINAPI channelvolume_GetAllVolumes(IChannelAudioVolume *iface, UINT32 count,
-                                                  float *levels)
-{
-    struct audio_session_wrapper *This = impl_from_IChannelAudioVolume(iface);
-    struct audio_session *session = This->session;
-    unsigned int i;
-
-    TRACE("(%p)->(%d, %p)\n", session, count, levels);
-
-    if (!levels)
-        return NULL_PTR_ERR;
-
-    if (count != session->channel_count)
-        return E_INVALIDARG;
-
-    for (i = 0; i < count; ++i)
-        levels[i] = session->channel_vols[i];
-
-    return S_OK;
-}
-
-static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl =
-{
-    channelvolume_QueryInterface,
-    channelvolume_AddRef,
-    channelvolume_Release,
-    channelvolume_GetChannelCount,
-    channelvolume_SetChannelVolume,
-    channelvolume_GetChannelVolume,
-    channelvolume_SetAllVolumes,
-    channelvolume_GetAllVolumes
-};
-
-static HRESULT WINAPI simplevolume_QueryInterface(ISimpleAudioVolume *iface, REFIID riid,
-                                                  void **ppv)
-{
-    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
-
-    if (!ppv)
-        return E_POINTER;
-
-    if (IsEqualIID(riid, &IID_IUnknown) ||
-        IsEqualIID(riid, &IID_ISimpleAudioVolume))
-        *ppv = iface;
-    else {
-        *ppv = NULL;
-        return E_NOINTERFACE;
-    }
-
-    IUnknown_AddRef((IUnknown *)*ppv);
-
-    return S_OK;
-}
-
-static ULONG WINAPI simplevolume_AddRef(ISimpleAudioVolume *iface)
-{
-    struct audio_session_wrapper *This = impl_from_ISimpleAudioVolume(iface);
-    return IAudioSessionControl2_AddRef(&This->IAudioSessionControl2_iface);
-}
-
-static ULONG WINAPI simplevolume_Release(ISimpleAudioVolume *iface)
-{
-    struct audio_session_wrapper *This = impl_from_ISimpleAudioVolume(iface);
-    return IAudioSessionControl2_Release(&This->IAudioSessionControl2_iface);
-}
-
-static HRESULT WINAPI simplevolume_SetMasterVolume(ISimpleAudioVolume *iface, float level,
-                                                  const GUID *context)
-{
-    struct audio_session_wrapper *This = impl_from_ISimpleAudioVolume(iface);
-    struct audio_session *session = This->session;
-    struct audio_client *client;
-
-    TRACE("(%p)->(%f, %s)\n", session, level, wine_dbgstr_guid(context));
-
-    if (level < 0.f || level > 1.f)
-        return E_INVALIDARG;
-
-    if (context)
-        FIXME("Notifications not supported yet\n");
-
-    sessions_lock();
-
-    session->master_vol = level;
-
-    LIST_FOR_EACH_ENTRY(client, &session->clients, struct audio_client, entry)
-        set_stream_volumes(client);
-
-    sessions_unlock();
-
-    return S_OK;
-}
-
-static HRESULT WINAPI simplevolume_GetMasterVolume(ISimpleAudioVolume *iface, float *level)
-{
-    struct audio_session_wrapper *This = impl_from_ISimpleAudioVolume(iface);
-    struct audio_session *session = This->session;
-
-    TRACE("(%p)->(%p)\n", session, level);
-
-    if (!level)
-        return NULL_PTR_ERR;
-
-    *level = session->master_vol;
-
-    return S_OK;
-}
-
-static HRESULT WINAPI simplevolume_SetMute(ISimpleAudioVolume *iface, BOOL mute,
-                                           const GUID *context)
-{
-    struct audio_session_wrapper *This = impl_from_ISimpleAudioVolume(iface);
-    struct audio_session *session = This->session;
-    struct audio_client *client;
-
-    TRACE("(%p)->(%u, %s)\n", session, mute, debugstr_guid(context));
-
-    if (context)
-        FIXME("Notifications not supported yet\n");
-
-    sessions_lock();
-
-    session->mute = mute;
-
-    LIST_FOR_EACH_ENTRY(client, &session->clients, struct audio_client, entry)
-        set_stream_volumes(client);
-
-    sessions_unlock();
-
-    return S_OK;
-}
-
-static HRESULT WINAPI simplevolume_GetMute(ISimpleAudioVolume *iface, BOOL *mute)
-{
-    struct audio_session_wrapper *This = impl_from_ISimpleAudioVolume(iface);
-    struct audio_session *session = This->session;
-
-    TRACE("(%p)->(%p)\n", session, mute);
-
-    if (!mute)
-        return NULL_PTR_ERR;
-
-    *mute = session->mute;
-
-    return S_OK;
-}
-
-static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl =
-{
-    simplevolume_QueryInterface,
-    simplevolume_AddRef,
-    simplevolume_Release,
-    simplevolume_SetMasterVolume,
-    simplevolume_GetMasterVolume,
-    simplevolume_SetMute,
-    simplevolume_GetMute
-};
-
-static void session_init_vols(struct audio_session *session, UINT channels)
-{
-    if (session->channel_count < channels) {
-        UINT i;
-
-        session->channel_vols = realloc(session->channel_vols, sizeof(float) * channels);
-        if (!session->channel_vols)
-            return;
-
-        for (i = session->channel_count; i < channels; i++)
-            session->channel_vols[i] = 1.f;
-
-        session->channel_count = channels;
-    }
-}
-
-static struct audio_session *session_create(const GUID *guid, IMMDevice *device, UINT channels)
-{
-    struct audio_session *ret = calloc(1, sizeof(struct audio_session));
-    if (!ret)
-        return NULL;
-
-    memcpy(&ret->guid, guid, sizeof(GUID));
-
-    ret->device = device;
-
-    list_init(&ret->clients);
-
-    list_add_head(&sessions, &ret->entry);
-
-    session_init_vols(ret, channels);
-
-    ret->master_vol = 1.f;
-
-    return ret;
-}
-
-struct audio_session_wrapper *session_wrapper_create(struct audio_client *client)
-{
-    struct audio_session_wrapper *ret;
-
-    ret = calloc(1, sizeof(struct audio_session_wrapper));
-    if (!ret)
-        return NULL;
-
-    ret->IAudioSessionControl2_iface.lpVtbl = &AudioSessionControl2_Vtbl;
-    ret->IChannelAudioVolume_iface.lpVtbl   = &ChannelAudioVolume_Vtbl;
-    ret->ISimpleAudioVolume_iface.lpVtbl    = &SimpleAudioVolume_Vtbl;
-
-    ret->ref    = 1;
-    ret->client = client;
-
-    if (client) {
-        ret->session = client->session;
-        IAudioClient3_AddRef(&client->IAudioClient3_iface);
-    }
-
-    return ret;
-}
-
-/* If channels == 0, then this will return or create a session with
- * matching dataflow and GUID. Otherwise, channels must also match. */
-HRESULT get_audio_session(const GUID *guid, IMMDevice *device, UINT channels,
-                          struct audio_session **out)
-{
-    struct audio_session *session;
-
-    TRACE("(%s, %p, %u, %p)\n", debugstr_guid(guid), device, channels, out);
-
-    if (!guid || IsEqualGUID(guid, &GUID_NULL)) {
-        *out = session_create(&GUID_NULL, device, channels);
-        if (!*out)
-            return E_OUTOFMEMORY;
-
-        return S_OK;
-    }
-
-    *out = NULL;
-    LIST_FOR_EACH_ENTRY(session, &sessions, struct audio_session, entry) {
-        if (session->device == device && IsEqualGUID(guid, &session->guid)) {
-            session_init_vols(session, channels);
-            *out = session;
-            break;
-        }
-    }
-
-    if (!*out) {
-        *out = session_create(guid, device, channels);
-        if (!*out)
-            return E_OUTOFMEMORY;
-    }
-
-    return S_OK;
-}
-
-HRESULT get_audio_session_wrapper(const GUID *guid, IMMDevice *device,
-                                  struct audio_session_wrapper **out)
-{
-    struct audio_session *session;
-
-    const HRESULT hr = get_audio_session(guid, device, 0, &session);
-    if (FAILED(hr))
-        return hr;
-
-    *out = session_wrapper_create(NULL);
-    if (!*out)
-        return E_OUTOFMEMORY;
-
-    (*out)->session = session;
-
-    return S_OK;
-}
diff --git a/dlls/mmdevapi/spatialaudio.c b/dlls/mmdevapi/spatialaudio.c
index 11111111111..11111111111 100644
--- a/dlls/mmdevapi/spatialaudio.c
+++ b/dlls/mmdevapi/spatialaudio.c
@@ -17,6 +17,7 @@
  */
 
 #define COBJMACROS
+#define NONAMELESSUNION
 
 #include <stdarg.h>
 
@@ -24,6 +25,7 @@
 #include "winbase.h"
 #include "winnls.h"
 #include "winreg.h"
+#include "wine/heap.h"
 #include "wine/debug.h"
 #include "wine/list.h"
 
@@ -35,7 +37,7 @@
 #include "audiopolicy.h"
 #include "spatialaudioclient.h"
 
-#include "mmdevapi_private.h"
+#include "mmdevapi.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(mmdevapi);
 
@@ -159,8 +161,8 @@ static ULONG WINAPI SAO_Release(ISpatialAudioObject *iface)
         LeaveCriticalSection(&This->sa_stream->lock);
 
         ISpatialAudioObjectRenderStream_Release(&This->sa_stream->ISpatialAudioObjectRenderStream_iface);
-        free(This->buf);
-        free(This);
+        heap_free(This->buf);
+        heap_free(This);
     }
     return ref;
 }
@@ -287,11 +289,11 @@ static ULONG WINAPI SAORS_Release(ISpatialAudioObjectRenderStream *iface)
         IAudioClient_Release(This->client);
         if(This->params.NotifyObject)
             ISpatialAudioObjectRenderStreamNotify_Release(This->params.NotifyObject);
-        free((void*)This->params.ObjectFormat);
+        heap_free((void*)This->params.ObjectFormat);
         CloseHandle(This->params.EventHandle);
         DeleteCriticalSection(&This->lock);
         ISpatialAudioClient_Release(&This->sa_client->ISpatialAudioClient_iface);
-        free(This);
+        heap_free(This);
     }
     return ref;
 }
@@ -468,7 +470,7 @@ static HRESULT WINAPI SAORS_ActivateSpatialAudioObject(ISpatialAudioObjectRender
             return SPTLAUDCLNT_E_OBJECT_ALREADY_ACTIVE;
     }
 
-    obj = calloc(1, sizeof(*obj));
+    obj = heap_alloc_zero(sizeof(*obj));
     obj->ISpatialAudioObject_iface.lpVtbl = &ISpatialAudioObject_vtbl;
     obj->ref = 1;
     obj->type = type;
@@ -482,7 +484,7 @@ static HRESULT WINAPI SAORS_ActivateSpatialAudioObject(ISpatialAudioObjectRender
     obj->sa_stream = This;
     SAORS_AddRef(&This->ISpatialAudioObjectRenderStream_iface);
 
-    obj->buf = calloc(This->period_frames, This->sa_client->object_fmtex.Format.nBlockAlign);
+    obj->buf = heap_alloc_zero(This->period_frames * This->sa_client->object_fmtex.Format.nBlockAlign);
 
     EnterCriticalSection(&This->lock);
 
@@ -547,7 +549,7 @@ static ULONG WINAPI SAC_Release(ISpatialAudioClient *iface)
     TRACE("(%p) new ref %lu\n", This, ref);
     if (!ref) {
         IMMDevice_Release(This->mmdev);
-        free(This);
+        heap_free(This);
     }
     return ref;
 }
@@ -625,7 +627,7 @@ static HRESULT WINAPI SAC_IsSpatialAudioStreamAvailable(ISpatialAudioClient *ifa
 
 static WAVEFORMATEX *clone_fmtex(const WAVEFORMATEX *src)
 {
-    WAVEFORMATEX *r = malloc(sizeof(WAVEFORMATEX) + src->cbSize);
+    WAVEFORMATEX *r = heap_alloc(sizeof(WAVEFORMATEX) + src->cbSize);
     memcpy(r, src, sizeof(WAVEFORMATEX) + src->cbSize);
     return r;
 }
@@ -782,7 +784,7 @@ static HRESULT WINAPI SAC_ActivateSpatialAudioStream(ISpatialAudioClient *iface,
             return AUDCLNT_E_UNSUPPORTED_FORMAT;
         }
 
-        obj = calloc(1, sizeof(SpatialAudioStreamImpl));
+        obj = heap_alloc_zero(sizeof(SpatialAudioStreamImpl));
 
         obj->ISpatialAudioObjectRenderStream_iface.lpVtbl = &ISpatialAudioObjectRenderStream_vtbl;
         obj->ref = 1;
@@ -820,10 +822,10 @@ static HRESULT WINAPI SAC_ActivateSpatialAudioStream(ISpatialAudioClient *iface,
             if(obj->params.NotifyObject)
                 ISpatialAudioObjectRenderStreamNotify_Release(obj->params.NotifyObject);
             DeleteCriticalSection(&obj->lock);
-            free((void*)obj->params.ObjectFormat);
+            heap_free((void*)obj->params.ObjectFormat);
             CloseHandle(obj->params.EventHandle);
             ISpatialAudioClient_Release(&obj->sa_client->ISpatialAudioClient_iface);
-            free(obj);
+            heap_free(obj);
             *stream = NULL;
             return hr;
         }
@@ -912,7 +914,7 @@ HRESULT SpatialAudioClient_Create(IMMDevice *mmdev, ISpatialAudioClient **out)
     WAVEFORMATEX *closest;
     HRESULT hr;
 
-    obj = calloc(1, sizeof(*obj));
+    obj = heap_alloc_zero(sizeof(*obj));
 
     obj->ref = 1;
     obj->ISpatialAudioClient_iface.lpVtbl = &ISpatialAudioClient_vtbl;
@@ -930,7 +932,7 @@ HRESULT SpatialAudioClient_Create(IMMDevice *mmdev, ISpatialAudioClient **out)
             CLSCTX_INPROC_SERVER, NULL, (void**)&aclient);
     if(FAILED(hr)){
         WARN("Activate failed: %08lx\n", hr);
-        free(obj);
+        heap_free(obj);
         return hr;
     }
 
@@ -942,7 +944,7 @@ HRESULT SpatialAudioClient_Create(IMMDevice *mmdev, ISpatialAudioClient **out)
         if(sizeof(WAVEFORMATEX) + closest->cbSize > sizeof(obj->object_fmtex)){
             ERR("Returned format too large: %s\n", debugstr_fmtex(closest));
             CoTaskMemFree(closest);
-            free(obj);
+            heap_free(obj);
             return AUDCLNT_E_UNSUPPORTED_FORMAT;
         }else if(!((closest->wFormatTag == WAVE_FORMAT_IEEE_FLOAT ||
                     (closest->wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
@@ -951,7 +953,7 @@ HRESULT SpatialAudioClient_Create(IMMDevice *mmdev, ISpatialAudioClient **out)
                     closest->wBitsPerSample == 32)){
             ERR("Returned format not 32-bit float: %s\n", debugstr_fmtex(closest));
             CoTaskMemFree(closest);
-            free(obj);
+            heap_free(obj);
             return AUDCLNT_E_UNSUPPORTED_FORMAT;
         }
         WARN("The audio stack doesn't support 48kHz 32bit float. Using the closest match. Audio may be glitchy. %s\n", debugstr_fmtex(closest));
@@ -961,7 +963,7 @@ HRESULT SpatialAudioClient_Create(IMMDevice *mmdev, ISpatialAudioClient **out)
         CoTaskMemFree(closest);
     } else if(hr != S_OK){
         WARN("Checking supported formats failed: %08lx\n", hr);
-        free(obj);
+        heap_free(obj);
         return hr;
     }
 
diff --git a/dlls/mmdevapi/tests/capture.c b/dlls/mmdevapi/tests/capture.c
index 11111111111..11111111111 100644
--- a/dlls/mmdevapi/tests/capture.c
+++ b/dlls/mmdevapi/tests/capture.c
@@ -283,7 +283,7 @@ static void test_capture(IAudioClient *ac, HANDLE handle, WAVEFORMATEX *wfx)
             /* Native's position is one period further than what we read.
              * Perhaps that's precisely the meaning of DATA_DISCONTINUITY:
              * signal when the position jump left a gap. */
-            ok(pos >= sum + frames, "Position %u last %u frames %u\n", (UINT)pos, sum, frames);
+            ok(pos == sum + frames, "Position %u last %u frames %u\n", (UINT)pos, sum, frames);
             sum = pos;
         }else{ /* win10 */
             ok(pos == sum, "Position %u last %u frames %u\n", (UINT)pos, sum, frames);
@@ -531,6 +531,9 @@ static void test_audioclient(void)
     trace("Returned latency: %u.%04u ms\n",
           (UINT)(t1/10000), (UINT)(t1 % 10000));
 
+    hr = IAudioClient_Initialize(ac, AUDCLNT_SHAREMODE_SHARED, 0, 5000000, 0, pwfx, NULL);
+    ok(hr == AUDCLNT_E_ALREADY_INITIALIZED, "Calling Initialize twice returns %08lx\n", hr);
+
     hr = IAudioClient_SetEventHandle(ac, NULL);
     ok(hr == E_INVALIDARG, "SetEventHandle(NULL) returns %08lx\n", hr);
 
diff --git a/dlls/mmdevapi/tests/propstore.c b/dlls/mmdevapi/tests/propstore.c
index 11111111111..11111111111 100644
--- a/dlls/mmdevapi/tests/propstore.c
+++ b/dlls/mmdevapi/tests/propstore.c
@@ -16,6 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#define NONAMELESSUNION
 #include "wine/test.h"
 
 #define COBJMACROS
@@ -28,9 +29,6 @@
 #include "uuids.h"
 #include "mmdeviceapi.h"
 #include "devpkey.h"
-#include "ks.h"
-#include "ksmedia.h"
-#include "mmreg.h"
 
 static BOOL (WINAPI *pIsWow64Process)(HANDLE, BOOL *);
 
@@ -40,7 +38,6 @@ static const WCHAR software_renderW[] =
 
 static void test_propertystore(IPropertyStore *store)
 {
-    const WAVEFORMATEXTENSIBLE *format;
     HRESULT hr;
     PROPVARIANT pv;
     char temp[128];
@@ -50,9 +47,12 @@ static void test_propertystore(IPropertyStore *store)
     hr = IPropertyStore_GetValue(store, &PKEY_AudioEndpoint_GUID, &pv);
     ok(hr == S_OK, "Failed with %08lx\n", hr);
     ok(pv.vt == VT_LPWSTR, "Value should be %i, is %i\n", VT_LPWSTR, pv.vt);
-    WideCharToMultiByte(CP_ACP, 0, pv.pwszVal, -1, temp, sizeof(temp)-1, NULL, NULL);
-    trace("guid: %s\n", temp);
-    PropVariantClear(&pv);
+    if (hr == S_OK && pv.vt == VT_LPWSTR)
+    {
+        WideCharToMultiByte(CP_ACP, 0, pv.pwszVal, -1, temp, sizeof(temp)-1, NULL, NULL);
+        trace("guid: %s\n", temp);
+        PropVariantClear(&pv);
+    }
 
     pv.vt = VT_EMPTY;
     hr = IPropertyStore_GetValue(store, (const PROPERTYKEY*)&DEVPKEY_DeviceInterface_FriendlyName, &pv);
@@ -71,20 +71,6 @@ static void test_propertystore(IPropertyStore *store)
     ok(hr == S_OK, "Failed with %08lx\n", hr);
     ok(pv.vt == VT_EMPTY, "Key should not be found\n");
     PropVariantClear(&pv);
-
-    pv.vt = VT_EMPTY;
-    hr = IPropertyStore_GetValue(store, (const PROPERTYKEY *)&PKEY_AudioEngine_DeviceFormat, &pv);
-    ok(hr == S_OK, "Failed with %08lx\n", hr);
-    ok(pv.vt == VT_BLOB, "Got type %u\n", pv.vt);
-    ok(pv.blob.cbSize == sizeof(WAVEFORMATEXTENSIBLE), "Got size %lu\n", pv.blob.cbSize);
-    format = (const void *)pv.blob.pBlobData;
-    ok(format->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE, "Got format tag %#x\n", format->Format.wFormatTag);
-    ok(format->Format.cbSize == sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX),
-            "Got extra size %u\n", format->Format.cbSize);
-    todo_wine ok(format->Format.wBitsPerSample == 16, "Got bit depth %u\n", format->Format.wBitsPerSample);
-    todo_wine ok(IsEqualGUID(&format->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM),
-            "Got subformat %s\n", debugstr_guid(&format->SubFormat));
-    PropVariantClear(&pv);
 }
 
 static void test_deviceinterface(IPropertyStore *store)
@@ -197,20 +183,17 @@ static void test_setvalue_on_wow64(IPropertyStore *store)
 
     /* should NOT find the key in 32-bit view */
     ret = RegOpenKeyExW(HKEY_LOCAL_MACHINE, software_renderW, 0, KEY_READ, &root);
-    todo_wine
-    ok(ret == 0 || broken(ret == ERROR_FILE_NOT_FOUND /* win10 < 2004 */),
-       "Wrong error when opening mmdevices Render key: %lu\n", ret);
+    ok(ret == ERROR_FILE_NOT_FOUND, "Wrong error when opening mmdevices Render key: %lu\n", ret);
 }
 
 START_TEST(propstore)
 {
     HRESULT hr;
-    IMMDeviceCollection *collection;
     IMMDeviceEnumerator *mme = NULL;
+    IMMDevice *dev = NULL;
     IPropertyStore *store;
     BOOL is_wow64 = FALSE;
     HMODULE hk32 = GetModuleHandleA("kernel32.dll");
-    unsigned int i, count;
 
     pIsWow64Process = (void *)GetProcAddress(hk32, "IsWow64Process");
 
@@ -219,49 +202,53 @@ START_TEST(propstore)
 
     CoInitializeEx(NULL, COINIT_MULTITHREADED);
     hr = CoCreateInstance(&CLSID_MMDeviceEnumerator, NULL, CLSCTX_INPROC_SERVER, &IID_IMMDeviceEnumerator, (void**)&mme);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-
-    hr = IMMDeviceEnumerator_EnumAudioEndpoints(mme, eRender, DEVICE_STATE_ACTIVE, &collection);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    hr = IMMDeviceCollection_GetCount(collection, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-
-    for (i = 0; i < count; ++i)
+    if (FAILED(hr))
     {
-        IMMDevice *dev;
-
-        hr = IMMDeviceCollection_Item(collection, i, &dev);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        skip("mmdevapi not available: 0x%08lx\n", hr);
+        goto cleanup;
+    }
 
-        store = NULL;
-        hr = IMMDevice_OpenPropertyStore(dev, 3, &store);
-        ok(hr == E_INVALIDARG, "Wrong hr returned: %08lx\n", hr);
+    hr = IMMDeviceEnumerator_GetDefaultAudioEndpoint(mme, eRender, eMultimedia, &dev);
+    ok(hr == S_OK || hr == E_NOTFOUND, "GetDefaultAudioEndpoint failed: 0x%08lx\n", hr);
+    if (hr != S_OK)
+    {
+        if (hr == E_NOTFOUND)
+            skip("No sound card available\n");
+        else
+            skip("GetDefaultAudioEndpoint returns 0x%08lx\n", hr);
+        goto cleanup;
+    }
+    store = NULL;
+    hr = IMMDevice_OpenPropertyStore(dev, 3, &store);
+    ok(hr == E_INVALIDARG, "Wrong hr returned: %08lx\n", hr);
+    if (hr != S_OK)
         /* It seems on windows returning with E_INVALIDARG doesn't
          * set store to NULL, so just don't set store to non-null
          * before calling this function
          */
-        ok(!store, "Got unexpected store %p\n", store);
-
-        hr = IMMDevice_OpenPropertyStore(dev, STGM_READ, NULL);
-        ok(hr == E_POINTER, "Wrong hr returned: %08lx\n", hr);
-
-        store = NULL;
-        hr = IMMDevice_OpenPropertyStore(dev, STGM_READWRITE, &store);
-        if (hr == E_ACCESSDENIED)
-            hr = IMMDevice_OpenPropertyStore(dev, STGM_READ, &store);
-        ok(hr == S_OK, "Opening valid store returned %08lx\n", hr);
-
+        ok(!store, "Store set to non-NULL on failure: %p/%08lx\n", store, hr);
+    else if (store)
+        IPropertyStore_Release(store);
+    hr = IMMDevice_OpenPropertyStore(dev, STGM_READ, NULL);
+    ok(hr == E_POINTER, "Wrong hr returned: %08lx\n", hr);
+
+    store = NULL;
+    hr = IMMDevice_OpenPropertyStore(dev, STGM_READWRITE, &store);
+    if(hr == E_ACCESSDENIED)
+        hr = IMMDevice_OpenPropertyStore(dev, STGM_READ, &store);
+    ok(hr == S_OK, "Opening valid store returned %08lx\n", hr);
+    if (store)
+    {
         test_propertystore(store);
         test_deviceinterface(store);
         test_getat(store);
         if (is_wow64)
             test_setvalue_on_wow64(store);
-
         IPropertyStore_Release(store);
-        IMMDevice_Release(dev);
     }
-
-    IMMDeviceCollection_Release(collection);
-    IMMDeviceEnumerator_Release(mme);
+    IMMDevice_Release(dev);
+cleanup:
+    if (mme)
+        IMMDeviceEnumerator_Release(mme);
     CoUninitialize();
 }
diff --git a/dlls/mmdevapi/unixlib.h b/dlls/mmdevapi/unixlib.h
index 11111111111..11111111111 100644
--- a/dlls/mmdevapi/unixlib.h
+++ b/dlls/mmdevapi/unixlib.h
@@ -53,7 +53,7 @@ struct get_endpoint_ids_params
 
 struct create_stream_params
 {
-    const WCHAR *name;
+    const char *name;
     const char *device;
     EDataFlow flow;
     AUDCLNT_SHAREMODE share;
@@ -207,6 +207,7 @@ struct set_volumes_params
     float master_volume;
     const float *volumes;
     const float *session_volumes;
+    int channel;
 };
 
 struct set_event_handle_params
@@ -218,7 +219,7 @@ struct set_event_handle_params
 
 struct test_connect_params
 {
-    const WCHAR *name;
+    const char *name;
     enum driver_priority priority;
 };
 
@@ -332,5 +333,4 @@ enum unix_funcs
     midi_in_message,
     midi_notify_wait,
     aux_message,
-    funcs_count
 };
diff --git a/dlls/winealsa.drv/Makefile.in b/dlls/winealsa.drv/Makefile.in
index 11111111111..11111111111 100644
--- a/dlls/winealsa.drv/Makefile.in
+++ b/dlls/winealsa.drv/Makefile.in
@@ -4,7 +4,7 @@ IMPORTS   = uuid ole32 advapi32
 DELAYIMPORTS = winmm
 UNIX_LIBS    = $(ALSA_LIBS) $(PTHREAD_LIBS)
 
-C_SRCS = \
+SOURCES = \
 	alsa.c \
 	alsamidi.c \
 	midi.c \
diff --git a/dlls/winealsa.drv/alsa.c b/dlls/winealsa.drv/alsa.c
index 11111111111..11111111111 100644
--- a/dlls/winealsa.drv/alsa.c
+++ b/dlls/winealsa.drv/alsa.c
@@ -82,22 +82,20 @@ struct alsa_stream
     pthread_mutex_t lock;
 };
 
-#define EXTRA_SAFE_RT 40000
+#define                     EXTRA_SAFE_RT   40000
 
-static const REFERENCE_TIME def_period = 100000;
-static const REFERENCE_TIME min_period = 50000;
+int GetAudioEnv(char const* env, int def) {
+  char* val = getenv(env);
+  if (val) {
+    return atoi(val);
+  }
+  return def;
+}
 
 static const WCHAR drv_keyW[] = {'S','o','f','t','w','a','r','e','\\',
     'W','i','n','e','\\','D','r','i','v','e','r','s','\\',
     'w','i','n','e','a','l','s','a','.','d','r','v'};
 
-static ULONG_PTR zero_bits = 0;
-
-static NTSTATUS alsa_not_implemented(void *args)
-{
-    return STATUS_SUCCESS;
-}
-
 static inline void ascii_to_unicode( WCHAR *dst, const char *src, size_t len )
 {
     while (len--) *dst++ = (unsigned char)*src++;
@@ -478,27 +476,6 @@ static WCHAR *alsa_get_card_name(int card)
     return ret;
 }
 
-static NTSTATUS alsa_process_attach(void *args)
-{
-#ifdef _WIN64
-    if (NtCurrentTeb()->WowTebOffset)
-    {
-        SYSTEM_BASIC_INFORMATION info;
-
-        NtQuerySystemInformation(SystemEmulationBasicInformation, &info, sizeof(info), NULL);
-        zero_bits = (ULONG_PTR)info.HighestUserAddress | 0x7fffffff;
-    }
-#endif
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS alsa_main_loop(void *args)
-{
-    struct main_loop_params *params = args;
-    NtSetEvent(params->event, NULL);
-    return STATUS_SUCCESS;
-}
-
 static NTSTATUS alsa_get_endpoint_ids(void *args)
 {
     static const WCHAR defaultW[] = {'d','e','f','a','u','l','t',0};
@@ -797,6 +774,15 @@ static void silence_buffer(struct alsa_stream *stream, BYTE *buffer, UINT32 fram
         memset(buffer, 0, frames * stream->fmt->nBlockAlign);
 }
 
+static ULONG_PTR zero_bits(void)
+{
+#ifdef _WIN64
+    return !NtCurrentTeb()->WowTebOffset ? 0 : 0x7fffffff;
+#else
+    return 0;
+#endif
+}
+
 static NTSTATUS alsa_create_stream(void *args)
 {
     struct create_stream_params *params = args;
@@ -804,42 +790,10 @@ static NTSTATUS alsa_create_stream(void *args)
     snd_pcm_sw_params_t *sw_params = NULL;
     snd_pcm_format_t format;
     unsigned int rate, alsa_period_us, i;
-    WAVEFORMATEXTENSIBLE *fmtex = (WAVEFORMATEXTENSIBLE *)params->fmt;
+    WAVEFORMATEXTENSIBLE *fmtex;
     int err;
     SIZE_T size;
 
-    params->result = S_OK;
-
-    if (params->share == AUDCLNT_SHAREMODE_SHARED) {
-        params->period = def_period;
-        if (params->duration < 3 * params->period)
-            params->duration = 3 * params->period;
-    } else {
-        if (fmtex->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
-           (fmtex->dwChannelMask == 0 || fmtex->dwChannelMask & SPEAKER_RESERVED))
-            params->result = AUDCLNT_E_UNSUPPORTED_FORMAT;
-        else {
-            if (!params->period)
-                params->period = def_period;
-            if (params->period < min_period || params->period > 5000000)
-                params->result = AUDCLNT_E_INVALID_DEVICE_PERIOD;
-            else if (params->duration > 20000000) /* The smaller the period, the lower this limit. */
-                params->result = AUDCLNT_E_BUFFER_SIZE_ERROR;
-            else if (params->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) {
-                if (params->duration != params->period)
-                    params->result = AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
-
-                FIXME("EXCLUSIVE mode with EVENTCALLBACK\n");
-
-                params->result = AUDCLNT_E_DEVICE_IN_USE;
-            } else if (params->duration < 8 * params->period)
-                params->duration = 8 * params->period; /* May grow above 2s. */
-        }
-    }
-
-    if (FAILED(params->result))
-        return STATUS_SUCCESS;
-
     stream = calloc(1, sizeof(*stream));
     if(!stream){
         params->result = E_OUTOFMEMORY;
@@ -1011,7 +965,7 @@ static NTSTATUS alsa_create_stream(void *args)
     stream->fmt = &fmtex->Format;
 
     size = stream->bufsize_frames * params->fmt->nBlockAlign;
-    if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->local_buffer, zero_bits, &size,
+    if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->local_buffer, zero_bits(), &size,
                                MEM_COMMIT, PAGE_READWRITE)){
         params->result = E_OUTOFMEMORY;
         goto exit;
@@ -1057,7 +1011,6 @@ exit:
         free(stream->vols);
         free(stream);
     }else{
-        *params->channel_count = params->fmt->nChannels;
         *params->stream = (stream_handle)(UINT_PTR)stream;
     }
 
@@ -1725,7 +1678,7 @@ static NTSTATUS alsa_get_render_buffer(void *args)
                 stream->tmp_buffer = NULL;
             }
             size = frames * stream->fmt->nBlockAlign;
-            if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer, zero_bits, &size,
+            if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer, zero_bits(), &size,
                                        MEM_COMMIT, PAGE_READWRITE)){
                 stream->tmp_buffer_frames = 0;
                 return alsa_unlock_result(stream, &params->result, E_OUTOFMEMORY);
@@ -1828,7 +1781,7 @@ static NTSTATUS alsa_get_capture_buffer(void *args)
                 stream->tmp_buffer = NULL;
             }
             size = *frames * stream->fmt->nBlockAlign;
-            if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer, zero_bits, &size,
+            if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer, zero_bits(), &size,
                                        MEM_COMMIT, PAGE_READWRITE)){
                 stream->tmp_buffer_frames = 0;
                 return alsa_unlock_result(stream, &params->result, E_OUTOFMEMORY);
@@ -2146,20 +2099,6 @@ exit:
     return STATUS_SUCCESS;
 }
 
-static NTSTATUS alsa_get_device_period(void *args)
-{
-    struct get_device_period_params *params = args;
-
-    if (params->def_period)
-        *params->def_period = def_period;
-    if (params->min_period)
-        *params->min_period = def_period;
-
-    params->result = S_OK;
-
-    return STATUS_SUCCESS;
-}
-
 static NTSTATUS alsa_get_buffer_size(void *args)
 {
     struct get_buffer_size_params *params = args;
@@ -2241,12 +2180,6 @@ static NTSTATUS alsa_get_position(void *args)
     UINT64 position;
     snd_pcm_state_t alsa_state;
 
-    if (params->device) {
-        FIXME("Device position reporting not implemented\n");
-        params->result = E_NOTIMPL;
-        return STATUS_SUCCESS;
-    }
-
     alsa_lock(stream);
 
     /* avail_update required to get accurate snd_pcm_state() */
@@ -2506,9 +2439,9 @@ static NTSTATUS alsa_get_prop_value(void *args)
 
 const unixlib_entry_t __wine_unix_call_funcs[] =
 {
-    alsa_process_attach,
-    alsa_not_implemented,
-    alsa_main_loop,
+    NULL,
+    NULL,
+    NULL,
     alsa_get_endpoint_ids,
     alsa_create_stream,
     alsa_release_stream,
@@ -2522,7 +2455,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     alsa_release_capture_buffer,
     alsa_is_format_supported,
     alsa_get_mix_format,
-    alsa_get_device_period,
+    NULL,
     alsa_get_buffer_size,
     alsa_get_latency,
     alsa_get_current_padding,
@@ -2531,36 +2464,21 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     alsa_get_position,
     alsa_set_volumes,
     alsa_set_event_handle,
-    alsa_not_implemented,
+    NULL,
     alsa_is_started,
     alsa_get_prop_value,
-    alsa_not_implemented,
+    NULL,
     alsa_midi_release,
     alsa_midi_out_message,
     alsa_midi_in_message,
     alsa_midi_notify_wait,
-    alsa_not_implemented,
+    NULL,
 };
 
-C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == funcs_count);
-
 #ifdef _WIN64
 
 typedef UINT PTR32;
 
-static NTSTATUS alsa_wow64_main_loop(void *args)
-{
-    struct
-    {
-        PTR32 event;
-    } *params32 = args;
-    struct main_loop_params params =
-    {
-        .event = ULongToHandle(params32->event)
-    };
-    return alsa_main_loop(&params);
-}
-
 static NTSTATUS alsa_wow64_get_endpoint_ids(void *args)
 {
     struct
@@ -2732,28 +2650,6 @@ static NTSTATUS alsa_wow64_get_mix_format(void *args)
     return STATUS_SUCCESS;
 }
 
-static NTSTATUS alsa_wow64_get_device_period(void *args)
-{
-    struct
-    {
-        PTR32 device;
-        EDataFlow flow;
-        HRESULT result;
-        PTR32 def_period;
-        PTR32 min_period;
-    } *params32 = args;
-    struct get_device_period_params params =
-    {
-        .device = ULongToPtr(params32->device),
-        .flow = params32->flow,
-        .def_period = ULongToPtr(params32->def_period),
-        .min_period = ULongToPtr(params32->min_period),
-    };
-    alsa_get_device_period(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
 static NTSTATUS alsa_wow64_get_buffer_size(void *args)
 {
     struct
@@ -2874,6 +2770,7 @@ static NTSTATUS alsa_wow64_set_volumes(void *args)
         float master_volume;
         PTR32 volumes;
         PTR32 session_volumes;
+        int channel;
     } *params32 = args;
     struct set_volumes_params params =
     {
@@ -2881,6 +2778,7 @@ static NTSTATUS alsa_wow64_set_volumes(void *args)
         .master_volume = params32->master_volume,
         .volumes = ULongToPtr(params32->volumes),
         .session_volumes = ULongToPtr(params32->session_volumes),
+        .channel = params32->channel
     };
     return alsa_set_volumes(&params);
 }
@@ -2962,9 +2860,9 @@ static NTSTATUS alsa_wow64_get_prop_value(void *args)
 
 const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
 {
-    alsa_process_attach,
-    alsa_not_implemented,
-    alsa_wow64_main_loop,
+    NULL,
+    NULL,
+    NULL,
     alsa_wow64_get_endpoint_ids,
     alsa_wow64_create_stream,
     alsa_wow64_release_stream,
@@ -2978,7 +2876,7 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
     alsa_release_capture_buffer,
     alsa_wow64_is_format_supported,
     alsa_wow64_get_mix_format,
-    alsa_wow64_get_device_period,
+    NULL,
     alsa_wow64_get_buffer_size,
     alsa_wow64_get_latency,
     alsa_wow64_get_current_padding,
@@ -2987,17 +2885,15 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
     alsa_wow64_get_position,
     alsa_wow64_set_volumes,
     alsa_wow64_set_event_handle,
-    alsa_not_implemented,
+    NULL,
     alsa_is_started,
     alsa_wow64_get_prop_value,
-    alsa_not_implemented,
+    NULL,
     alsa_midi_release,
     alsa_wow64_midi_out_message,
     alsa_wow64_midi_in_message,
     alsa_wow64_midi_notify_wait,
-    alsa_not_implemented,
+    NULL,
 };
 
-C_ASSERT(ARRAYSIZE(__wine_unix_call_wow64_funcs) == funcs_count);
-
 #endif /* _WIN64 */
diff --git a/dlls/winealsa.drv/mmdevdrv.c b/dlls/winealsa.drv/mmdevdrv.c
index 11111111111..11111111111 100644
--- a/dlls/winealsa.drv/mmdevdrv.c
+++ b/dlls/winealsa.drv/mmdevdrv.c
@@ -21,7 +21,6 @@
 #define COBJMACROS
 
 #include <stdarg.h>
-#include <wchar.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -47,41 +46,211 @@
 
 #include "unixlib.h"
 
-#include "../mmdevapi/mmdevdrv.h"
-
 WINE_DEFAULT_DEBUG_CHANNEL(alsa);
 
-static WCHAR drv_key_devicesW[256];
+#define NULL_PTR_ERR MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER)
+
+static const REFERENCE_TIME DefaultPeriod = 100000;
+static const REFERENCE_TIME MinimumPeriod = 50000;
+
+int GetAudioEnv(char const* env, int def) {
+  char* val = getenv(env);
+  if (val) {
+    return atoi(val);
+  }
+  return def;
+}
+
+struct ACImpl;
+typedef struct ACImpl ACImpl;
+
+typedef struct _AudioSession {
+    GUID guid;
+    struct list clients;
+
+    IMMDevice *device;
+
+    float master_vol;
+    UINT32 channel_count;
+    float *channel_vols;
+    BOOL mute;
+
+    struct list entry;
+} AudioSession;
+
+typedef struct _AudioSessionWrapper {
+    IAudioSessionControl2 IAudioSessionControl2_iface;
+    IChannelAudioVolume IChannelAudioVolume_iface;
+    ISimpleAudioVolume ISimpleAudioVolume_iface;
+
+    LONG ref;
+
+    ACImpl *client;
+    AudioSession *session;
+} AudioSessionWrapper;
+
+struct ACImpl {
+    IAudioClient3 IAudioClient3_iface;
+    IAudioRenderClient IAudioRenderClient_iface;
+    IAudioCaptureClient IAudioCaptureClient_iface;
+    IAudioClock IAudioClock_iface;
+    IAudioClock2 IAudioClock2_iface;
+    IAudioStreamVolume IAudioStreamVolume_iface;
+
+    LONG ref;
+
+    IMMDevice *parent;
+    IUnknown *pUnkFTMarshal;
+
+    EDataFlow dataflow;
+    float *vols;
+    UINT32 channel_count;
+    stream_handle stream;
+
+    HANDLE timer_thread;
+
+    AudioSession *session;
+    AudioSessionWrapper *session_wrapper;
+
+    struct list entry;
+
+    /* Keep at end */
+    char alsa_name[1];
+};
+
+typedef struct _SessionMgr {
+    IAudioSessionManager2 IAudioSessionManager2_iface;
+
+    LONG ref;
+
+    IMMDevice *device;
+} SessionMgr;
+
+static CRITICAL_SECTION g_sessions_lock;
+static CRITICAL_SECTION_DEBUG g_sessions_lock_debug =
+{
+    0, 0, &g_sessions_lock,
+    { &g_sessions_lock_debug.ProcessLocksList, &g_sessions_lock_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": g_sessions_lock") }
+};
+static CRITICAL_SECTION g_sessions_lock = { &g_sessions_lock_debug, -1, 0, 0, 0, 0 };
+static struct list g_sessions = LIST_INIT(g_sessions);
+
+static const WCHAR drv_key_devicesW[] = {'S','o','f','t','w','a','r','e','\\',
+    'W','i','n','e','\\','D','r','i','v','e','r','s','\\',
+    'w','i','n','e','a','l','s','a','.','d','r','v','\\','d','e','v','i','c','e','s',0};
 static const WCHAR guidW[] = {'g','u','i','d',0};
 
-BOOL WINAPI DllMain(HINSTANCE dll, DWORD reason, void *reserved)
+static const IAudioClient3Vtbl AudioClient3_Vtbl;
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl;
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl;
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl;
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl;
+static const IAudioClockVtbl AudioClock_Vtbl;
+static const IAudioClock2Vtbl AudioClock2_Vtbl;
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl;
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl;
+static const IAudioSessionManager2Vtbl AudioSessionManager2_Vtbl;
+
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client);
+
+static inline ACImpl *impl_from_IAudioClient3(IAudioClient3 *iface)
 {
-    switch (reason)
-    {
-    case DLL_PROCESS_ATTACH:
-    {
-        WCHAR buf[MAX_PATH];
-        WCHAR *filename;
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClient3_iface);
+}
 
-        if(__wine_init_unix_call()) return FALSE;
+static inline ACImpl *impl_from_IAudioRenderClient(IAudioRenderClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioRenderClient_iface);
+}
+
+static inline ACImpl *impl_from_IAudioCaptureClient(IAudioCaptureClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioCaptureClient_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IAudioSessionControl2(IAudioSessionControl2 *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IAudioSessionControl2_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_ISimpleAudioVolume(ISimpleAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, ISimpleAudioVolume_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IChannelAudioVolume(IChannelAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IChannelAudioVolume_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock(IAudioClock *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock_iface);
+}
 
-        GetModuleFileNameW(dll, buf, ARRAY_SIZE(buf));
+static inline ACImpl *impl_from_IAudioClock2(IAudioClock2 *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock2_iface);
+}
 
-        filename = wcsrchr(buf, '\\');
-        filename = filename ? filename + 1 : buf;
+static inline ACImpl *impl_from_IAudioStreamVolume(IAudioStreamVolume *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioStreamVolume_iface);
+}
 
-        swprintf(drv_key_devicesW, ARRAY_SIZE(drv_key_devicesW),
-                 L"Software\\Wine\\Drivers\\%s\\devices", filename);
+static inline SessionMgr *impl_from_IAudioSessionManager2(IAudioSessionManager2 *iface)
+{
+    return CONTAINING_RECORD(iface, SessionMgr, IAudioSessionManager2_iface);
+}
 
+BOOL WINAPI DllMain(HINSTANCE dll, DWORD reason, void *reserved)
+{
+    switch (reason)
+    {
+    case DLL_PROCESS_ATTACH:
+        if(__wine_init_unix_call()) return FALSE;
         break;
-    }
+
     case DLL_PROCESS_DETACH:
         if (reserved) break;
+        DeleteCriticalSection(&g_sessions_lock);
         break;
     }
     return TRUE;
 }
 
+int WINAPI AUDDRV_GetPriority(void)
+{
+    return Priority_Neutral;
+}
+
+static HRESULT alsa_stream_release(stream_handle stream, HANDLE timer_thread)
+{
+    struct release_stream_params params;
+
+    params.stream = stream;
+    params.timer_thread = timer_thread;
+
+    ALSA_CALL(release_stream, &params);
+
+    return params.result;
+}
+
+static DWORD WINAPI alsa_timer_thread(void *user)
+{
+    struct timer_loop_params params;
+    struct ACImpl *This = user;
+
+    SetThreadDescription(GetCurrentThread(), L"winealsa_timer");
+
+    params.stream = This->stream;
+
+    ALSA_CALL(timer_loop, &params);
+
+    return 0;
+}
+
 static void set_device_guid(EDataFlow flow, HKEY drv_key, const WCHAR *key_name,
         GUID *guid)
 {
@@ -117,7 +286,7 @@ exit:
         RegCloseKey(drv_key);
 }
 
-void WINAPI get_device_guid(EDataFlow flow, const char *device, GUID *guid)
+static void get_device_guid(EDataFlow flow, const char *device, GUID *guid)
 {
     HKEY key = NULL, dev_key;
     DWORD type, size = sizeof(*guid);
@@ -154,7 +323,81 @@ void WINAPI get_device_guid(EDataFlow flow, const char *device, GUID *guid)
         RegCloseKey(key);
 }
 
-BOOL WINAPI get_device_name_from_guid(GUID *guid, char **name, EDataFlow *flow)
+static void set_stream_volumes(ACImpl *This)
+{
+    struct set_volumes_params params;
+
+    params.stream = This->stream;
+    params.master_volume = (This->session->mute ? 0.0f : This->session->master_vol);
+    params.volumes = This->vols;
+    params.session_volumes = This->session->channel_vols;
+    params.channel = 0;
+
+    ALSA_CALL(set_volumes, &params);
+}
+
+HRESULT WINAPI AUDDRV_GetEndpointIDs(EDataFlow flow, WCHAR ***ids_out, GUID **guids_out,
+        UINT *num, UINT *def_index)
+{
+    struct get_endpoint_ids_params params;
+    unsigned int i;
+    GUID *guids = NULL;
+    WCHAR **ids = NULL;
+
+    TRACE("%d %p %p %p %p\n", flow, ids, guids, num, def_index);
+
+    params.flow = flow;
+    params.size = 1000;
+    params.endpoints = NULL;
+    do{
+        HeapFree(GetProcessHeap(), 0, params.endpoints);
+        params.endpoints = HeapAlloc(GetProcessHeap(), 0, params.size);
+        ALSA_CALL(get_endpoint_ids, &params);
+    }while(params.result == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
+
+    if(FAILED(params.result)) goto end;
+
+    ids = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, params.num * sizeof(*ids));
+    guids = HeapAlloc(GetProcessHeap(), 0, params.num * sizeof(*guids));
+    if(!ids || !guids){
+        params.result = E_OUTOFMEMORY;
+        goto end;
+    }
+
+    for(i = 0; i < params.num; i++){
+        WCHAR *name = (WCHAR *)((char *)params.endpoints + params.endpoints[i].name);
+        char *device = (char *)params.endpoints + params.endpoints[i].device;
+        unsigned int size = (wcslen(name) + 1) * sizeof(WCHAR);
+
+        ids[i] = HeapAlloc(GetProcessHeap(), 0, size);
+        if(!ids[i]){
+            params.result = E_OUTOFMEMORY;
+            goto end;
+        }
+        memcpy(ids[i], name, size);
+        get_device_guid(flow, device, guids + i);
+    }
+    *def_index = params.default_idx;
+
+end:
+    HeapFree(GetProcessHeap(), 0, params.endpoints);
+    if(FAILED(params.result)){
+        HeapFree(GetProcessHeap(), 0, guids);
+        if(ids){
+            for(i = 0; i < params.num; i++)
+                HeapFree(GetProcessHeap(), 0, ids[i]);
+            HeapFree(GetProcessHeap(), 0, ids);
+        }
+    }else{
+        *ids_out = ids;
+        *guids_out = guids;
+        *num = params.num;
+    }
+
+    return params.result;
+}
+
+static BOOL get_alsa_name_by_guid(GUID *guid, char *name, DWORD name_size, EDataFlow *flow)
 {
     HKEY devices_key;
     UINT i = 0;
@@ -185,8 +428,6 @@ BOOL WINAPI get_device_name_from_guid(GUID *guid, char **name, EDataFlow *flow)
         if(RegQueryValueExW(key, guidW, 0, &type,
                     (BYTE*)&reg_guid, &size) == ERROR_SUCCESS){
             if(IsEqualGUID(&reg_guid, guid)){
-                INT size;
-
                 RegCloseKey(key);
                 RegCloseKey(devices_key);
 
@@ -201,16 +442,7 @@ BOOL WINAPI get_device_name_from_guid(GUID *guid, char **name, EDataFlow *flow)
                     return FALSE;
                 }
 
-                if(!(size = WideCharToMultiByte(CP_UNIXCP, 0, key_name + 2, -1, NULL, 0, NULL, NULL)))
-                    return FALSE;
-
-                if(!(*name = malloc(size)))
-                    return FALSE;
-
-                if(!WideCharToMultiByte(CP_UNIXCP, 0, key_name + 2, -1, *name, size, NULL, NULL)){
-                    free(*name);
-                    return FALSE;
-                }
+                WideCharToMultiByte(CP_UNIXCP, 0, key_name + 2, -1, name, name_size, NULL, NULL);
 
                 return TRUE;
             }
@@ -225,3 +457,2028 @@ BOOL WINAPI get_device_name_from_guid(GUID *guid, char **name, EDataFlow *flow)
 
     return FALSE;
 }
+
+HRESULT WINAPI AUDDRV_GetAudioEndpoint(GUID *guid, IMMDevice *dev, IAudioClient **out)
+{
+    ACImpl *This;
+    char alsa_name[256];
+    EDataFlow dataflow;
+    HRESULT hr;
+    int len;
+
+    TRACE("%s %p %p\n", debugstr_guid(guid), dev, out);
+
+    if(!get_alsa_name_by_guid(guid, alsa_name, sizeof(alsa_name), &dataflow))
+        return AUDCLNT_E_DEVICE_INVALIDATED;
+
+    if(dataflow != eRender && dataflow != eCapture)
+        return E_UNEXPECTED;
+
+    len = strlen(alsa_name);
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, offsetof(ACImpl, alsa_name[len + 1]));
+    if(!This)
+        return E_OUTOFMEMORY;
+
+    This->IAudioClient3_iface.lpVtbl = &AudioClient3_Vtbl;
+    This->IAudioRenderClient_iface.lpVtbl = &AudioRenderClient_Vtbl;
+    This->IAudioCaptureClient_iface.lpVtbl = &AudioCaptureClient_Vtbl;
+    This->IAudioClock_iface.lpVtbl = &AudioClock_Vtbl;
+    This->IAudioClock2_iface.lpVtbl = &AudioClock2_Vtbl;
+    This->IAudioStreamVolume_iface.lpVtbl = &AudioStreamVolume_Vtbl;
+
+    hr = CoCreateFreeThreadedMarshaler((IUnknown *)&This->IAudioClient3_iface, &This->pUnkFTMarshal);
+    if (FAILED(hr)) {
+        HeapFree(GetProcessHeap(), 0, This);
+        return hr;
+    }
+
+    This->dataflow = dataflow;
+    memcpy(This->alsa_name, alsa_name, len + 1);
+
+    This->parent = dev;
+    IMMDevice_AddRef(This->parent);
+
+    *out = (IAudioClient *)&This->IAudioClient3_iface;
+    IAudioClient3_AddRef(&This->IAudioClient3_iface);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_QueryInterface(IAudioClient3 *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioClient) ||
+            IsEqualIID(riid, &IID_IAudioClient2) ||
+            IsEqualIID(riid, &IID_IAudioClient3))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->pUnkFTMarshal, riid, ppv);
+
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClient_AddRef(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioClient_Release(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    ULONG ref;
+
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    if(!ref){
+        IAudioClient3_Stop(iface);
+        IMMDevice_Release(This->parent);
+        IUnknown_Release(This->pUnkFTMarshal);
+        if(This->session){
+            EnterCriticalSection(&g_sessions_lock);
+            list_remove(&This->entry);
+            LeaveCriticalSection(&g_sessions_lock);
+        }
+        HeapFree(GetProcessHeap(), 0, This->vols);
+        if (This->stream)
+            alsa_stream_release(This->stream, This->timer_thread);
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static void dump_fmt(const WAVEFORMATEX *fmt)
+{
+    TRACE("wFormatTag: 0x%x (", fmt->wFormatTag);
+    switch(fmt->wFormatTag){
+    case WAVE_FORMAT_PCM:
+        TRACE("WAVE_FORMAT_PCM");
+        break;
+    case WAVE_FORMAT_IEEE_FLOAT:
+        TRACE("WAVE_FORMAT_IEEE_FLOAT");
+        break;
+    case WAVE_FORMAT_EXTENSIBLE:
+        TRACE("WAVE_FORMAT_EXTENSIBLE");
+        break;
+    default:
+        TRACE("Unknown");
+        break;
+    }
+    TRACE(")\n");
+
+    TRACE("nChannels: %u\n", fmt->nChannels);
+    TRACE("nSamplesPerSec: %lu\n", fmt->nSamplesPerSec);
+    TRACE("nAvgBytesPerSec: %lu\n", fmt->nAvgBytesPerSec);
+    TRACE("nBlockAlign: %u\n", fmt->nBlockAlign);
+    TRACE("wBitsPerSample: %u\n", fmt->wBitsPerSample);
+    TRACE("cbSize: %u\n", fmt->cbSize);
+
+    if(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE){
+        WAVEFORMATEXTENSIBLE *fmtex = (void*)fmt;
+        TRACE("dwChannelMask: %08lx\n", fmtex->dwChannelMask);
+        TRACE("Samples: %04x\n", fmtex->Samples.wReserved);
+        TRACE("SubFormat: %s\n", wine_dbgstr_guid(&fmtex->SubFormat));
+    }
+}
+
+static void session_init_vols(AudioSession *session, UINT channels)
+{
+    if(session->channel_count < channels){
+        UINT i;
+
+        if(session->channel_vols)
+            session->channel_vols = HeapReAlloc(GetProcessHeap(), 0,
+                    session->channel_vols, sizeof(float) * channels);
+        else
+            session->channel_vols = HeapAlloc(GetProcessHeap(), 0,
+                    sizeof(float) * channels);
+        if(!session->channel_vols)
+            return;
+
+        for(i = session->channel_count; i < channels; ++i)
+            session->channel_vols[i] = 1.f;
+
+        session->channel_count = channels;
+    }
+}
+
+static AudioSession *create_session(const GUID *guid, IMMDevice *device,
+        UINT num_channels)
+{
+    AudioSession *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(AudioSession));
+    if(!ret)
+        return NULL;
+
+    memcpy(&ret->guid, guid, sizeof(GUID));
+
+    ret->device = device;
+
+    list_init(&ret->clients);
+
+    list_add_head(&g_sessions, &ret->entry);
+
+    session_init_vols(ret, num_channels);
+
+    ret->master_vol = 1.f;
+
+    return ret;
+}
+
+/* if channels == 0, then this will return or create a session with
+ * matching dataflow and GUID. otherwise, channels must also match */
+static HRESULT get_audio_session(const GUID *sessionguid,
+        IMMDevice *device, UINT channels, AudioSession **out)
+{
+    AudioSession *session;
+
+    if(!sessionguid || IsEqualGUID(sessionguid, &GUID_NULL)){
+        *out = create_session(&GUID_NULL, device, channels);
+        if(!*out)
+            return E_OUTOFMEMORY;
+
+        return S_OK;
+    }
+
+    *out = NULL;
+    LIST_FOR_EACH_ENTRY(session, &g_sessions, AudioSession, entry){
+        if(session->device == device &&
+                IsEqualGUID(sessionguid, &session->guid)){
+            session_init_vols(session, channels);
+            *out = session;
+            break;
+        }
+    }
+
+    if(!*out){
+        *out = create_session(sessionguid, device, channels);
+        if(!*out)
+            return E_OUTOFMEMORY;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Initialize(IAudioClient3 *iface,
+        AUDCLNT_SHAREMODE mode, DWORD flags, REFERENCE_TIME duration,
+        REFERENCE_TIME period, const WAVEFORMATEX *fmt,
+        const GUID *sessionguid)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct create_stream_params params;
+    stream_handle stream;
+    unsigned int i;
+
+    TRACE("(%p)->(%x, %lx, %s, %s, %p, %s)\n", This, mode, flags,
+          wine_dbgstr_longlong(duration), wine_dbgstr_longlong(period), fmt, debugstr_guid(sessionguid));
+
+    if(!fmt)
+        return E_POINTER;
+
+    if(mode != AUDCLNT_SHAREMODE_SHARED && mode != AUDCLNT_SHAREMODE_EXCLUSIVE)
+        return E_INVALIDARG;
+
+    if(flags & ~(AUDCLNT_STREAMFLAGS_CROSSPROCESS |
+                AUDCLNT_STREAMFLAGS_LOOPBACK |
+                AUDCLNT_STREAMFLAGS_EVENTCALLBACK |
+                AUDCLNT_STREAMFLAGS_NOPERSIST |
+                AUDCLNT_STREAMFLAGS_RATEADJUST |
+                AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED |
+                AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY |
+                AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM)){
+        FIXME("Unknown flags: %08lx\n", flags);
+        return E_INVALIDARG;
+    }
+
+    if(mode == AUDCLNT_SHAREMODE_SHARED){
+        period = GetAudioEnv("STAGING_AUDIO_DEFAULT_PERIOD", DefaultPeriod);
+        duration = GetAudioEnv("STAGING_AUDIO_DURATION", 100000);
+    }else{
+        if(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE){
+            if(((WAVEFORMATEXTENSIBLE*)fmt)->dwChannelMask == 0 ||
+                    ((WAVEFORMATEXTENSIBLE*)fmt)->dwChannelMask & SPEAKER_RESERVED)
+                return AUDCLNT_E_UNSUPPORTED_FORMAT;
+        }
+
+        if(!period){
+            period = GetAudioEnv("STAGING_AUDIO_DEFAULT_PERIOD", DefaultPeriod); /* not minimum */
+            duration = GetAudioEnv("STAGING_AUDIO_DURATION", 100000);
+        }
+        if(period < GetAudioEnv("STAGING_AUDIO_MINIMUM_PERIOD", MinimumPeriod) || period > 5000000)
+            return AUDCLNT_E_INVALID_DEVICE_PERIOD;
+        if(duration > 20000000) /* the smaller the period, the lower this limit */
+            return AUDCLNT_E_BUFFER_SIZE_ERROR;
+        if(flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK){
+            if(duration != period)
+                return AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
+            FIXME("EXCLUSIVE mode with EVENTCALLBACK\n");
+            return AUDCLNT_E_DEVICE_IN_USE;
+        }else{
+            if( duration < 8 * period)
+                duration = 8 * period; /* may grow above 2s */
+        }
+    }
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(This->stream){
+        LeaveCriticalSection(&g_sessions_lock);
+        return AUDCLNT_E_ALREADY_INITIALIZED;
+    }
+
+    dump_fmt(fmt);
+
+    params.name = NULL;
+    params.device = This->alsa_name;
+    params.flow = This->dataflow;
+    params.share = mode;
+    params.flags = flags;
+    params.duration = duration;
+    params.period = period;
+    params.fmt = fmt;
+    params.channel_count = NULL;
+    params.stream = &stream;
+
+    ALSA_CALL(create_stream, &params);
+    if(FAILED(params.result)){
+        LeaveCriticalSection(&g_sessions_lock);
+        return params.result;
+    }
+
+    This->channel_count = fmt->nChannels;
+    This->vols = HeapAlloc(GetProcessHeap(), 0, This->channel_count * sizeof(float));
+    if(!This->vols){
+        params.result = E_OUTOFMEMORY;
+        goto exit;
+    }
+    for(i = 0; i < This->channel_count; ++i)
+        This->vols[i] = 1.f;
+
+    params.result = get_audio_session(sessionguid, This->parent, This->channel_count,
+                                      &This->session);
+    if(FAILED(params.result))
+        goto exit;
+
+    list_add_tail(&This->session->clients, &This->entry);
+
+exit:
+    if(FAILED(params.result)){
+        alsa_stream_release(stream, NULL);
+        HeapFree(GetProcessHeap(), 0, This->vols);
+        This->vols = NULL;
+    }else{
+        This->stream = stream;
+        set_stream_volumes(This);
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetBufferSize(IAudioClient3 *iface,
+        UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_buffer_size_params params;
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if(!out)
+        return E_POINTER;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    params.frames = out;
+
+    ALSA_CALL(get_buffer_size, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetStreamLatency(IAudioClient3 *iface,
+        REFERENCE_TIME *latency)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_latency_params params;
+
+    TRACE("(%p)->(%p)\n", This, latency);
+
+    if(!latency)
+        return E_POINTER;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    params.latency = latency;
+
+    ALSA_CALL(get_latency, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetCurrentPadding(IAudioClient3 *iface,
+        UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_current_padding_params params;
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if(!out)
+        return E_POINTER;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    params.padding = out;
+
+    ALSA_CALL(get_current_padding, &params);
+
+    TRACE("pad: %u\n", *out);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_IsFormatSupported(IAudioClient3 *iface,
+        AUDCLNT_SHAREMODE mode, const WAVEFORMATEX *fmt,
+        WAVEFORMATEX **out)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct is_format_supported_params params;
+
+    TRACE("(%p)->(%x, %p, %p)\n", This, mode, fmt, out);
+    if(fmt) dump_fmt(fmt);
+
+    params.device = This->alsa_name;
+    params.flow = This->dataflow;
+    params.share = mode;
+    params.fmt_in = fmt;
+    params.fmt_out = NULL;
+
+    if(out){
+        *out = NULL;
+        if(mode == AUDCLNT_SHAREMODE_SHARED)
+            params.fmt_out = CoTaskMemAlloc(sizeof(*params.fmt_out));
+    }
+    ALSA_CALL(is_format_supported, &params);
+
+    if(params.result == S_FALSE)
+        *out = &params.fmt_out->Format;
+    else
+        CoTaskMemFree(params.fmt_out);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetMixFormat(IAudioClient3 *iface,
+        WAVEFORMATEX **pwfx)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_mix_format_params params;
+
+    TRACE("(%p)->(%p)\n", This, pwfx);
+
+    if(!pwfx)
+        return E_POINTER;
+    *pwfx = NULL;
+
+    params.device = This->alsa_name;
+    params.flow = This->dataflow;
+    params.fmt = CoTaskMemAlloc(sizeof(WAVEFORMATEXTENSIBLE));
+    if(!params.fmt)
+        return E_OUTOFMEMORY;
+
+    ALSA_CALL(get_mix_format, &params);
+
+    if(SUCCEEDED(params.result)){
+        *pwfx = &params.fmt->Format;
+        dump_fmt(*pwfx);
+    } else
+        CoTaskMemFree(params.fmt);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetDevicePeriod(IAudioClient3 *iface,
+        REFERENCE_TIME *defperiod, REFERENCE_TIME *minperiod)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    TRACE("(%p)->(%p, %p)\n", This, defperiod, minperiod);
+
+    if(!defperiod && !minperiod)
+        return E_POINTER;
+
+    if(defperiod)
+        *defperiod = GetAudioEnv("STAGING_AUDIO_DEFAULT_PERIOD", DefaultPeriod);
+    if(minperiod)
+        *minperiod = GetAudioEnv("STAGING_AUDIO_MINIMUM_PERIOD", MinimumPeriod);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Start(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct start_params params;
+
+    TRACE("(%p)\n", This);
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(!This->stream){
+        LeaveCriticalSection(&g_sessions_lock);
+        return AUDCLNT_E_NOT_INITIALIZED;
+    }
+
+    params.stream = This->stream;
+
+    ALSA_CALL(start, &params);
+
+    if(SUCCEEDED(params.result) && !This->timer_thread){
+        This->timer_thread = CreateThread(NULL, 0, alsa_timer_thread, This, 0, NULL);
+        SetThreadPriority(This->timer_thread, THREAD_PRIORITY_TIME_CRITICAL);
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_Stop(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct stop_params params;
+
+    TRACE("(%p)\n", This);
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+
+    ALSA_CALL(stop, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_Reset(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct reset_params params;
+
+    TRACE("(%p)\n", This);
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+
+    ALSA_CALL(reset, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_SetEventHandle(IAudioClient3 *iface,
+        HANDLE event)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct set_event_handle_params params;
+
+    TRACE("(%p)->(%p)\n", This, event);
+
+    if(!event)
+        return E_INVALIDARG;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    params.event = event;
+
+    ALSA_CALL(set_event_handle, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetService(IAudioClient3 *iface, REFIID riid,
+        void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(!This->stream){
+        LeaveCriticalSection(&g_sessions_lock);
+        return AUDCLNT_E_NOT_INITIALIZED;
+    }
+
+    if(IsEqualIID(riid, &IID_IAudioRenderClient)){
+        if(This->dataflow != eRender){
+            LeaveCriticalSection(&g_sessions_lock);
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        }
+        IAudioRenderClient_AddRef(&This->IAudioRenderClient_iface);
+        *ppv = &This->IAudioRenderClient_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioCaptureClient)){
+        if(This->dataflow != eCapture){
+            LeaveCriticalSection(&g_sessions_lock);
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        }
+        IAudioCaptureClient_AddRef(&This->IAudioCaptureClient_iface);
+        *ppv = &This->IAudioCaptureClient_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioClock)){
+        IAudioClock_AddRef(&This->IAudioClock_iface);
+        *ppv = &This->IAudioClock_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioStreamVolume)){
+        IAudioStreamVolume_AddRef(&This->IAudioStreamVolume_iface);
+        *ppv = &This->IAudioStreamVolume_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioSessionControl)){
+        if(!This->session_wrapper){
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if(!This->session_wrapper){
+                LeaveCriticalSection(&g_sessions_lock);
+                return E_OUTOFMEMORY;
+            }
+        }else
+            IAudioSessionControl2_AddRef(&This->session_wrapper->IAudioSessionControl2_iface);
+
+        *ppv = &This->session_wrapper->IAudioSessionControl2_iface;
+    }else if(IsEqualIID(riid, &IID_IChannelAudioVolume)){
+        if(!This->session_wrapper){
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if(!This->session_wrapper){
+                LeaveCriticalSection(&g_sessions_lock);
+                return E_OUTOFMEMORY;
+            }
+        }else
+            IChannelAudioVolume_AddRef(&This->session_wrapper->IChannelAudioVolume_iface);
+
+        *ppv = &This->session_wrapper->IChannelAudioVolume_iface;
+    }else if(IsEqualIID(riid, &IID_ISimpleAudioVolume)){
+        if(!This->session_wrapper){
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if(!This->session_wrapper){
+                LeaveCriticalSection(&g_sessions_lock);
+                return E_OUTOFMEMORY;
+            }
+        }else
+            ISimpleAudioVolume_AddRef(&This->session_wrapper->ISimpleAudioVolume_iface);
+
+        *ppv = &This->session_wrapper->ISimpleAudioVolume_iface;
+    }
+
+    if(*ppv){
+        LeaveCriticalSection(&g_sessions_lock);
+        return S_OK;
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    FIXME("stub %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static HRESULT WINAPI AudioClient_IsOffloadCapable(IAudioClient3 *iface,
+        AUDIO_STREAM_CATEGORY category, BOOL *offload_capable)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    TRACE("(%p)->(0x%x, %p)\n", This, category, offload_capable);
+
+    if(!offload_capable)
+        return E_INVALIDARG;
+
+    *offload_capable = FALSE;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_SetClientProperties(IAudioClient3 *iface,
+        const AudioClientProperties *prop)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    const Win8AudioClientProperties *legacy_prop = (const Win8AudioClientProperties *)prop;
+
+    TRACE("(%p)->(%p)\n", This, prop);
+
+    if(!legacy_prop)
+        return E_POINTER;
+
+    if(legacy_prop->cbSize == sizeof(AudioClientProperties)){
+        TRACE("{ bIsOffload: %u, eCategory: 0x%x, Options: 0x%x }\n",
+                legacy_prop->bIsOffload,
+                legacy_prop->eCategory,
+                prop->Options);
+    }else if(legacy_prop->cbSize == sizeof(Win8AudioClientProperties)){
+        TRACE("{ bIsOffload: %u, eCategory: 0x%x }\n",
+                legacy_prop->bIsOffload,
+                legacy_prop->eCategory);
+    }else{
+        WARN("Unsupported Size = %d\n", legacy_prop->cbSize);
+        return E_INVALIDARG;
+    }
+
+
+    if(legacy_prop->bIsOffload)
+        return AUDCLNT_E_ENDPOINT_OFFLOAD_NOT_CAPABLE;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_GetBufferSizeLimits(IAudioClient3 *iface,
+        const WAVEFORMATEX *format, BOOL event_driven, REFERENCE_TIME *min_duration,
+        REFERENCE_TIME *max_duration)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(%p, %u, %p, %p)\n", This, format, event_driven, min_duration, max_duration);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioClient_GetSharedModeEnginePeriod(IAudioClient3 *iface,
+        const WAVEFORMATEX *format, UINT32 *default_period_frames, UINT32 *unit_period_frames,
+        UINT32 *min_period_frames, UINT32 *max_period_frames)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(%p, %p, %p, %p, %p)\n", This, format, default_period_frames, unit_period_frames,
+            min_period_frames, max_period_frames);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioClient_GetCurrentSharedModeEnginePeriod(IAudioClient3 *iface,
+        WAVEFORMATEX **cur_format, UINT32 *cur_period_frames)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(%p, %p)\n", This, cur_format, cur_period_frames);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioClient_InitializeSharedAudioStream(IAudioClient3 *iface,
+        DWORD flags, UINT32 period_frames, const WAVEFORMATEX *format,
+        const GUID *session_guid)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(0x%lx, %u, %p, %s)\n", This, flags, period_frames, format, debugstr_guid(session_guid));
+
+    return E_NOTIMPL;
+}
+
+static const IAudioClient3Vtbl AudioClient3_Vtbl =
+{
+    AudioClient_QueryInterface,
+    AudioClient_AddRef,
+    AudioClient_Release,
+    AudioClient_Initialize,
+    AudioClient_GetBufferSize,
+    AudioClient_GetStreamLatency,
+    AudioClient_GetCurrentPadding,
+    AudioClient_IsFormatSupported,
+    AudioClient_GetMixFormat,
+    AudioClient_GetDevicePeriod,
+    AudioClient_Start,
+    AudioClient_Stop,
+    AudioClient_Reset,
+    AudioClient_SetEventHandle,
+    AudioClient_GetService,
+    AudioClient_IsOffloadCapable,
+    AudioClient_SetClientProperties,
+    AudioClient_GetBufferSizeLimits,
+    AudioClient_GetSharedModeEnginePeriod,
+    AudioClient_GetCurrentSharedModeEnginePeriod,
+    AudioClient_InitializeSharedAudioStream,
+};
+
+static HRESULT WINAPI AudioRenderClient_QueryInterface(
+        IAudioRenderClient *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioRenderClient))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->pUnkFTMarshal, riid, ppv);
+
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioRenderClient_AddRef(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioRenderClient_Release(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioRenderClient_GetBuffer(IAudioRenderClient *iface,
+        UINT32 frames, BYTE **data)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    struct get_render_buffer_params params;
+
+    TRACE("(%p)->(%u, %p)\n", This, frames, data);
+
+    if(!data)
+        return E_POINTER;
+    *data = NULL;
+
+    params.stream = This->stream;
+    params.frames = frames;
+    params.data = data;
+
+    ALSA_CALL(get_render_buffer, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioRenderClient_ReleaseBuffer(
+        IAudioRenderClient *iface, UINT32 written_frames, DWORD flags)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    struct release_render_buffer_params params;
+
+    TRACE("(%p)->(%u, %lx)\n", This, written_frames, flags);
+
+    params.stream = This->stream;
+    params.written_frames = written_frames;
+    params.flags = flags;
+
+    ALSA_CALL(release_render_buffer, &params);
+
+    return params.result;
+}
+
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl = {
+    AudioRenderClient_QueryInterface,
+    AudioRenderClient_AddRef,
+    AudioRenderClient_Release,
+    AudioRenderClient_GetBuffer,
+    AudioRenderClient_ReleaseBuffer
+};
+
+static HRESULT WINAPI AudioCaptureClient_QueryInterface(
+        IAudioCaptureClient *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioCaptureClient))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->pUnkFTMarshal, riid, ppv);
+
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioCaptureClient_AddRef(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioCaptureClient_Release(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetBuffer(IAudioCaptureClient *iface,
+        BYTE **data, UINT32 *frames, DWORD *flags, UINT64 *devpos,
+        UINT64 *qpcpos)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    struct get_capture_buffer_params params;
+
+    TRACE("(%p)->(%p, %p, %p, %p, %p)\n", This, data, frames, flags,
+            devpos, qpcpos);
+
+    if(!data)
+        return E_POINTER;
+
+    *data = NULL;
+
+    if(!frames || !flags)
+        return E_POINTER;
+
+    params.stream = This->stream;
+    params.data = data;
+    params.frames = frames;
+    params.flags = (UINT*)flags;
+    params.devpos = devpos;
+    params.qpcpos = qpcpos;
+
+    ALSA_CALL(get_capture_buffer, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioCaptureClient_ReleaseBuffer(
+        IAudioCaptureClient *iface, UINT32 done)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    struct release_capture_buffer_params params;
+
+    TRACE("(%p)->(%u)\n", This, done);
+
+    params.stream = This->stream;
+    params.done = done;
+
+    ALSA_CALL(release_capture_buffer, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetNextPacketSize(
+        IAudioCaptureClient *iface, UINT32 *frames)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    struct get_next_packet_size_params params;
+
+    TRACE("(%p)->(%p)\n", This, frames);
+
+    if(!frames)
+        return E_POINTER;
+
+    params.stream = This->stream;
+    params.frames = frames;
+
+    ALSA_CALL(get_next_packet_size, &params);
+
+    return params.result;
+}
+
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl =
+{
+    AudioCaptureClient_QueryInterface,
+    AudioCaptureClient_AddRef,
+    AudioCaptureClient_Release,
+    AudioCaptureClient_GetBuffer,
+    AudioCaptureClient_ReleaseBuffer,
+    AudioCaptureClient_GetNextPacketSize
+};
+
+static HRESULT WINAPI AudioClock_QueryInterface(IAudioClock *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IAudioClock))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IAudioClock2))
+        *ppv = &This->IAudioClock2_iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClock_AddRef(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioClock_Release(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioClock_GetFrequency(IAudioClock *iface, UINT64 *freq)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    struct get_frequency_params params;
+
+    TRACE("(%p)->(%p)\n", This, freq);
+
+    params.stream = This->stream;
+    params.freq = freq;
+
+    ALSA_CALL(get_frequency, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClock_GetPosition(IAudioClock *iface, UINT64 *pos,
+        UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    struct get_position_params params;
+
+    TRACE("(%p)->(%p, %p)\n", This, pos, qpctime);
+
+    if(!pos)
+        return E_POINTER;
+
+    params.stream = This->stream;
+    params.device = FALSE;
+    params.pos = pos;
+    params.qpctime = qpctime;
+
+    ALSA_CALL(get_position, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClock_GetCharacteristics(IAudioClock *iface,
+        DWORD *chars)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%p)\n", This, chars);
+
+    if(!chars)
+        return E_POINTER;
+
+    *chars = AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ;
+
+    return S_OK;
+}
+
+static const IAudioClockVtbl AudioClock_Vtbl =
+{
+    AudioClock_QueryInterface,
+    AudioClock_AddRef,
+    AudioClock_Release,
+    AudioClock_GetFrequency,
+    AudioClock_GetPosition,
+    AudioClock_GetCharacteristics
+};
+
+static HRESULT WINAPI AudioClock2_QueryInterface(IAudioClock2 *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClock_QueryInterface(&This->IAudioClock_iface, riid, ppv);
+}
+
+static ULONG WINAPI AudioClock2_AddRef(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioClock2_Release(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioClock2_GetDevicePosition(IAudioClock2 *iface,
+        UINT64 *pos, UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+
+    FIXME("(%p)->(%p, %p)\n", This, pos, qpctime);
+
+    return E_NOTIMPL;
+}
+
+static const IAudioClock2Vtbl AudioClock2_Vtbl =
+{
+    AudioClock2_QueryInterface,
+    AudioClock2_AddRef,
+    AudioClock2_Release,
+    AudioClock2_GetDevicePosition
+};
+
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client)
+{
+    AudioSessionWrapper *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(AudioSessionWrapper));
+    if(!ret)
+        return NULL;
+
+    ret->IAudioSessionControl2_iface.lpVtbl = &AudioSessionControl2_Vtbl;
+    ret->ISimpleAudioVolume_iface.lpVtbl = &SimpleAudioVolume_Vtbl;
+    ret->IChannelAudioVolume_iface.lpVtbl = &ChannelAudioVolume_Vtbl;
+
+    ret->ref = 1;
+
+    ret->client = client;
+    if(client){
+        ret->session = client->session;
+        AudioClient_AddRef(&client->IAudioClient3_iface);
+    }
+
+    return ret;
+}
+
+static HRESULT WINAPI AudioSessionControl_QueryInterface(
+        IAudioSessionControl2 *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioSessionControl) ||
+            IsEqualIID(riid, &IID_IAudioSessionControl2))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioSessionControl_AddRef(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionControl_Release(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    if(!ref){
+        if(This->client){
+            EnterCriticalSection(&g_sessions_lock);
+            This->client->session_wrapper = NULL;
+            LeaveCriticalSection(&g_sessions_lock);
+            AudioClient_Release(&This->client->IAudioClient3_iface);
+        }
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetState(IAudioSessionControl2 *iface,
+        AudioSessionState *state)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    struct is_started_params params;
+    ACImpl *client;
+
+    TRACE("(%p)->(%p)\n", This, state);
+
+    if(!state)
+        return NULL_PTR_ERR;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(list_empty(&This->session->clients)){
+        *state = AudioSessionStateExpired;
+        LeaveCriticalSection(&g_sessions_lock);
+        return S_OK;
+    }
+
+    LIST_FOR_EACH_ENTRY(client, &This->session->clients, ACImpl, entry){
+        params.stream = client->stream;
+        ALSA_CALL(is_started, &params);
+        if(params.result == S_OK){
+            *state = AudioSessionStateActive;
+            LeaveCriticalSection(&g_sessions_lock);
+            return S_OK;
+        }
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    *state = AudioSessionStateInactive;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetDisplayName(
+        IAudioSessionControl2 *iface, WCHAR **name)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, name);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDisplayName(
+        IAudioSessionControl2 *iface, const WCHAR *name, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, name, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetIconPath(
+        IAudioSessionControl2 *iface, WCHAR **path)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, path);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetIconPath(
+        IAudioSessionControl2 *iface, const WCHAR *path, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, path, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetGroupingParam(
+        IAudioSessionControl2 *iface, GUID *group)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, group);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetGroupingParam(
+        IAudioSessionControl2 *iface, const GUID *group, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%s, %s) - stub\n", This, debugstr_guid(group),
+            debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_RegisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_UnregisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionInstanceIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetProcessId(
+        IAudioSessionControl2 *iface, DWORD *pid)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%p)\n", This, pid);
+
+    if(!pid)
+        return E_POINTER;
+
+    *pid = GetCurrentProcessId();
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_IsSystemSoundsSession(
+        IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)\n", This);
+
+    return S_FALSE;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDuckingPreference(
+        IAudioSessionControl2 *iface, BOOL optout)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%d)\n", This, optout);
+
+    return S_OK;
+}
+
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl =
+{
+    AudioSessionControl_QueryInterface,
+    AudioSessionControl_AddRef,
+    AudioSessionControl_Release,
+    AudioSessionControl_GetState,
+    AudioSessionControl_GetDisplayName,
+    AudioSessionControl_SetDisplayName,
+    AudioSessionControl_GetIconPath,
+    AudioSessionControl_SetIconPath,
+    AudioSessionControl_GetGroupingParam,
+    AudioSessionControl_SetGroupingParam,
+    AudioSessionControl_RegisterAudioSessionNotification,
+    AudioSessionControl_UnregisterAudioSessionNotification,
+    AudioSessionControl_GetSessionIdentifier,
+    AudioSessionControl_GetSessionInstanceIdentifier,
+    AudioSessionControl_GetProcessId,
+    AudioSessionControl_IsSystemSoundsSession,
+    AudioSessionControl_SetDuckingPreference
+};
+
+static HRESULT WINAPI SimpleAudioVolume_QueryInterface(
+        ISimpleAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_ISimpleAudioVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI SimpleAudioVolume_AddRef(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI SimpleAudioVolume_Release(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMasterVolume(
+        ISimpleAudioVolume *iface, float level, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+    ACImpl *client;
+
+    TRACE("(%p)->(%f, %s)\n", session, level, wine_dbgstr_guid(context));
+
+    if(level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    TRACE("ALSA does not support volume control\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    session->master_vol = level;
+
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMasterVolume(
+        ISimpleAudioVolume *iface, float *level)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, level);
+
+    if(!level)
+        return NULL_PTR_ERR;
+
+    *level = session->master_vol;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMute(ISimpleAudioVolume *iface,
+        BOOL mute, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+    ACImpl *client;
+
+    TRACE("(%p)->(%u, %s)\n", session, mute, debugstr_guid(context));
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    session->mute = mute;
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMute(ISimpleAudioVolume *iface,
+        BOOL *mute)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, mute);
+
+    if(!mute)
+        return NULL_PTR_ERR;
+
+    *mute = session->mute;
+
+    return S_OK;
+}
+
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl  =
+{
+    SimpleAudioVolume_QueryInterface,
+    SimpleAudioVolume_AddRef,
+    SimpleAudioVolume_Release,
+    SimpleAudioVolume_SetMasterVolume,
+    SimpleAudioVolume_GetMasterVolume,
+    SimpleAudioVolume_SetMute,
+    SimpleAudioVolume_GetMute
+};
+
+static HRESULT WINAPI AudioStreamVolume_QueryInterface(
+        IAudioStreamVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioStreamVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioStreamVolume_AddRef(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioStreamVolume_Release(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelCount(
+        IAudioStreamVolume *iface, UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if(!out)
+        return E_POINTER;
+
+    *out = This->channel_count;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_SetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%d, %f)\n", This, index, level);
+
+    if(level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if(index >= This->channel_count)
+        return E_INVALIDARG;
+
+    TRACE("ALSA does not support volume control\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    This->vols[index] = level;
+    set_stream_volumes(This);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float *level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%d, %p)\n", This, index, level);
+
+    if(!level)
+        return E_POINTER;
+
+    if(index >= This->channel_count)
+        return E_INVALIDARG;
+
+    *level = This->vols[index];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_SetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, const float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    unsigned int i;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if(!levels)
+        return E_POINTER;
+
+    if(count != This->channel_count)
+        return E_INVALIDARG;
+
+    TRACE("ALSA does not support volume control\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    for(i = 0; i < count; ++i)
+        This->vols[i] = levels[i];
+    set_stream_volumes(This);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    unsigned int i;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if(!levels)
+        return E_POINTER;
+
+    if(count != This->channel_count)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    for(i = 0; i < count; ++i)
+        levels[i] = This->vols[i];
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl =
+{
+    AudioStreamVolume_QueryInterface,
+    AudioStreamVolume_AddRef,
+    AudioStreamVolume_Release,
+    AudioStreamVolume_GetChannelCount,
+    AudioStreamVolume_SetChannelVolume,
+    AudioStreamVolume_GetChannelVolume,
+    AudioStreamVolume_SetAllVolumes,
+    AudioStreamVolume_GetAllVolumes
+};
+
+static HRESULT WINAPI ChannelAudioVolume_QueryInterface(
+        IChannelAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IChannelAudioVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI ChannelAudioVolume_AddRef(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI ChannelAudioVolume_Release(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelCount(
+        IChannelAudioVolume *iface, UINT32 *out)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, out);
+
+    if(!out)
+        return NULL_PTR_ERR;
+
+    *out = session->channel_count;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float level,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    ACImpl *client;
+
+    TRACE("(%p)->(%d, %f, %s)\n", session, index, level,
+            wine_dbgstr_guid(context));
+
+    if(level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if(index >= session->channel_count)
+        return E_INVALIDARG;
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    TRACE("ALSA does not support volume control\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    session->channel_vols[index] = level;
+
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float *level)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%d, %p)\n", session, index, level);
+
+    if(!level)
+        return NULL_PTR_ERR;
+
+    if(index >= session->channel_count)
+        return E_INVALIDARG;
+
+    *level = session->channel_vols[index];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, const float *levels,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    unsigned int i;
+    ACImpl *client;
+
+    TRACE("(%p)->(%d, %p, %s)\n", session, count, levels,
+            wine_dbgstr_guid(context));
+
+    if(!levels)
+        return NULL_PTR_ERR;
+
+    if(count != session->channel_count)
+        return E_INVALIDARG;
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    TRACE("ALSA does not support volume control\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    for(i = 0; i < count; ++i)
+        session->channel_vols[i] = levels[i];
+
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, float *levels)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    unsigned int i;
+
+    TRACE("(%p)->(%d, %p)\n", session, count, levels);
+
+    if(!levels)
+        return NULL_PTR_ERR;
+
+    if(count != session->channel_count)
+        return E_INVALIDARG;
+
+    for(i = 0; i < count; ++i)
+        levels[i] = session->channel_vols[i];
+
+    return S_OK;
+}
+
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl =
+{
+    ChannelAudioVolume_QueryInterface,
+    ChannelAudioVolume_AddRef,
+    ChannelAudioVolume_Release,
+    ChannelAudioVolume_GetChannelCount,
+    ChannelAudioVolume_SetChannelVolume,
+    ChannelAudioVolume_GetChannelVolume,
+    ChannelAudioVolume_SetAllVolumes,
+    ChannelAudioVolume_GetAllVolumes
+};
+
+static HRESULT WINAPI AudioSessionManager_QueryInterface(IAudioSessionManager2 *iface,
+        REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioSessionManager) ||
+            IsEqualIID(riid, &IID_IAudioSessionManager2))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioSessionManager_AddRef(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionManager_Release(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    if(!ref)
+        HeapFree(GetProcessHeap(), 0, This);
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetAudioSessionControl(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        IAudioSessionControl **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %lx, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if(FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if(!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = (IAudioSessionControl*)&wrapper->IAudioSessionControl2_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSimpleAudioVolume(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        ISimpleAudioVolume **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %lx, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if(FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if(!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = &wrapper->ISimpleAudioVolume_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSessionEnumerator(
+        IAudioSessionManager2 *iface, IAudioSessionEnumerator **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, out);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterDuckNotification(
+        IAudioSessionManager2 *iface, const WCHAR *session_id,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterDuckNotification(
+        IAudioSessionManager2 *iface,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static const IAudioSessionManager2Vtbl AudioSessionManager2_Vtbl =
+{
+    AudioSessionManager_QueryInterface,
+    AudioSessionManager_AddRef,
+    AudioSessionManager_Release,
+    AudioSessionManager_GetAudioSessionControl,
+    AudioSessionManager_GetSimpleAudioVolume,
+    AudioSessionManager_GetSessionEnumerator,
+    AudioSessionManager_RegisterSessionNotification,
+    AudioSessionManager_UnregisterSessionNotification,
+    AudioSessionManager_RegisterDuckNotification,
+    AudioSessionManager_UnregisterDuckNotification
+};
+
+HRESULT WINAPI AUDDRV_GetAudioSessionManager(IMMDevice *device,
+        IAudioSessionManager2 **out)
+{
+    SessionMgr *This;
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(SessionMgr));
+    if(!This)
+        return E_OUTOFMEMORY;
+
+    This->IAudioSessionManager2_iface.lpVtbl = &AudioSessionManager2_Vtbl;
+    This->device = device;
+    This->ref = 1;
+
+    *out = &This->IAudioSessionManager2_iface;
+
+    return S_OK;
+}
+
+HRESULT WINAPI AUDDRV_GetPropValue(GUID *guid, const PROPERTYKEY *prop, PROPVARIANT *out)
+{
+    struct get_prop_value_params params;
+    char name[256];
+    EDataFlow flow;
+    unsigned int size = 0;
+
+    TRACE("%s, (%s,%lu), %p\n", wine_dbgstr_guid(guid), wine_dbgstr_guid(&prop->fmtid), prop->pid, out);
+
+    if(!get_alsa_name_by_guid(guid, name, sizeof(name), &flow))
+    {
+        WARN("Unknown interface %s\n", debugstr_guid(guid));
+        return E_NOINTERFACE;
+    }
+
+    params.device = name;
+    params.flow = flow;
+    params.guid = guid;
+    params.prop = prop;
+    params.value = out;
+    params.buffer = NULL;
+    params.buffer_size = &size;
+
+    while(1) {
+        ALSA_CALL(get_prop_value, &params);
+
+        if(params.result != E_NOT_SUFFICIENT_BUFFER)
+            break;
+
+        CoTaskMemFree(params.buffer);
+        params.buffer = CoTaskMemAlloc(*params.buffer_size);
+        if(!params.buffer)
+            return E_OUTOFMEMORY;
+    }
+    if(FAILED(params.result))
+        CoTaskMemFree(params.buffer);
+
+    return params.result;
+}
diff --git a/dlls/winealsa.drv/mmdevdrv.c.orig b/dlls/winealsa.drv/mmdevdrv.c.orig
new file mode 100644
index 11111111111..11111111111
--- /dev/null
+++ b/dlls/winealsa.drv/mmdevdrv.c.orig
@@ -0,0 +1,2475 @@
+/*
+ * Copyright 2010 Maarten Lankhorst for CodeWeavers
+ * Copyright 2011 Andrew Eikum for CodeWeavers
+ * Copyright 2022 Huw Davies
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winnls.h"
+#include "winreg.h"
+#include "winternl.h"
+#include "propsys.h"
+#include "propkey.h"
+#include "initguid.h"
+#include "ole2.h"
+#include "mmdeviceapi.h"
+#include "devpkey.h"
+#include "mmsystem.h"
+#include "dsound.h"
+
+#include "endpointvolume.h"
+#include "audioclient.h"
+#include "audiopolicy.h"
+
+#include "wine/debug.h"
+#include "wine/list.h"
+#include "wine/unixlib.h"
+
+#include "unixlib.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(alsa);
+
+#define NULL_PTR_ERR MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER)
+
+static const REFERENCE_TIME DefaultPeriod = 100000;
+static const REFERENCE_TIME MinimumPeriod = 50000;
+
+struct ACImpl;
+typedef struct ACImpl ACImpl;
+
+typedef struct _AudioSession {
+    GUID guid;
+    struct list clients;
+
+    IMMDevice *device;
+
+    float master_vol;
+    UINT32 channel_count;
+    float *channel_vols;
+    BOOL mute;
+
+    struct list entry;
+} AudioSession;
+
+typedef struct _AudioSessionWrapper {
+    IAudioSessionControl2 IAudioSessionControl2_iface;
+    IChannelAudioVolume IChannelAudioVolume_iface;
+    ISimpleAudioVolume ISimpleAudioVolume_iface;
+
+    LONG ref;
+
+    ACImpl *client;
+    AudioSession *session;
+} AudioSessionWrapper;
+
+struct ACImpl {
+    IAudioClient3 IAudioClient3_iface;
+    IAudioRenderClient IAudioRenderClient_iface;
+    IAudioCaptureClient IAudioCaptureClient_iface;
+    IAudioClock IAudioClock_iface;
+    IAudioClock2 IAudioClock2_iface;
+    IAudioStreamVolume IAudioStreamVolume_iface;
+
+    LONG ref;
+
+    IMMDevice *parent;
+    IUnknown *pUnkFTMarshal;
+
+    EDataFlow dataflow;
+    float *vols;
+    UINT32 channel_count;
+    stream_handle stream;
+
+    HANDLE timer_thread;
+
+    AudioSession *session;
+    AudioSessionWrapper *session_wrapper;
+
+    struct list entry;
+
+    /* Keep at end */
+    char alsa_name[1];
+};
+
+typedef struct _SessionMgr {
+    IAudioSessionManager2 IAudioSessionManager2_iface;
+
+    LONG ref;
+
+    IMMDevice *device;
+} SessionMgr;
+
+static CRITICAL_SECTION g_sessions_lock;
+static CRITICAL_SECTION_DEBUG g_sessions_lock_debug =
+{
+    0, 0, &g_sessions_lock,
+    { &g_sessions_lock_debug.ProcessLocksList, &g_sessions_lock_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": g_sessions_lock") }
+};
+static CRITICAL_SECTION g_sessions_lock = { &g_sessions_lock_debug, -1, 0, 0, 0, 0 };
+static struct list g_sessions = LIST_INIT(g_sessions);
+
+static const WCHAR drv_key_devicesW[] = {'S','o','f','t','w','a','r','e','\\',
+    'W','i','n','e','\\','D','r','i','v','e','r','s','\\',
+    'w','i','n','e','a','l','s','a','.','d','r','v','\\','d','e','v','i','c','e','s',0};
+static const WCHAR guidW[] = {'g','u','i','d',0};
+
+static const IAudioClient3Vtbl AudioClient3_Vtbl;
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl;
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl;
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl;
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl;
+static const IAudioClockVtbl AudioClock_Vtbl;
+static const IAudioClock2Vtbl AudioClock2_Vtbl;
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl;
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl;
+static const IAudioSessionManager2Vtbl AudioSessionManager2_Vtbl;
+
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client);
+
+static inline ACImpl *impl_from_IAudioClient3(IAudioClient3 *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClient3_iface);
+}
+
+static inline ACImpl *impl_from_IAudioRenderClient(IAudioRenderClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioRenderClient_iface);
+}
+
+static inline ACImpl *impl_from_IAudioCaptureClient(IAudioCaptureClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioCaptureClient_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IAudioSessionControl2(IAudioSessionControl2 *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IAudioSessionControl2_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_ISimpleAudioVolume(ISimpleAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, ISimpleAudioVolume_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IChannelAudioVolume(IChannelAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IChannelAudioVolume_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock(IAudioClock *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock2(IAudioClock2 *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock2_iface);
+}
+
+static inline ACImpl *impl_from_IAudioStreamVolume(IAudioStreamVolume *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioStreamVolume_iface);
+}
+
+static inline SessionMgr *impl_from_IAudioSessionManager2(IAudioSessionManager2 *iface)
+{
+    return CONTAINING_RECORD(iface, SessionMgr, IAudioSessionManager2_iface);
+}
+
+BOOL WINAPI DllMain(HINSTANCE dll, DWORD reason, void *reserved)
+{
+    switch (reason)
+    {
+    case DLL_PROCESS_ATTACH:
+        if(__wine_init_unix_call()) return FALSE;
+        break;
+
+    case DLL_PROCESS_DETACH:
+        if (reserved) break;
+        DeleteCriticalSection(&g_sessions_lock);
+        break;
+    }
+    return TRUE;
+}
+
+int WINAPI AUDDRV_GetPriority(void)
+{
+    return Priority_Neutral;
+}
+
+static HRESULT alsa_stream_release(stream_handle stream, HANDLE timer_thread)
+{
+    struct release_stream_params params;
+
+    params.stream = stream;
+    params.timer_thread = timer_thread;
+
+    ALSA_CALL(release_stream, &params);
+
+    return params.result;
+}
+
+static DWORD WINAPI alsa_timer_thread(void *user)
+{
+    struct timer_loop_params params;
+    struct ACImpl *This = user;
+
+    SetThreadDescription(GetCurrentThread(), L"winealsa_timer");
+
+    params.stream = This->stream;
+
+    ALSA_CALL(timer_loop, &params);
+
+    return 0;
+}
+
+static void set_device_guid(EDataFlow flow, HKEY drv_key, const WCHAR *key_name,
+        GUID *guid)
+{
+    HKEY key;
+    BOOL opened = FALSE;
+    LONG lr;
+
+    if(!drv_key){
+        lr = RegCreateKeyExW(HKEY_CURRENT_USER, drv_key_devicesW, 0, NULL, 0, KEY_WRITE,
+                    NULL, &drv_key, NULL);
+        if(lr != ERROR_SUCCESS){
+            ERR("RegCreateKeyEx(drv_key) failed: %lu\n", lr);
+            return;
+        }
+        opened = TRUE;
+    }
+
+    lr = RegCreateKeyExW(drv_key, key_name, 0, NULL, 0, KEY_WRITE,
+                NULL, &key, NULL);
+    if(lr != ERROR_SUCCESS){
+        ERR("RegCreateKeyEx(%s) failed: %lu\n", wine_dbgstr_w(key_name), lr);
+        goto exit;
+    }
+
+    lr = RegSetValueExW(key, guidW, 0, REG_BINARY, (BYTE*)guid,
+                sizeof(GUID));
+    if(lr != ERROR_SUCCESS)
+        ERR("RegSetValueEx(%s\\guid) failed: %lu\n", wine_dbgstr_w(key_name), lr);
+
+    RegCloseKey(key);
+exit:
+    if(opened)
+        RegCloseKey(drv_key);
+}
+
+static void get_device_guid(EDataFlow flow, const char *device, GUID *guid)
+{
+    HKEY key = NULL, dev_key;
+    DWORD type, size = sizeof(*guid);
+    WCHAR key_name[256];
+
+    if(flow == eCapture)
+        key_name[0] = '1';
+    else
+        key_name[0] = '0';
+    key_name[1] = ',';
+    MultiByteToWideChar(CP_UNIXCP, 0, device, -1, key_name + 2, ARRAY_SIZE(key_name) - 2);
+
+    if(RegOpenKeyExW(HKEY_CURRENT_USER, drv_key_devicesW, 0, KEY_WRITE|KEY_READ, &key) == ERROR_SUCCESS){
+        if(RegOpenKeyExW(key, key_name, 0, KEY_READ, &dev_key) == ERROR_SUCCESS){
+            if(RegQueryValueExW(dev_key, guidW, 0, &type,
+                        (BYTE*)guid, &size) == ERROR_SUCCESS){
+                if(type == REG_BINARY){
+                    RegCloseKey(dev_key);
+                    RegCloseKey(key);
+                    return;
+                }
+                ERR("Invalid type for device %s GUID: %lu; ignoring and overwriting\n",
+                        wine_dbgstr_w(key_name), type);
+            }
+            RegCloseKey(dev_key);
+        }
+    }
+
+    CoCreateGuid(guid);
+
+    set_device_guid(flow, key, key_name, guid);
+
+    if(key)
+        RegCloseKey(key);
+}
+
+static void set_stream_volumes(ACImpl *This)
+{
+    struct set_volumes_params params;
+
+    params.stream = This->stream;
+    params.master_volume = (This->session->mute ? 0.0f : This->session->master_vol);
+    params.volumes = This->vols;
+    params.session_volumes = This->session->channel_vols;
+    params.channel = 0;
+
+    ALSA_CALL(set_volumes, &params);
+}
+
+HRESULT WINAPI AUDDRV_GetEndpointIDs(EDataFlow flow, WCHAR ***ids_out, GUID **guids_out,
+        UINT *num, UINT *def_index)
+{
+    struct get_endpoint_ids_params params;
+    unsigned int i;
+    GUID *guids = NULL;
+    WCHAR **ids = NULL;
+
+    TRACE("%d %p %p %p %p\n", flow, ids, guids, num, def_index);
+
+    params.flow = flow;
+    params.size = 1000;
+    params.endpoints = NULL;
+    do{
+        HeapFree(GetProcessHeap(), 0, params.endpoints);
+        params.endpoints = HeapAlloc(GetProcessHeap(), 0, params.size);
+        ALSA_CALL(get_endpoint_ids, &params);
+    }while(params.result == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
+
+    if(FAILED(params.result)) goto end;
+
+    ids = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, params.num * sizeof(*ids));
+    guids = HeapAlloc(GetProcessHeap(), 0, params.num * sizeof(*guids));
+    if(!ids || !guids){
+        params.result = E_OUTOFMEMORY;
+        goto end;
+    }
+
+    for(i = 0; i < params.num; i++){
+        WCHAR *name = (WCHAR *)((char *)params.endpoints + params.endpoints[i].name);
+        char *device = (char *)params.endpoints + params.endpoints[i].device;
+        unsigned int size = (wcslen(name) + 1) * sizeof(WCHAR);
+
+        ids[i] = HeapAlloc(GetProcessHeap(), 0, size);
+        if(!ids[i]){
+            params.result = E_OUTOFMEMORY;
+            goto end;
+        }
+        memcpy(ids[i], name, size);
+        get_device_guid(flow, device, guids + i);
+    }
+    *def_index = params.default_idx;
+
+end:
+    HeapFree(GetProcessHeap(), 0, params.endpoints);
+    if(FAILED(params.result)){
+        HeapFree(GetProcessHeap(), 0, guids);
+        if(ids){
+            for(i = 0; i < params.num; i++)
+                HeapFree(GetProcessHeap(), 0, ids[i]);
+            HeapFree(GetProcessHeap(), 0, ids);
+        }
+    }else{
+        *ids_out = ids;
+        *guids_out = guids;
+        *num = params.num;
+    }
+
+    return params.result;
+}
+
+static BOOL get_alsa_name_by_guid(GUID *guid, char *name, DWORD name_size, EDataFlow *flow)
+{
+    HKEY devices_key;
+    UINT i = 0;
+    WCHAR key_name[256];
+    DWORD key_name_size;
+
+    if(RegOpenKeyExW(HKEY_CURRENT_USER, drv_key_devicesW, 0, KEY_READ, &devices_key) != ERROR_SUCCESS){
+        ERR("No devices found in registry?\n");
+        return FALSE;
+    }
+
+    while(1){
+        HKEY key;
+        DWORD size, type;
+        GUID reg_guid;
+
+        key_name_size = ARRAY_SIZE(key_name);
+        if(RegEnumKeyExW(devices_key, i++, key_name, &key_name_size, NULL,
+                NULL, NULL, NULL) != ERROR_SUCCESS)
+            break;
+
+        if(RegOpenKeyExW(devices_key, key_name, 0, KEY_READ, &key) != ERROR_SUCCESS){
+            WARN("Couldn't open key: %s\n", wine_dbgstr_w(key_name));
+            continue;
+        }
+
+        size = sizeof(reg_guid);
+        if(RegQueryValueExW(key, guidW, 0, &type,
+                    (BYTE*)&reg_guid, &size) == ERROR_SUCCESS){
+            if(IsEqualGUID(&reg_guid, guid)){
+                RegCloseKey(key);
+                RegCloseKey(devices_key);
+
+                TRACE("Found matching device key: %s\n", wine_dbgstr_w(key_name));
+
+                if(key_name[0] == '0')
+                    *flow = eRender;
+                else if(key_name[0] == '1')
+                    *flow = eCapture;
+                else{
+                    ERR("Unknown device type: %c\n", key_name[0]);
+                    return FALSE;
+                }
+
+                WideCharToMultiByte(CP_UNIXCP, 0, key_name + 2, -1, name, name_size, NULL, NULL);
+
+                return TRUE;
+            }
+        }
+
+        RegCloseKey(key);
+    }
+
+    RegCloseKey(devices_key);
+
+    WARN("No matching device in registry for GUID %s\n", debugstr_guid(guid));
+
+    return FALSE;
+}
+
+HRESULT WINAPI AUDDRV_GetAudioEndpoint(GUID *guid, IMMDevice *dev, IAudioClient **out)
+{
+    ACImpl *This;
+    char alsa_name[256];
+    EDataFlow dataflow;
+    HRESULT hr;
+    int len;
+
+    TRACE("%s %p %p\n", debugstr_guid(guid), dev, out);
+
+    if(!get_alsa_name_by_guid(guid, alsa_name, sizeof(alsa_name), &dataflow))
+        return AUDCLNT_E_DEVICE_INVALIDATED;
+
+    if(dataflow != eRender && dataflow != eCapture)
+        return E_UNEXPECTED;
+
+    len = strlen(alsa_name);
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, offsetof(ACImpl, alsa_name[len + 1]));
+    if(!This)
+        return E_OUTOFMEMORY;
+
+    This->IAudioClient3_iface.lpVtbl = &AudioClient3_Vtbl;
+    This->IAudioRenderClient_iface.lpVtbl = &AudioRenderClient_Vtbl;
+    This->IAudioCaptureClient_iface.lpVtbl = &AudioCaptureClient_Vtbl;
+    This->IAudioClock_iface.lpVtbl = &AudioClock_Vtbl;
+    This->IAudioClock2_iface.lpVtbl = &AudioClock2_Vtbl;
+    This->IAudioStreamVolume_iface.lpVtbl = &AudioStreamVolume_Vtbl;
+
+    hr = CoCreateFreeThreadedMarshaler((IUnknown *)&This->IAudioClient3_iface, &This->pUnkFTMarshal);
+    if (FAILED(hr)) {
+        HeapFree(GetProcessHeap(), 0, This);
+        return hr;
+    }
+
+    This->dataflow = dataflow;
+    memcpy(This->alsa_name, alsa_name, len + 1);
+
+    This->parent = dev;
+    IMMDevice_AddRef(This->parent);
+
+    *out = (IAudioClient *)&This->IAudioClient3_iface;
+    IAudioClient3_AddRef(&This->IAudioClient3_iface);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_QueryInterface(IAudioClient3 *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioClient) ||
+            IsEqualIID(riid, &IID_IAudioClient2) ||
+            IsEqualIID(riid, &IID_IAudioClient3))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->pUnkFTMarshal, riid, ppv);
+
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClient_AddRef(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioClient_Release(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    ULONG ref;
+
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    if(!ref){
+        IAudioClient3_Stop(iface);
+        IMMDevice_Release(This->parent);
+        IUnknown_Release(This->pUnkFTMarshal);
+        if(This->session){
+            EnterCriticalSection(&g_sessions_lock);
+            list_remove(&This->entry);
+            LeaveCriticalSection(&g_sessions_lock);
+        }
+        HeapFree(GetProcessHeap(), 0, This->vols);
+        if (This->stream)
+            alsa_stream_release(This->stream, This->timer_thread);
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static void dump_fmt(const WAVEFORMATEX *fmt)
+{
+    TRACE("wFormatTag: 0x%x (", fmt->wFormatTag);
+    switch(fmt->wFormatTag){
+    case WAVE_FORMAT_PCM:
+        TRACE("WAVE_FORMAT_PCM");
+        break;
+    case WAVE_FORMAT_IEEE_FLOAT:
+        TRACE("WAVE_FORMAT_IEEE_FLOAT");
+        break;
+    case WAVE_FORMAT_EXTENSIBLE:
+        TRACE("WAVE_FORMAT_EXTENSIBLE");
+        break;
+    default:
+        TRACE("Unknown");
+        break;
+    }
+    TRACE(")\n");
+
+    TRACE("nChannels: %u\n", fmt->nChannels);
+    TRACE("nSamplesPerSec: %lu\n", fmt->nSamplesPerSec);
+    TRACE("nAvgBytesPerSec: %lu\n", fmt->nAvgBytesPerSec);
+    TRACE("nBlockAlign: %u\n", fmt->nBlockAlign);
+    TRACE("wBitsPerSample: %u\n", fmt->wBitsPerSample);
+    TRACE("cbSize: %u\n", fmt->cbSize);
+
+    if(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE){
+        WAVEFORMATEXTENSIBLE *fmtex = (void*)fmt;
+        TRACE("dwChannelMask: %08lx\n", fmtex->dwChannelMask);
+        TRACE("Samples: %04x\n", fmtex->Samples.wReserved);
+        TRACE("SubFormat: %s\n", wine_dbgstr_guid(&fmtex->SubFormat));
+    }
+}
+
+static void session_init_vols(AudioSession *session, UINT channels)
+{
+    if(session->channel_count < channels){
+        UINT i;
+
+        if(session->channel_vols)
+            session->channel_vols = HeapReAlloc(GetProcessHeap(), 0,
+                    session->channel_vols, sizeof(float) * channels);
+        else
+            session->channel_vols = HeapAlloc(GetProcessHeap(), 0,
+                    sizeof(float) * channels);
+        if(!session->channel_vols)
+            return;
+
+        for(i = session->channel_count; i < channels; ++i)
+            session->channel_vols[i] = 1.f;
+
+        session->channel_count = channels;
+    }
+}
+
+static AudioSession *create_session(const GUID *guid, IMMDevice *device,
+        UINT num_channels)
+{
+    AudioSession *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(AudioSession));
+    if(!ret)
+        return NULL;
+
+    memcpy(&ret->guid, guid, sizeof(GUID));
+
+    ret->device = device;
+
+    list_init(&ret->clients);
+
+    list_add_head(&g_sessions, &ret->entry);
+
+    session_init_vols(ret, num_channels);
+
+    ret->master_vol = 1.f;
+
+    return ret;
+}
+
+/* if channels == 0, then this will return or create a session with
+ * matching dataflow and GUID. otherwise, channels must also match */
+static HRESULT get_audio_session(const GUID *sessionguid,
+        IMMDevice *device, UINT channels, AudioSession **out)
+{
+    AudioSession *session;
+
+    if(!sessionguid || IsEqualGUID(sessionguid, &GUID_NULL)){
+        *out = create_session(&GUID_NULL, device, channels);
+        if(!*out)
+            return E_OUTOFMEMORY;
+
+        return S_OK;
+    }
+
+    *out = NULL;
+    LIST_FOR_EACH_ENTRY(session, &g_sessions, AudioSession, entry){
+        if(session->device == device &&
+                IsEqualGUID(sessionguid, &session->guid)){
+            session_init_vols(session, channels);
+            *out = session;
+            break;
+        }
+    }
+
+    if(!*out){
+        *out = create_session(sessionguid, device, channels);
+        if(!*out)
+            return E_OUTOFMEMORY;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Initialize(IAudioClient3 *iface,
+        AUDCLNT_SHAREMODE mode, DWORD flags, REFERENCE_TIME duration,
+        REFERENCE_TIME period, const WAVEFORMATEX *fmt,
+        const GUID *sessionguid)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct create_stream_params params;
+    stream_handle stream;
+    unsigned int i;
+
+    TRACE("(%p)->(%x, %lx, %s, %s, %p, %s)\n", This, mode, flags,
+          wine_dbgstr_longlong(duration), wine_dbgstr_longlong(period), fmt, debugstr_guid(sessionguid));
+
+    if(!fmt)
+        return E_POINTER;
+
+    if(mode != AUDCLNT_SHAREMODE_SHARED && mode != AUDCLNT_SHAREMODE_EXCLUSIVE)
+        return E_INVALIDARG;
+
+    if(flags & ~(AUDCLNT_STREAMFLAGS_CROSSPROCESS |
+                AUDCLNT_STREAMFLAGS_LOOPBACK |
+                AUDCLNT_STREAMFLAGS_EVENTCALLBACK |
+                AUDCLNT_STREAMFLAGS_NOPERSIST |
+                AUDCLNT_STREAMFLAGS_RATEADJUST |
+                AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED |
+                AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY |
+                AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM)){
+        FIXME("Unknown flags: %08lx\n", flags);
+        return E_INVALIDARG;
+    }
+
+    if(mode == AUDCLNT_SHAREMODE_SHARED){
+        period = DefaultPeriod;
+        if( duration < 3 * period)
+            duration = 3 * period;
+    }else{
+        if(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE){
+            if(((WAVEFORMATEXTENSIBLE*)fmt)->dwChannelMask == 0 ||
+                    ((WAVEFORMATEXTENSIBLE*)fmt)->dwChannelMask & SPEAKER_RESERVED)
+                return AUDCLNT_E_UNSUPPORTED_FORMAT;
+        }
+
+        if(!period)
+            period = DefaultPeriod; /* not minimum */
+        if(period < MinimumPeriod || period > 5000000)
+            return AUDCLNT_E_INVALID_DEVICE_PERIOD;
+        if(duration > 20000000) /* the smaller the period, the lower this limit */
+            return AUDCLNT_E_BUFFER_SIZE_ERROR;
+        if(flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK){
+            if(duration != period)
+                return AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
+            FIXME("EXCLUSIVE mode with EVENTCALLBACK\n");
+            return AUDCLNT_E_DEVICE_IN_USE;
+        }else{
+            if( duration < 8 * period)
+                duration = 8 * period; /* may grow above 2s */
+        }
+    }
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(This->stream){
+        LeaveCriticalSection(&g_sessions_lock);
+        return AUDCLNT_E_ALREADY_INITIALIZED;
+    }
+
+    dump_fmt(fmt);
+
+    params.name = NULL;
+    params.device = This->alsa_name;
+    params.flow = This->dataflow;
+    params.share = mode;
+    params.flags = flags;
+    params.duration = duration;
+    params.period = period;
+    params.fmt = fmt;
+    params.channel_count = NULL;
+    params.stream = &stream;
+
+    ALSA_CALL(create_stream, &params);
+    if(FAILED(params.result)){
+        LeaveCriticalSection(&g_sessions_lock);
+        return params.result;
+    }
+
+    This->channel_count = fmt->nChannels;
+    This->vols = HeapAlloc(GetProcessHeap(), 0, This->channel_count * sizeof(float));
+    if(!This->vols){
+        params.result = E_OUTOFMEMORY;
+        goto exit;
+    }
+    for(i = 0; i < This->channel_count; ++i)
+        This->vols[i] = 1.f;
+
+    params.result = get_audio_session(sessionguid, This->parent, This->channel_count,
+                                      &This->session);
+    if(FAILED(params.result))
+        goto exit;
+
+    list_add_tail(&This->session->clients, &This->entry);
+
+exit:
+    if(FAILED(params.result)){
+        alsa_stream_release(stream, NULL);
+        HeapFree(GetProcessHeap(), 0, This->vols);
+        This->vols = NULL;
+    }else{
+        This->stream = stream;
+        set_stream_volumes(This);
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetBufferSize(IAudioClient3 *iface,
+        UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_buffer_size_params params;
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if(!out)
+        return E_POINTER;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    params.frames = out;
+
+    ALSA_CALL(get_buffer_size, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetStreamLatency(IAudioClient3 *iface,
+        REFERENCE_TIME *latency)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_latency_params params;
+
+    TRACE("(%p)->(%p)\n", This, latency);
+
+    if(!latency)
+        return E_POINTER;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    params.latency = latency;
+
+    ALSA_CALL(get_latency, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetCurrentPadding(IAudioClient3 *iface,
+        UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_current_padding_params params;
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if(!out)
+        return E_POINTER;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    params.padding = out;
+
+    ALSA_CALL(get_current_padding, &params);
+
+    TRACE("pad: %u\n", *out);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_IsFormatSupported(IAudioClient3 *iface,
+        AUDCLNT_SHAREMODE mode, const WAVEFORMATEX *fmt,
+        WAVEFORMATEX **out)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct is_format_supported_params params;
+
+    TRACE("(%p)->(%x, %p, %p)\n", This, mode, fmt, out);
+    if(fmt) dump_fmt(fmt);
+
+    params.device = This->alsa_name;
+    params.flow = This->dataflow;
+    params.share = mode;
+    params.fmt_in = fmt;
+    params.fmt_out = NULL;
+
+    if(out){
+        *out = NULL;
+        if(mode == AUDCLNT_SHAREMODE_SHARED)
+            params.fmt_out = CoTaskMemAlloc(sizeof(*params.fmt_out));
+    }
+    ALSA_CALL(is_format_supported, &params);
+
+    if(params.result == S_FALSE)
+        *out = &params.fmt_out->Format;
+    else
+        CoTaskMemFree(params.fmt_out);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetMixFormat(IAudioClient3 *iface,
+        WAVEFORMATEX **pwfx)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_mix_format_params params;
+
+    TRACE("(%p)->(%p)\n", This, pwfx);
+
+    if(!pwfx)
+        return E_POINTER;
+    *pwfx = NULL;
+
+    params.device = This->alsa_name;
+    params.flow = This->dataflow;
+    params.fmt = CoTaskMemAlloc(sizeof(WAVEFORMATEXTENSIBLE));
+    if(!params.fmt)
+        return E_OUTOFMEMORY;
+
+    ALSA_CALL(get_mix_format, &params);
+
+    if(SUCCEEDED(params.result)){
+        *pwfx = &params.fmt->Format;
+        dump_fmt(*pwfx);
+    } else
+        CoTaskMemFree(params.fmt);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetDevicePeriod(IAudioClient3 *iface,
+        REFERENCE_TIME *defperiod, REFERENCE_TIME *minperiod)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    TRACE("(%p)->(%p, %p)\n", This, defperiod, minperiod);
+
+    if(!defperiod && !minperiod)
+        return E_POINTER;
+
+    if(defperiod)
+        *defperiod = DefaultPeriod;
+    if(minperiod)
+        *minperiod = DefaultPeriod;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Start(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct start_params params;
+
+    TRACE("(%p)\n", This);
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(!This->stream){
+        LeaveCriticalSection(&g_sessions_lock);
+        return AUDCLNT_E_NOT_INITIALIZED;
+    }
+
+    params.stream = This->stream;
+
+    ALSA_CALL(start, &params);
+
+    if(SUCCEEDED(params.result) && !This->timer_thread){
+        This->timer_thread = CreateThread(NULL, 0, alsa_timer_thread, This, 0, NULL);
+        SetThreadPriority(This->timer_thread, THREAD_PRIORITY_TIME_CRITICAL);
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_Stop(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct stop_params params;
+
+    TRACE("(%p)\n", This);
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+
+    ALSA_CALL(stop, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_Reset(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct reset_params params;
+
+    TRACE("(%p)\n", This);
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+
+    ALSA_CALL(reset, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_SetEventHandle(IAudioClient3 *iface,
+        HANDLE event)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct set_event_handle_params params;
+
+    TRACE("(%p)->(%p)\n", This, event);
+
+    if(!event)
+        return E_INVALIDARG;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    params.event = event;
+
+    ALSA_CALL(set_event_handle, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetService(IAudioClient3 *iface, REFIID riid,
+        void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(!This->stream){
+        LeaveCriticalSection(&g_sessions_lock);
+        return AUDCLNT_E_NOT_INITIALIZED;
+    }
+
+    if(IsEqualIID(riid, &IID_IAudioRenderClient)){
+        if(This->dataflow != eRender){
+            LeaveCriticalSection(&g_sessions_lock);
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        }
+        IAudioRenderClient_AddRef(&This->IAudioRenderClient_iface);
+        *ppv = &This->IAudioRenderClient_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioCaptureClient)){
+        if(This->dataflow != eCapture){
+            LeaveCriticalSection(&g_sessions_lock);
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        }
+        IAudioCaptureClient_AddRef(&This->IAudioCaptureClient_iface);
+        *ppv = &This->IAudioCaptureClient_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioClock)){
+        IAudioClock_AddRef(&This->IAudioClock_iface);
+        *ppv = &This->IAudioClock_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioStreamVolume)){
+        IAudioStreamVolume_AddRef(&This->IAudioStreamVolume_iface);
+        *ppv = &This->IAudioStreamVolume_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioSessionControl)){
+        if(!This->session_wrapper){
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if(!This->session_wrapper){
+                LeaveCriticalSection(&g_sessions_lock);
+                return E_OUTOFMEMORY;
+            }
+        }else
+            IAudioSessionControl2_AddRef(&This->session_wrapper->IAudioSessionControl2_iface);
+
+        *ppv = &This->session_wrapper->IAudioSessionControl2_iface;
+    }else if(IsEqualIID(riid, &IID_IChannelAudioVolume)){
+        if(!This->session_wrapper){
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if(!This->session_wrapper){
+                LeaveCriticalSection(&g_sessions_lock);
+                return E_OUTOFMEMORY;
+            }
+        }else
+            IChannelAudioVolume_AddRef(&This->session_wrapper->IChannelAudioVolume_iface);
+
+        *ppv = &This->session_wrapper->IChannelAudioVolume_iface;
+    }else if(IsEqualIID(riid, &IID_ISimpleAudioVolume)){
+        if(!This->session_wrapper){
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if(!This->session_wrapper){
+                LeaveCriticalSection(&g_sessions_lock);
+                return E_OUTOFMEMORY;
+            }
+        }else
+            ISimpleAudioVolume_AddRef(&This->session_wrapper->ISimpleAudioVolume_iface);
+
+        *ppv = &This->session_wrapper->ISimpleAudioVolume_iface;
+    }
+
+    if(*ppv){
+        LeaveCriticalSection(&g_sessions_lock);
+        return S_OK;
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    FIXME("stub %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static HRESULT WINAPI AudioClient_IsOffloadCapable(IAudioClient3 *iface,
+        AUDIO_STREAM_CATEGORY category, BOOL *offload_capable)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    TRACE("(%p)->(0x%x, %p)\n", This, category, offload_capable);
+
+    if(!offload_capable)
+        return E_INVALIDARG;
+
+    *offload_capable = FALSE;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_SetClientProperties(IAudioClient3 *iface,
+        const AudioClientProperties *prop)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    const Win8AudioClientProperties *legacy_prop = (const Win8AudioClientProperties *)prop;
+
+    TRACE("(%p)->(%p)\n", This, prop);
+
+    if(!legacy_prop)
+        return E_POINTER;
+
+    if(legacy_prop->cbSize == sizeof(AudioClientProperties)){
+        TRACE("{ bIsOffload: %u, eCategory: 0x%x, Options: 0x%x }\n",
+                legacy_prop->bIsOffload,
+                legacy_prop->eCategory,
+                prop->Options);
+    }else if(legacy_prop->cbSize == sizeof(Win8AudioClientProperties)){
+        TRACE("{ bIsOffload: %u, eCategory: 0x%x }\n",
+                legacy_prop->bIsOffload,
+                legacy_prop->eCategory);
+    }else{
+        WARN("Unsupported Size = %d\n", legacy_prop->cbSize);
+        return E_INVALIDARG;
+    }
+
+
+    if(legacy_prop->bIsOffload)
+        return AUDCLNT_E_ENDPOINT_OFFLOAD_NOT_CAPABLE;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_GetBufferSizeLimits(IAudioClient3 *iface,
+        const WAVEFORMATEX *format, BOOL event_driven, REFERENCE_TIME *min_duration,
+        REFERENCE_TIME *max_duration)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(%p, %u, %p, %p)\n", This, format, event_driven, min_duration, max_duration);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioClient_GetSharedModeEnginePeriod(IAudioClient3 *iface,
+        const WAVEFORMATEX *format, UINT32 *default_period_frames, UINT32 *unit_period_frames,
+        UINT32 *min_period_frames, UINT32 *max_period_frames)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(%p, %p, %p, %p, %p)\n", This, format, default_period_frames, unit_period_frames,
+            min_period_frames, max_period_frames);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioClient_GetCurrentSharedModeEnginePeriod(IAudioClient3 *iface,
+        WAVEFORMATEX **cur_format, UINT32 *cur_period_frames)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(%p, %p)\n", This, cur_format, cur_period_frames);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioClient_InitializeSharedAudioStream(IAudioClient3 *iface,
+        DWORD flags, UINT32 period_frames, const WAVEFORMATEX *format,
+        const GUID *session_guid)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(0x%lx, %u, %p, %s)\n", This, flags, period_frames, format, debugstr_guid(session_guid));
+
+    return E_NOTIMPL;
+}
+
+static const IAudioClient3Vtbl AudioClient3_Vtbl =
+{
+    AudioClient_QueryInterface,
+    AudioClient_AddRef,
+    AudioClient_Release,
+    AudioClient_Initialize,
+    AudioClient_GetBufferSize,
+    AudioClient_GetStreamLatency,
+    AudioClient_GetCurrentPadding,
+    AudioClient_IsFormatSupported,
+    AudioClient_GetMixFormat,
+    AudioClient_GetDevicePeriod,
+    AudioClient_Start,
+    AudioClient_Stop,
+    AudioClient_Reset,
+    AudioClient_SetEventHandle,
+    AudioClient_GetService,
+    AudioClient_IsOffloadCapable,
+    AudioClient_SetClientProperties,
+    AudioClient_GetBufferSizeLimits,
+    AudioClient_GetSharedModeEnginePeriod,
+    AudioClient_GetCurrentSharedModeEnginePeriod,
+    AudioClient_InitializeSharedAudioStream,
+};
+
+static HRESULT WINAPI AudioRenderClient_QueryInterface(
+        IAudioRenderClient *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioRenderClient))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->pUnkFTMarshal, riid, ppv);
+
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioRenderClient_AddRef(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioRenderClient_Release(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioRenderClient_GetBuffer(IAudioRenderClient *iface,
+        UINT32 frames, BYTE **data)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    struct get_render_buffer_params params;
+
+    TRACE("(%p)->(%u, %p)\n", This, frames, data);
+
+    if(!data)
+        return E_POINTER;
+    *data = NULL;
+
+    params.stream = This->stream;
+    params.frames = frames;
+    params.data = data;
+
+    ALSA_CALL(get_render_buffer, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioRenderClient_ReleaseBuffer(
+        IAudioRenderClient *iface, UINT32 written_frames, DWORD flags)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    struct release_render_buffer_params params;
+
+    TRACE("(%p)->(%u, %lx)\n", This, written_frames, flags);
+
+    params.stream = This->stream;
+    params.written_frames = written_frames;
+    params.flags = flags;
+
+    ALSA_CALL(release_render_buffer, &params);
+
+    return params.result;
+}
+
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl = {
+    AudioRenderClient_QueryInterface,
+    AudioRenderClient_AddRef,
+    AudioRenderClient_Release,
+    AudioRenderClient_GetBuffer,
+    AudioRenderClient_ReleaseBuffer
+};
+
+static HRESULT WINAPI AudioCaptureClient_QueryInterface(
+        IAudioCaptureClient *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioCaptureClient))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->pUnkFTMarshal, riid, ppv);
+
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioCaptureClient_AddRef(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioCaptureClient_Release(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetBuffer(IAudioCaptureClient *iface,
+        BYTE **data, UINT32 *frames, DWORD *flags, UINT64 *devpos,
+        UINT64 *qpcpos)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    struct get_capture_buffer_params params;
+
+    TRACE("(%p)->(%p, %p, %p, %p, %p)\n", This, data, frames, flags,
+            devpos, qpcpos);
+
+    if(!data)
+        return E_POINTER;
+
+    *data = NULL;
+
+    if(!frames || !flags)
+        return E_POINTER;
+
+    params.stream = This->stream;
+    params.data = data;
+    params.frames = frames;
+    params.flags = (UINT*)flags;
+    params.devpos = devpos;
+    params.qpcpos = qpcpos;
+
+    ALSA_CALL(get_capture_buffer, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioCaptureClient_ReleaseBuffer(
+        IAudioCaptureClient *iface, UINT32 done)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    struct release_capture_buffer_params params;
+
+    TRACE("(%p)->(%u)\n", This, done);
+
+    params.stream = This->stream;
+    params.done = done;
+
+    ALSA_CALL(release_capture_buffer, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetNextPacketSize(
+        IAudioCaptureClient *iface, UINT32 *frames)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    struct get_next_packet_size_params params;
+
+    TRACE("(%p)->(%p)\n", This, frames);
+
+    if(!frames)
+        return E_POINTER;
+
+    params.stream = This->stream;
+    params.frames = frames;
+
+    ALSA_CALL(get_next_packet_size, &params);
+
+    return params.result;
+}
+
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl =
+{
+    AudioCaptureClient_QueryInterface,
+    AudioCaptureClient_AddRef,
+    AudioCaptureClient_Release,
+    AudioCaptureClient_GetBuffer,
+    AudioCaptureClient_ReleaseBuffer,
+    AudioCaptureClient_GetNextPacketSize
+};
+
+static HRESULT WINAPI AudioClock_QueryInterface(IAudioClock *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IAudioClock))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IAudioClock2))
+        *ppv = &This->IAudioClock2_iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClock_AddRef(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioClock_Release(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioClock_GetFrequency(IAudioClock *iface, UINT64 *freq)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    struct get_frequency_params params;
+
+    TRACE("(%p)->(%p)\n", This, freq);
+
+    params.stream = This->stream;
+    params.freq = freq;
+
+    ALSA_CALL(get_frequency, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClock_GetPosition(IAudioClock *iface, UINT64 *pos,
+        UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    struct get_position_params params;
+
+    TRACE("(%p)->(%p, %p)\n", This, pos, qpctime);
+
+    if(!pos)
+        return E_POINTER;
+
+    params.stream = This->stream;
+    params.device = FALSE;
+    params.pos = pos;
+    params.qpctime = qpctime;
+
+    ALSA_CALL(get_position, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClock_GetCharacteristics(IAudioClock *iface,
+        DWORD *chars)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%p)\n", This, chars);
+
+    if(!chars)
+        return E_POINTER;
+
+    *chars = AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ;
+
+    return S_OK;
+}
+
+static const IAudioClockVtbl AudioClock_Vtbl =
+{
+    AudioClock_QueryInterface,
+    AudioClock_AddRef,
+    AudioClock_Release,
+    AudioClock_GetFrequency,
+    AudioClock_GetPosition,
+    AudioClock_GetCharacteristics
+};
+
+static HRESULT WINAPI AudioClock2_QueryInterface(IAudioClock2 *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClock_QueryInterface(&This->IAudioClock_iface, riid, ppv);
+}
+
+static ULONG WINAPI AudioClock2_AddRef(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioClock2_Release(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioClock2_GetDevicePosition(IAudioClock2 *iface,
+        UINT64 *pos, UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+
+    FIXME("(%p)->(%p, %p)\n", This, pos, qpctime);
+
+    return E_NOTIMPL;
+}
+
+static const IAudioClock2Vtbl AudioClock2_Vtbl =
+{
+    AudioClock2_QueryInterface,
+    AudioClock2_AddRef,
+    AudioClock2_Release,
+    AudioClock2_GetDevicePosition
+};
+
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client)
+{
+    AudioSessionWrapper *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(AudioSessionWrapper));
+    if(!ret)
+        return NULL;
+
+    ret->IAudioSessionControl2_iface.lpVtbl = &AudioSessionControl2_Vtbl;
+    ret->ISimpleAudioVolume_iface.lpVtbl = &SimpleAudioVolume_Vtbl;
+    ret->IChannelAudioVolume_iface.lpVtbl = &ChannelAudioVolume_Vtbl;
+
+    ret->ref = 1;
+
+    ret->client = client;
+    if(client){
+        ret->session = client->session;
+        AudioClient_AddRef(&client->IAudioClient3_iface);
+    }
+
+    return ret;
+}
+
+static HRESULT WINAPI AudioSessionControl_QueryInterface(
+        IAudioSessionControl2 *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioSessionControl) ||
+            IsEqualIID(riid, &IID_IAudioSessionControl2))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioSessionControl_AddRef(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionControl_Release(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    if(!ref){
+        if(This->client){
+            EnterCriticalSection(&g_sessions_lock);
+            This->client->session_wrapper = NULL;
+            LeaveCriticalSection(&g_sessions_lock);
+            AudioClient_Release(&This->client->IAudioClient3_iface);
+        }
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetState(IAudioSessionControl2 *iface,
+        AudioSessionState *state)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    struct is_started_params params;
+    ACImpl *client;
+
+    TRACE("(%p)->(%p)\n", This, state);
+
+    if(!state)
+        return NULL_PTR_ERR;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(list_empty(&This->session->clients)){
+        *state = AudioSessionStateExpired;
+        LeaveCriticalSection(&g_sessions_lock);
+        return S_OK;
+    }
+
+    LIST_FOR_EACH_ENTRY(client, &This->session->clients, ACImpl, entry){
+        params.stream = client->stream;
+        ALSA_CALL(is_started, &params);
+        if(params.result == S_OK){
+            *state = AudioSessionStateActive;
+            LeaveCriticalSection(&g_sessions_lock);
+            return S_OK;
+        }
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    *state = AudioSessionStateInactive;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetDisplayName(
+        IAudioSessionControl2 *iface, WCHAR **name)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, name);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDisplayName(
+        IAudioSessionControl2 *iface, const WCHAR *name, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, name, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetIconPath(
+        IAudioSessionControl2 *iface, WCHAR **path)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, path);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetIconPath(
+        IAudioSessionControl2 *iface, const WCHAR *path, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, path, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetGroupingParam(
+        IAudioSessionControl2 *iface, GUID *group)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, group);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetGroupingParam(
+        IAudioSessionControl2 *iface, const GUID *group, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%s, %s) - stub\n", This, debugstr_guid(group),
+            debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_RegisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_UnregisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionInstanceIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetProcessId(
+        IAudioSessionControl2 *iface, DWORD *pid)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%p)\n", This, pid);
+
+    if(!pid)
+        return E_POINTER;
+
+    *pid = GetCurrentProcessId();
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_IsSystemSoundsSession(
+        IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)\n", This);
+
+    return S_FALSE;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDuckingPreference(
+        IAudioSessionControl2 *iface, BOOL optout)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%d)\n", This, optout);
+
+    return S_OK;
+}
+
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl =
+{
+    AudioSessionControl_QueryInterface,
+    AudioSessionControl_AddRef,
+    AudioSessionControl_Release,
+    AudioSessionControl_GetState,
+    AudioSessionControl_GetDisplayName,
+    AudioSessionControl_SetDisplayName,
+    AudioSessionControl_GetIconPath,
+    AudioSessionControl_SetIconPath,
+    AudioSessionControl_GetGroupingParam,
+    AudioSessionControl_SetGroupingParam,
+    AudioSessionControl_RegisterAudioSessionNotification,
+    AudioSessionControl_UnregisterAudioSessionNotification,
+    AudioSessionControl_GetSessionIdentifier,
+    AudioSessionControl_GetSessionInstanceIdentifier,
+    AudioSessionControl_GetProcessId,
+    AudioSessionControl_IsSystemSoundsSession,
+    AudioSessionControl_SetDuckingPreference
+};
+
+static HRESULT WINAPI SimpleAudioVolume_QueryInterface(
+        ISimpleAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_ISimpleAudioVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI SimpleAudioVolume_AddRef(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI SimpleAudioVolume_Release(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMasterVolume(
+        ISimpleAudioVolume *iface, float level, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+    ACImpl *client;
+
+    TRACE("(%p)->(%f, %s)\n", session, level, wine_dbgstr_guid(context));
+
+    if(level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    TRACE("ALSA does not support volume control\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    session->master_vol = level;
+
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMasterVolume(
+        ISimpleAudioVolume *iface, float *level)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, level);
+
+    if(!level)
+        return NULL_PTR_ERR;
+
+    *level = session->master_vol;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMute(ISimpleAudioVolume *iface,
+        BOOL mute, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+    ACImpl *client;
+
+    TRACE("(%p)->(%u, %s)\n", session, mute, debugstr_guid(context));
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    session->mute = mute;
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMute(ISimpleAudioVolume *iface,
+        BOOL *mute)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, mute);
+
+    if(!mute)
+        return NULL_PTR_ERR;
+
+    *mute = session->mute;
+
+    return S_OK;
+}
+
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl  =
+{
+    SimpleAudioVolume_QueryInterface,
+    SimpleAudioVolume_AddRef,
+    SimpleAudioVolume_Release,
+    SimpleAudioVolume_SetMasterVolume,
+    SimpleAudioVolume_GetMasterVolume,
+    SimpleAudioVolume_SetMute,
+    SimpleAudioVolume_GetMute
+};
+
+static HRESULT WINAPI AudioStreamVolume_QueryInterface(
+        IAudioStreamVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioStreamVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioStreamVolume_AddRef(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioStreamVolume_Release(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelCount(
+        IAudioStreamVolume *iface, UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if(!out)
+        return E_POINTER;
+
+    *out = This->channel_count;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_SetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%d, %f)\n", This, index, level);
+
+    if(level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if(index >= This->channel_count)
+        return E_INVALIDARG;
+
+    TRACE("ALSA does not support volume control\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    This->vols[index] = level;
+    set_stream_volumes(This);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float *level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%d, %p)\n", This, index, level);
+
+    if(!level)
+        return E_POINTER;
+
+    if(index >= This->channel_count)
+        return E_INVALIDARG;
+
+    *level = This->vols[index];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_SetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, const float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    unsigned int i;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if(!levels)
+        return E_POINTER;
+
+    if(count != This->channel_count)
+        return E_INVALIDARG;
+
+    TRACE("ALSA does not support volume control\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    for(i = 0; i < count; ++i)
+        This->vols[i] = levels[i];
+    set_stream_volumes(This);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    unsigned int i;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if(!levels)
+        return E_POINTER;
+
+    if(count != This->channel_count)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    for(i = 0; i < count; ++i)
+        levels[i] = This->vols[i];
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl =
+{
+    AudioStreamVolume_QueryInterface,
+    AudioStreamVolume_AddRef,
+    AudioStreamVolume_Release,
+    AudioStreamVolume_GetChannelCount,
+    AudioStreamVolume_SetChannelVolume,
+    AudioStreamVolume_GetChannelVolume,
+    AudioStreamVolume_SetAllVolumes,
+    AudioStreamVolume_GetAllVolumes
+};
+
+static HRESULT WINAPI ChannelAudioVolume_QueryInterface(
+        IChannelAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IChannelAudioVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI ChannelAudioVolume_AddRef(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI ChannelAudioVolume_Release(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelCount(
+        IChannelAudioVolume *iface, UINT32 *out)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, out);
+
+    if(!out)
+        return NULL_PTR_ERR;
+
+    *out = session->channel_count;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float level,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    ACImpl *client;
+
+    TRACE("(%p)->(%d, %f, %s)\n", session, index, level,
+            wine_dbgstr_guid(context));
+
+    if(level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if(index >= session->channel_count)
+        return E_INVALIDARG;
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    TRACE("ALSA does not support volume control\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    session->channel_vols[index] = level;
+
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float *level)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%d, %p)\n", session, index, level);
+
+    if(!level)
+        return NULL_PTR_ERR;
+
+    if(index >= session->channel_count)
+        return E_INVALIDARG;
+
+    *level = session->channel_vols[index];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, const float *levels,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    unsigned int i;
+    ACImpl *client;
+
+    TRACE("(%p)->(%d, %p, %s)\n", session, count, levels,
+            wine_dbgstr_guid(context));
+
+    if(!levels)
+        return NULL_PTR_ERR;
+
+    if(count != session->channel_count)
+        return E_INVALIDARG;
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    TRACE("ALSA does not support volume control\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    for(i = 0; i < count; ++i)
+        session->channel_vols[i] = levels[i];
+
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, float *levels)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    unsigned int i;
+
+    TRACE("(%p)->(%d, %p)\n", session, count, levels);
+
+    if(!levels)
+        return NULL_PTR_ERR;
+
+    if(count != session->channel_count)
+        return E_INVALIDARG;
+
+    for(i = 0; i < count; ++i)
+        levels[i] = session->channel_vols[i];
+
+    return S_OK;
+}
+
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl =
+{
+    ChannelAudioVolume_QueryInterface,
+    ChannelAudioVolume_AddRef,
+    ChannelAudioVolume_Release,
+    ChannelAudioVolume_GetChannelCount,
+    ChannelAudioVolume_SetChannelVolume,
+    ChannelAudioVolume_GetChannelVolume,
+    ChannelAudioVolume_SetAllVolumes,
+    ChannelAudioVolume_GetAllVolumes
+};
+
+static HRESULT WINAPI AudioSessionManager_QueryInterface(IAudioSessionManager2 *iface,
+        REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioSessionManager) ||
+            IsEqualIID(riid, &IID_IAudioSessionManager2))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioSessionManager_AddRef(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionManager_Release(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    if(!ref)
+        HeapFree(GetProcessHeap(), 0, This);
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetAudioSessionControl(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        IAudioSessionControl **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %lx, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if(FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if(!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = (IAudioSessionControl*)&wrapper->IAudioSessionControl2_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSimpleAudioVolume(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        ISimpleAudioVolume **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %lx, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if(FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if(!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = &wrapper->ISimpleAudioVolume_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSessionEnumerator(
+        IAudioSessionManager2 *iface, IAudioSessionEnumerator **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, out);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterDuckNotification(
+        IAudioSessionManager2 *iface, const WCHAR *session_id,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterDuckNotification(
+        IAudioSessionManager2 *iface,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static const IAudioSessionManager2Vtbl AudioSessionManager2_Vtbl =
+{
+    AudioSessionManager_QueryInterface,
+    AudioSessionManager_AddRef,
+    AudioSessionManager_Release,
+    AudioSessionManager_GetAudioSessionControl,
+    AudioSessionManager_GetSimpleAudioVolume,
+    AudioSessionManager_GetSessionEnumerator,
+    AudioSessionManager_RegisterSessionNotification,
+    AudioSessionManager_UnregisterSessionNotification,
+    AudioSessionManager_RegisterDuckNotification,
+    AudioSessionManager_UnregisterDuckNotification
+};
+
+HRESULT WINAPI AUDDRV_GetAudioSessionManager(IMMDevice *device,
+        IAudioSessionManager2 **out)
+{
+    SessionMgr *This;
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(SessionMgr));
+    if(!This)
+        return E_OUTOFMEMORY;
+
+    This->IAudioSessionManager2_iface.lpVtbl = &AudioSessionManager2_Vtbl;
+    This->device = device;
+    This->ref = 1;
+
+    *out = &This->IAudioSessionManager2_iface;
+
+    return S_OK;
+}
+
+HRESULT WINAPI AUDDRV_GetPropValue(GUID *guid, const PROPERTYKEY *prop, PROPVARIANT *out)
+{
+    struct get_prop_value_params params;
+    char name[256];
+    EDataFlow flow;
+    unsigned int size = 0;
+
+    TRACE("%s, (%s,%lu), %p\n", wine_dbgstr_guid(guid), wine_dbgstr_guid(&prop->fmtid), prop->pid, out);
+
+    if(!get_alsa_name_by_guid(guid, name, sizeof(name), &flow))
+    {
+        WARN("Unknown interface %s\n", debugstr_guid(guid));
+        return E_NOINTERFACE;
+    }
+
+    params.device = name;
+    params.flow = flow;
+    params.guid = guid;
+    params.prop = prop;
+    params.value = out;
+    params.buffer = NULL;
+    params.buffer_size = &size;
+
+    while(1) {
+        ALSA_CALL(get_prop_value, &params);
+
+        if(params.result != E_NOT_SUFFICIENT_BUFFER)
+            break;
+
+        CoTaskMemFree(params.buffer);
+        params.buffer = CoTaskMemAlloc(*params.buffer_size);
+        if(!params.buffer)
+            return E_OUTOFMEMORY;
+    }
+    if(FAILED(params.result))
+        CoTaskMemFree(params.buffer);
+
+    return params.result;
+}
diff --git a/dlls/winealsa.drv/unixlib.h b/dlls/winealsa.drv/unixlib.h
index 11111111111..11111111111 100644
--- a/dlls/winealsa.drv/unixlib.h
+++ b/dlls/winealsa.drv/unixlib.h
@@ -18,15 +18,15 @@
 
 #include "../mmdevapi/unixlib.h"
 
-NTSTATUS alsa_midi_release(void *args) DECLSPEC_HIDDEN;
-NTSTATUS alsa_midi_out_message(void *args) DECLSPEC_HIDDEN;
-NTSTATUS alsa_midi_in_message(void *args) DECLSPEC_HIDDEN;
-NTSTATUS alsa_midi_notify_wait(void *args) DECLSPEC_HIDDEN;
+NTSTATUS alsa_midi_release(void *args);
+NTSTATUS alsa_midi_out_message(void *args);
+NTSTATUS alsa_midi_in_message(void *args);
+NTSTATUS alsa_midi_notify_wait(void *args);
 
 #ifdef _WIN64
-NTSTATUS alsa_wow64_midi_out_message(void *args) DECLSPEC_HIDDEN;
-NTSTATUS alsa_wow64_midi_in_message(void *args) DECLSPEC_HIDDEN;
-NTSTATUS alsa_wow64_midi_notify_wait(void *args) DECLSPEC_HIDDEN;
+NTSTATUS alsa_wow64_midi_out_message(void *args);
+NTSTATUS alsa_wow64_midi_in_message(void *args);
+NTSTATUS alsa_wow64_midi_notify_wait(void *args);
 #endif
 
 #define ALSA_CALL(func, params) WINE_UNIX_CALL(func, params)
diff --git a/dlls/winealsa.drv/winealsa.drv.spec b/dlls/winealsa.drv/winealsa.drv.spec
index 11111111111..11111111111 100644
--- a/dlls/winealsa.drv/winealsa.drv.spec
+++ b/dlls/winealsa.drv/winealsa.drv.spec
@@ -4,5 +4,8 @@
 @ stdcall -private modMessage(long long long long long) ALSA_modMessage
 
 # MMDevAPI driver functions
-@ stdcall -private get_device_guid(long ptr ptr) get_device_guid
-@ stdcall -private get_device_name_from_guid(ptr ptr ptr) get_device_name_from_guid
+@ stdcall -private GetPriority() AUDDRV_GetPriority
+@ stdcall -private GetEndpointIDs(long ptr ptr ptr ptr) AUDDRV_GetEndpointIDs
+@ stdcall -private GetAudioEndpoint(ptr ptr ptr) AUDDRV_GetAudioEndpoint
+@ stdcall -private GetAudioSessionManager(ptr ptr) AUDDRV_GetAudioSessionManager
+@ stdcall -private GetPropValue(ptr ptr ptr) AUDDRV_GetPropValue
diff --git a/dlls/winecoreaudio.drv/Makefile.in b/dlls/winecoreaudio.drv/Makefile.in
index 11111111111..11111111111 100644
--- a/dlls/winecoreaudio.drv/Makefile.in
+++ b/dlls/winecoreaudio.drv/Makefile.in
@@ -4,7 +4,7 @@ IMPORTS   = uuid ole32 user32 advapi32
 DELAYIMPORTS = winmm
 UNIX_LIBS    = $(COREAUDIO_LIBS)
 
-C_SRCS = \
+SOURCES = \
 	coreaudio.c \
 	coremidi.c \
 	midi.c \
diff --git a/dlls/winecoreaudio.drv/coreaudio.c b/dlls/winecoreaudio.drv/coreaudio.c
index 11111111111..11111111111 100644
--- a/dlls/winecoreaudio.drv/coreaudio.c
+++ b/dlls/winecoreaudio.drv/coreaudio.c
@@ -43,6 +43,7 @@
 #include <fenv.h>
 #include <unistd.h>
 
+#include <libkern/OSAtomic.h>
 #include <CoreAudio/CoreAudio.h>
 #include <AudioToolbox/AudioFormat.h>
 #include <AudioToolbox/AudioConverter.h>
@@ -69,39 +70,22 @@
 
 #include "unixlib.h"
 
-#if !defined(MAC_OS_VERSION_12_0) || MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_VERSION_12_0
-#define kAudioObjectPropertyElementMain kAudioObjectPropertyElementMaster
-#endif
-
-#if defined(MAC_OS_X_VERSION_10_12) && MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_12
-#include <os/lock.h>
-#else
-#include <libkern/OSAtomic.h>
-typedef OSSpinLock                  os_unfair_lock;
-#define os_unfair_lock_lock(lock)   OSSpinLockLock(lock)
-#define os_unfair_lock_unlock(lock) OSSpinLockUnlock(lock)
-#endif
-
 WINE_DEFAULT_DEBUG_CHANNEL(coreaudio);
 
 #define MAX_DEV_NAME_LEN 10 /* Max 32 bit digits */
 
 struct coreaudio_stream
 {
-    os_unfair_lock lock;
+    OSSpinLock lock;
     AudioComponentInstance unit;
     AudioConverterRef converter;
     AudioStreamBasicDescription dev_desc; /* audio unit format, not necessarily the same as fmt */
     AudioDeviceID dev_id;
-
     EDataFlow flow;
-    DWORD flags;
     AUDCLNT_SHAREMODE share;
-    HANDLE event;
 
-    BOOL playing, please_quit;
-    REFERENCE_TIME period;
-    UINT32 period_frames;
+    BOOL playing;
+    UINT32 period_ms, period_frames;
     UINT32 bufsize_frames, resamp_bufsize_frames;
     UINT32 lcl_offs_frames, held_frames, wri_offs_frames, tmp_buffer_frames;
     UINT32 cap_bufsize_frames, cap_offs_frames, cap_held_frames;
@@ -112,16 +96,6 @@ struct coreaudio_stream
     BYTE *local_buffer, *cap_buffer, *wrap_buffer, *resamp_buffer, *tmp_buffer;
 };
 
-static const REFERENCE_TIME def_period = 100000;
-static const REFERENCE_TIME min_period = 50000;
-
-static ULONG_PTR zero_bits = 0;
-
-static NTSTATUS unix_not_implemented(void *args)
-{
-    return STATUS_SUCCESS;
-}
-
 static HRESULT osstatus_to_hresult(OSStatus sc)
 {
     switch(sc){
@@ -210,27 +184,6 @@ static BOOL device_has_channels(AudioDeviceID device, EDataFlow flow)
     return ret;
 }
 
-static NTSTATUS unix_process_attach(void *args)
-{
-#ifdef _WIN64
-    if (NtCurrentTeb()->WowTebOffset)
-    {
-        SYSTEM_BASIC_INFORMATION info;
-
-        NtQuerySystemInformation(SystemEmulationBasicInformation, &info, sizeof(info), NULL);
-        zero_bits = (ULONG_PTR)info.HighestUserAddress | 0x7fffffff;
-    }
-#endif
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS unix_main_loop(void *args)
-{
-    struct main_loop_params *params = args;
-    NtSetEvent(params->event, NULL);
-    return STATUS_SUCCESS;
-}
-
 static NTSTATUS unix_get_endpoint_ids(void *args)
 {
     struct get_endpoint_ids_params *params = args;
@@ -251,7 +204,7 @@ static NTSTATUS unix_get_endpoint_ids(void *args)
     params->default_idx = 0;
 
     addr.mScope = kAudioObjectPropertyScopeGlobal;
-    addr.mElement = kAudioObjectPropertyElementMain;
+    addr.mElement = kAudioObjectPropertyElementMaster;
     if(params->flow == eRender) addr.mSelector = kAudioHardwarePropertyDefaultOutputDevice;
     else if(params->flow == eCapture) addr.mSelector = kAudioHardwarePropertyDefaultInputDevice;
     else{
@@ -385,7 +338,7 @@ static OSStatus ca_render_cb(void *user, AudioUnitRenderActionFlags *flags,
     struct coreaudio_stream *stream = user;
     UINT32 to_copy_bytes, to_copy_frames, chunk_bytes, lcl_offs_bytes;
 
-    os_unfair_lock_lock(&stream->lock);
+    OSSpinLockLock(&stream->lock);
 
     if(stream->playing){
         lcl_offs_bytes = stream->lcl_offs_frames * stream->fmt->nBlockAlign;
@@ -409,7 +362,7 @@ static OSStatus ca_render_cb(void *user, AudioUnitRenderActionFlags *flags,
     if(nframes > to_copy_frames)
         silence_buffer(stream, ((BYTE *)data->mBuffers[0].mData) + to_copy_bytes, nframes - to_copy_frames);
 
-    os_unfair_lock_unlock(&stream->lock);
+    OSSpinLockUnlock(&stream->lock);
 
     return noErr;
 }
@@ -442,7 +395,7 @@ static OSStatus ca_capture_cb(void *user, AudioUnitRenderActionFlags *flags,
     OSStatus sc;
     UINT32 cap_wri_offs_frames;
 
-    os_unfair_lock_lock(&stream->lock);
+    OSSpinLockLock(&stream->lock);
 
     cap_wri_offs_frames = (stream->cap_offs_frames + stream->cap_held_frames) % stream->cap_bufsize_frames;
 
@@ -463,7 +416,7 @@ static OSStatus ca_capture_cb(void *user, AudioUnitRenderActionFlags *flags,
 
     sc = AudioUnitRender(stream->unit, flags, ts, bus, nframes, &list);
     if(sc != noErr){
-        os_unfair_lock_unlock(&stream->lock);
+        OSSpinLockUnlock(&stream->lock);
         return sc;
     }
 
@@ -483,7 +436,7 @@ static OSStatus ca_capture_cb(void *user, AudioUnitRenderActionFlags *flags,
         }
     }
 
-    os_unfair_lock_unlock(&stream->lock);
+    OSSpinLockUnlock(&stream->lock);
     return noErr;
 }
 
@@ -667,6 +620,15 @@ static HRESULT ca_setup_audiounit(EDataFlow dataflow, AudioComponentInstance uni
     return S_OK;
 }
 
+static ULONG_PTR zero_bits(void)
+{
+#ifdef _WIN64
+    return !NtCurrentTeb()->WowTebOffset ? 0 : 0x7fffffff;
+#else
+    return 0;
+#endif
+}
+
 static AudioDeviceID dev_id_from_device(const char *device)
 {
     return strtoul(device, NULL, 10);
@@ -675,45 +637,12 @@ static AudioDeviceID dev_id_from_device(const char *device)
 static NTSTATUS unix_create_stream(void *args)
 {
     struct create_stream_params *params = args;
-    struct coreaudio_stream *stream;
+    struct coreaudio_stream *stream = calloc(1, sizeof(*stream));
     AURenderCallbackStruct input;
     OSStatus sc;
     SIZE_T size;
 
-    params->result = S_OK;
-
-    if (params->share == AUDCLNT_SHAREMODE_SHARED) {
-        params->period = def_period;
-        if (params->duration < 3 * params->period)
-            params->duration = 3 * params->period;
-    } else {
-        const WAVEFORMATEXTENSIBLE *fmtex = (WAVEFORMATEXTENSIBLE *)params->fmt;
-        if (fmtex->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
-           (fmtex->dwChannelMask == 0 || fmtex->dwChannelMask & SPEAKER_RESERVED))
-            params->result = AUDCLNT_E_UNSUPPORTED_FORMAT;
-        else {
-            if (!params->period)
-                params->period = def_period;
-            if (params->period < min_period || params->period > 5000000)
-                params->result = AUDCLNT_E_INVALID_DEVICE_PERIOD;
-            else if (params->duration > 20000000) /* The smaller the period, the lower this limit. */
-                params->result = AUDCLNT_E_BUFFER_SIZE_ERROR;
-            else if (params->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) {
-                if (params->duration != params->period)
-                    params->result = AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
-
-                FIXME("EXCLUSIVE mode with EVENTCALLBACK\n");
-
-                params->result = AUDCLNT_E_DEVICE_IN_USE;
-            } else if (params->duration < 8 * params->period)
-                params->duration = 8 * params->period; /* May grow above 2s. */
-        }
-    }
-
-    if (FAILED(params->result))
-        return STATUS_SUCCESS;
-
-    if (!(stream = calloc(1, sizeof(*stream)))) {
+    if(!stream){
         params->result = E_OUTOFMEMORY;
         return STATUS_SUCCESS;
     }
@@ -724,11 +653,10 @@ static NTSTATUS unix_create_stream(void *args)
         goto end;
     }
 
-    stream->period = params->period;
+    stream->period_ms = params->period / 10000;
     stream->period_frames = muldiv(params->period, stream->fmt->nSamplesPerSec, 10000000);
     stream->dev_id = dev_id_from_device(params->device);
     stream->flow = params->flow;
-    stream->flags = params->flags;
     stream->share = params->share;
 
     stream->bufsize_frames = muldiv(params->duration, stream->fmt->nSamplesPerSec, 10000000);
@@ -776,7 +704,7 @@ static NTSTATUS unix_create_stream(void *args)
     }
 
     size = stream->bufsize_frames * stream->fmt->nBlockAlign;
-    if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->local_buffer, zero_bits,
+    if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->local_buffer, zero_bits(),
                                &size, MEM_COMMIT, PAGE_READWRITE)){
         params->result = E_OUTOFMEMORY;
         goto end;
@@ -795,10 +723,8 @@ end:
         if(stream->unit) AudioComponentInstanceDispose(stream->unit);
         free(stream->fmt);
         free(stream);
-    } else {
-        *params->channel_count = params->fmt->nChannels;
+    } else
         *params->stream = (stream_handle)(UINT_PTR)stream;
-    }
 
     return STATUS_SUCCESS;
 }
@@ -809,12 +735,6 @@ static NTSTATUS unix_release_stream( void *args )
     struct coreaudio_stream *stream = handle_get_stream(params->stream);
     SIZE_T size;
 
-    if(params->timer_thread){
-        stream->please_quit = TRUE;
-        NtWaitForSingleObject(params->timer_thread, FALSE, NULL);
-        NtClose(params->timer_thread);
-    }
-
     if(stream->unit){
         AudioOutputUnitStop(stream->unit);
         AudioComponentInstanceDispose(stream->unit);
@@ -1151,20 +1071,6 @@ unsupported:
     return STATUS_SUCCESS;
 }
 
-static NTSTATUS unix_get_device_period(void *args)
-{
-    struct get_device_period_params *params = args;
-
-    if (params->def_period)
-        *params->def_period = def_period;
-    if (params->min_period)
-        *params->min_period = min_period;
-
-    params->result = S_OK;
-
-    return STATUS_SUCCESS;
-}
-
 static UINT buf_ptr_diff(UINT left, UINT right, UINT bufsize)
 {
     if(left <= right)
@@ -1270,9 +1176,9 @@ static NTSTATUS unix_get_buffer_size(void *args)
     struct get_buffer_size_params *params = args;
     struct coreaudio_stream *stream = handle_get_stream(params->stream);
 
-    os_unfair_lock_lock(&stream->lock);
+    OSSpinLockLock(&stream->lock);
     *params->frames = stream->bufsize_frames;
-    os_unfair_lock_unlock(&stream->lock);
+    OSSpinLockUnlock(&stream->lock);
     params->result = S_OK;
     return STATUS_SUCCESS;
 }
@@ -1337,7 +1243,7 @@ static NTSTATUS unix_get_latency(void *args)
     AudioObjectPropertyAddress addr;
     OSStatus sc;
 
-    os_unfair_lock_lock(&stream->lock);
+    OSSpinLockLock(&stream->lock);
 
     addr.mScope = get_scope(stream->flow);
     addr.mSelector = kAudioDevicePropertyLatency;
@@ -1347,23 +1253,24 @@ static NTSTATUS unix_get_latency(void *args)
     sc = AudioObjectGetPropertyData(stream->dev_id, &addr, 0, NULL, &size, &latency);
     if(sc != noErr){
         WARN("Couldn't get _Latency property: %x\n", (int)sc);
-        os_unfair_lock_unlock(&stream->lock);
+        OSSpinLockUnlock(&stream->lock);
         params->result = osstatus_to_hresult(sc);
         return STATUS_SUCCESS;
     }
 
     params->result = ca_get_max_stream_latency(stream, &stream_latency);
     if(FAILED(params->result)){
-        os_unfair_lock_unlock(&stream->lock);
+        OSSpinLockUnlock(&stream->lock);
         return STATUS_SUCCESS;
     }
 
     latency += stream_latency;
     /* pretend we process audio in Period chunks, so max latency includes
      * the period time */
-    *params->latency = muldiv(latency, 10000000, stream->fmt->nSamplesPerSec) + stream->period;
+    *params->latency = muldiv(latency, 10000000, stream->fmt->nSamplesPerSec)
+        + stream->period_ms * 10000;
 
-    os_unfair_lock_unlock(&stream->lock);
+    OSSpinLockUnlock(&stream->lock);
     params->result = S_OK;
     return STATUS_SUCCESS;
 }
@@ -1379,9 +1286,9 @@ static NTSTATUS unix_get_current_padding(void *args)
     struct get_current_padding_params *params = args;
     struct coreaudio_stream *stream = handle_get_stream(params->stream);
 
-    os_unfair_lock_lock(&stream->lock);
+    OSSpinLockLock(&stream->lock);
     *params->padding = get_current_padding_nolock(stream);
-    os_unfair_lock_unlock(&stream->lock);
+    OSSpinLockUnlock(&stream->lock);
     params->result = S_OK;
     return STATUS_SUCCESS;
 }
@@ -1391,18 +1298,16 @@ static NTSTATUS unix_start(void *args)
     struct start_params *params = args;
     struct coreaudio_stream *stream = handle_get_stream(params->stream);
 
-    os_unfair_lock_lock(&stream->lock);
+    OSSpinLockLock(&stream->lock);
 
-    if((stream->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) && !stream->event)
-        params->result = AUDCLNT_E_EVENTHANDLE_NOT_SET;
-    else if(stream->playing)
+    if(stream->playing)
         params->result = AUDCLNT_E_NOT_STOPPED;
     else{
         stream->playing = TRUE;
         params->result = S_OK;
     }
 
-    os_unfair_lock_unlock(&stream->lock);
+    OSSpinLockUnlock(&stream->lock);
 
     return STATUS_SUCCESS;
 }
@@ -1412,7 +1317,7 @@ static NTSTATUS unix_stop(void *args)
     struct stop_params *params = args;
     struct coreaudio_stream *stream = handle_get_stream(params->stream);
 
-    os_unfair_lock_lock(&stream->lock);
+    OSSpinLockLock(&stream->lock);
 
     if(!stream->playing)
         params->result = S_FALSE;
@@ -1421,7 +1326,7 @@ static NTSTATUS unix_stop(void *args)
         params->result = S_OK;
     }
 
-    os_unfair_lock_unlock(&stream->lock);
+    OSSpinLockUnlock(&stream->lock);
 
     return STATUS_SUCCESS;
 }
@@ -1431,7 +1336,7 @@ static NTSTATUS unix_reset(void *args)
     struct reset_params *params = args;
     struct coreaudio_stream *stream = handle_get_stream(params->stream);
 
-    os_unfair_lock_lock(&stream->lock);
+    OSSpinLockLock(&stream->lock);
 
     if(stream->playing)
         params->result = AUDCLNT_E_NOT_STOPPED;
@@ -1450,36 +1355,7 @@ static NTSTATUS unix_reset(void *args)
         params->result = S_OK;
     }
 
-    os_unfair_lock_unlock(&stream->lock);
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS unix_timer_loop(void *args)
-{
-    struct timer_loop_params *params = args;
-    struct coreaudio_stream *stream = handle_get_stream(params->stream);
-    LARGE_INTEGER delay, next, last;
-    int adjust;
-
-    delay.QuadPart = -stream->period;
-    NtQueryPerformanceCounter(&last, NULL);
-    next.QuadPart = last.QuadPart + stream->period;
-
-    while(!stream->please_quit){
-        NtSetEvent(stream->event, NULL);
-        NtDelayExecution(FALSE, &delay);
-        NtQueryPerformanceCounter(&last, NULL);
-
-        adjust = next.QuadPart - last.QuadPart;
-        if(adjust > stream->period / 2)
-            adjust = stream->period / 2;
-        else if(adjust < -stream->period / 2)
-            adjust = -stream->period / 2;
-
-        delay.QuadPart = -(stream->period + adjust);
-        next.QuadPart += stream->period;
-    }
-
+    OSSpinLockUnlock(&stream->lock);
     return STATUS_SUCCESS;
 }
 
@@ -1490,7 +1366,7 @@ static NTSTATUS unix_get_render_buffer(void *args)
     SIZE_T size;
     UINT32 pad;
 
-    os_unfair_lock_lock(&stream->lock);
+    OSSpinLockLock(&stream->lock);
 
     pad = get_current_padding_nolock(stream);
 
@@ -1516,7 +1392,7 @@ static NTSTATUS unix_get_render_buffer(void *args)
                 stream->tmp_buffer = NULL;
             }
             size = params->frames * stream->fmt->nBlockAlign;
-            if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer, zero_bits,
+            if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer, zero_bits(),
                                        &size, MEM_COMMIT, PAGE_READWRITE)){
                 stream->tmp_buffer_frames = 0;
                 params->result = E_OUTOFMEMORY;
@@ -1535,7 +1411,7 @@ static NTSTATUS unix_get_render_buffer(void *args)
     params->result = S_OK;
 
 end:
-    os_unfair_lock_unlock(&stream->lock);
+    OSSpinLockUnlock(&stream->lock);
 
     return STATUS_SUCCESS;
 }
@@ -1546,7 +1422,7 @@ static NTSTATUS unix_release_render_buffer(void *args)
     struct coreaudio_stream *stream = handle_get_stream(params->stream);
     BYTE *buffer;
 
-    os_unfair_lock_lock(&stream->lock);
+    OSSpinLockLock(&stream->lock);
 
     if(!params->written_frames){
         stream->getbuf_last = 0;
@@ -1579,7 +1455,7 @@ static NTSTATUS unix_release_render_buffer(void *args)
         params->result = S_OK;
     }
 
-    os_unfair_lock_unlock(&stream->lock);
+    OSSpinLockUnlock(&stream->lock);
 
     return STATUS_SUCCESS;
 }
@@ -1592,7 +1468,7 @@ static NTSTATUS unix_get_capture_buffer(void *args)
     LARGE_INTEGER stamp, freq;
     SIZE_T size;
 
-    os_unfair_lock_lock(&stream->lock);
+    OSSpinLockLock(&stream->lock);
 
     if(stream->getbuf_last){
         params->result = AUDCLNT_E_OUT_OF_ORDER;
@@ -1614,7 +1490,7 @@ static NTSTATUS unix_get_capture_buffer(void *args)
         chunk_bytes = chunk_frames * stream->fmt->nBlockAlign;
         if(!stream->tmp_buffer){
             size = stream->period_frames * stream->fmt->nBlockAlign;
-            NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer, zero_bits,
+            NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer, zero_bits(),
                                     &size, MEM_COMMIT, PAGE_READWRITE);
         }
         *params->data = stream->tmp_buffer;
@@ -1636,7 +1512,7 @@ static NTSTATUS unix_get_capture_buffer(void *args)
     params->result = S_OK;
 
 end:
-    os_unfair_lock_unlock(&stream->lock);
+    OSSpinLockUnlock(&stream->lock);
     return STATUS_SUCCESS;
 }
 
@@ -1645,7 +1521,7 @@ static NTSTATUS unix_release_capture_buffer(void *args)
     struct release_capture_buffer_params *params = args;
     struct coreaudio_stream *stream = handle_get_stream(params->stream);
 
-    os_unfair_lock_lock(&stream->lock);
+    OSSpinLockLock(&stream->lock);
 
     if(!params->done){
         stream->getbuf_last = 0;
@@ -1663,7 +1539,7 @@ static NTSTATUS unix_release_capture_buffer(void *args)
         params->result = S_OK;
     }
 
-    os_unfair_lock_unlock(&stream->lock);
+    OSSpinLockUnlock(&stream->lock);
 
     return STATUS_SUCCESS;
 }
@@ -1673,7 +1549,7 @@ static NTSTATUS unix_get_next_packet_size(void *args)
     struct get_next_packet_size_params *params = args;
     struct coreaudio_stream *stream = handle_get_stream(params->stream);
 
-    os_unfair_lock_lock(&stream->lock);
+    OSSpinLockLock(&stream->lock);
 
     capture_resample(stream);
 
@@ -1682,7 +1558,7 @@ static NTSTATUS unix_get_next_packet_size(void *args)
     else
         *params->frames = 0;
 
-    os_unfair_lock_unlock(&stream->lock);
+    OSSpinLockUnlock(&stream->lock);
 
     params->result = S_OK;
     return STATUS_SUCCESS;
@@ -1694,13 +1570,7 @@ static NTSTATUS unix_get_position(void *args)
     struct coreaudio_stream *stream = handle_get_stream(params->stream);
     LARGE_INTEGER stamp, freq;
 
-    if (params->device) {
-        FIXME("Device position reporting not implemented\n");
-        params->result = E_NOTIMPL;
-        return STATUS_SUCCESS;
-    }
-
-    os_unfair_lock_lock(&stream->lock);
+    OSSpinLockLock(&stream->lock);
 
     *params->pos = stream->written_frames - stream->held_frames;
 
@@ -1712,7 +1582,7 @@ static NTSTATUS unix_get_position(void *args)
         *params->qpctime = (stamp.QuadPart * (INT64)10000000) / freq.QuadPart;
     }
 
-    os_unfair_lock_unlock(&stream->lock);
+    OSSpinLockUnlock(&stream->lock);
 
     params->result = S_OK;
     return STATUS_SUCCESS;
@@ -1745,88 +1615,55 @@ static NTSTATUS unix_is_started(void *args)
     return STATUS_SUCCESS;
 }
 
-static NTSTATUS unix_get_prop_value(void *args)
-{
-    struct get_prop_value_params *params = args;
-
-    params->result = E_NOTIMPL;
-
-    return STATUS_SUCCESS;
-}
-
 static NTSTATUS unix_set_volumes(void *args)
 {
     struct set_volumes_params *params = args;
     struct coreaudio_stream *stream = handle_get_stream(params->stream);
-    Float32 level = params->master_volume;
+    Float32 level = 1.0, tmp;
     OSStatus sc;
     UINT32 i;
-    AudioObjectPropertyAddress prop_addr = {
-        kAudioDevicePropertyVolumeScalar,
-        kAudioObjectPropertyScopeGlobal,
-        kAudioObjectPropertyElementMain
-    };
 
-    sc = AudioObjectSetPropertyData(stream->dev_id, &prop_addr, 0, NULL, sizeof(float), &level);
-    if (sc == noErr)
-        level = 1.0f;
-    else
-        WARN("Couldn't set master volume, applying it directly to the channels: %x\n", (int)sc);
-
-    for (i = 1; i <= stream->fmt->nChannels; ++i) {
-        const float vol = level * params->session_volumes[i - 1] * params->volumes[i - 1];
-
-        prop_addr.mElement = i;
+    if(params->channel >= stream->fmt->nChannels || params->channel < -1){
+        ERR("Incorrect channel %d\n", params->channel);
+        return STATUS_SUCCESS;
+    }
 
-        sc = AudioObjectSetPropertyData(stream->dev_id, &prop_addr, 0, NULL, sizeof(float), &vol);
-        if (sc != noErr) {
-            WARN("Couldn't set channel #%u volume: %x\n", i, (int)sc);
+    if(params->channel == -1){
+        for(i = 0; i < stream->fmt->nChannels; ++i){
+            tmp = params->master_volume * params->volumes[i] * params->session_volumes[i];
+            level = tmp < level ? tmp : level;
         }
-    }
+    }else
+        level = params->master_volume * params->volumes[params->channel] *
+            params->session_volumes[params->channel];
 
-    return STATUS_SUCCESS;
-}
+    sc = AudioUnitSetParameter(stream->unit, kHALOutputParam_Volume,
+                               kAudioUnitScope_Global, 0, level, 0);
+    if(sc != noErr)
+        WARN("Couldn't set volume: %x\n", (int)sc);
 
-static NTSTATUS unix_set_event_handle(void *args)
-{
-    struct set_event_handle_params *params = args;
-    struct coreaudio_stream *stream = handle_get_stream(params->stream);
-    HRESULT hr = S_OK;
-
-    os_unfair_lock_lock(&stream->lock);
-    if(!stream->unit)
-        hr = AUDCLNT_E_DEVICE_INVALIDATED;
-    else if(!(stream->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK))
-        hr = AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED;
-    else if(stream->event)
-        hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
-    else
-        stream->event = params->event;
-    os_unfair_lock_unlock(&stream->lock);
-
-    params->result = hr;
     return STATUS_SUCCESS;
 }
 
-const unixlib_entry_t __wine_unix_call_funcs[] =
+unixlib_entry_t __wine_unix_call_funcs[] =
 {
-    unix_process_attach,
-    unix_not_implemented,
-    unix_main_loop,
+    NULL,
+    NULL,
+    NULL,
     unix_get_endpoint_ids,
     unix_create_stream,
     unix_release_stream,
     unix_start,
     unix_stop,
     unix_reset,
-    unix_timer_loop,
+    NULL,
     unix_get_render_buffer,
     unix_release_render_buffer,
     unix_get_capture_buffer,
     unix_release_capture_buffer,
     unix_is_format_supported,
     unix_get_mix_format,
-    unix_get_device_period,
+    NULL,
     unix_get_buffer_size,
     unix_get_latency,
     unix_get_current_padding,
@@ -1834,37 +1671,22 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     unix_get_frequency,
     unix_get_position,
     unix_set_volumes,
-    unix_set_event_handle,
-    unix_not_implemented,
+    NULL,
+    NULL,
     unix_is_started,
-    unix_get_prop_value,
+    NULL,
     unix_midi_init,
     unix_midi_release,
     unix_midi_out_message,
     unix_midi_in_message,
     unix_midi_notify_wait,
-    unix_not_implemented,
+    NULL,
 };
 
-C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == funcs_count);
-
 #ifdef _WIN64
 
 typedef UINT PTR32;
 
-static NTSTATUS unix_wow64_main_loop(void *args)
-{
-    struct
-    {
-        PTR32 event;
-    } *params32 = args;
-    struct main_loop_params params =
-    {
-        .event = ULongToHandle(params32->event)
-    };
-    return unix_main_loop(&params);
-}
-
 static NTSTATUS unix_wow64_get_endpoint_ids(void *args)
 {
     struct
@@ -2036,28 +1858,6 @@ static NTSTATUS unix_wow64_get_mix_format(void *args)
     return STATUS_SUCCESS;
 }
 
-static NTSTATUS unix_wow64_get_device_period(void *args)
-{
-    struct
-    {
-        PTR32 device;
-        EDataFlow flow;
-        HRESULT result;
-        PTR32 def_period;
-        PTR32 min_period;
-    } *params32 = args;
-    struct get_device_period_params params =
-    {
-        .device = ULongToPtr(params32->device),
-        .flow = params32->flow,
-        .def_period = ULongToPtr(params32->def_period),
-        .min_period = ULongToPtr(params32->min_period),
-    };
-    unix_get_device_period(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
 static NTSTATUS unix_wow64_get_buffer_size(void *args)
 {
     struct
@@ -2135,7 +1935,6 @@ static NTSTATUS unix_wow64_get_position(void *args)
     struct
     {
         stream_handle stream;
-        BOOL device;
         HRESULT result;
         PTR32 pos;
         PTR32 qpctime;
@@ -2143,7 +1942,6 @@ static NTSTATUS unix_wow64_get_position(void *args)
     struct get_position_params params =
     {
         .stream = params32->stream,
-        .device = params32->device,
         .pos = ULongToPtr(params32->pos),
         .qpctime = ULongToPtr(params32->qpctime)
     };
@@ -2178,6 +1976,7 @@ static NTSTATUS unix_wow64_set_volumes(void *args)
         float master_volume;
         PTR32 volumes;
         PTR32 session_volumes;
+        int channel;
     } *params32 = args;
     struct set_volumes_params params =
     {
@@ -2185,103 +1984,30 @@ static NTSTATUS unix_wow64_set_volumes(void *args)
         .master_volume = params32->master_volume,
         .volumes = ULongToPtr(params32->volumes),
         .session_volumes = ULongToPtr(params32->session_volumes),
+        .channel = params32->channel
     };
     return unix_set_volumes(&params);
 }
 
-static NTSTATUS unix_wow64_set_event_handle(void *args)
-{
-    struct
-    {
-        stream_handle stream;
-        PTR32 event;
-        HRESULT result;
-    } *params32 = args;
-    struct set_event_handle_params params =
-    {
-        .stream = params32->stream,
-        .event = ULongToHandle(params32->event)
-    };
-    unix_set_event_handle(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS unix_wow64_get_prop_value(void *args)
+unixlib_entry_t __wine_unix_call_wow64_funcs[] =
 {
-    struct propvariant32
-    {
-        WORD vt;
-        WORD pad1, pad2, pad3;
-        union
-        {
-            ULONG ulVal;
-            PTR32 ptr;
-            ULARGE_INTEGER uhVal;
-        };
-    } *value32;
-    struct
-    {
-        PTR32 device;
-        EDataFlow flow;
-        PTR32 guid;
-        PTR32 prop;
-        HRESULT result;
-        PTR32 value;
-        PTR32 buffer; /* caller allocated buffer to hold value's strings */
-        PTR32 buffer_size;
-    } *params32 = args;
-    PROPVARIANT value;
-    struct get_prop_value_params params =
-    {
-        .device = ULongToPtr(params32->device),
-        .flow = params32->flow,
-        .guid = ULongToPtr(params32->guid),
-        .prop = ULongToPtr(params32->prop),
-        .value = &value,
-        .buffer = ULongToPtr(params32->buffer),
-        .buffer_size = ULongToPtr(params32->buffer_size)
-    };
-    unix_get_prop_value(&params);
-    params32->result = params.result;
-    if (SUCCEEDED(params.result))
-    {
-        value32 = UlongToPtr(params32->value);
-        value32->vt = value.vt;
-        switch (value.vt)
-        {
-        case VT_UI4:
-            value32->ulVal = value.ulVal;
-            break;
-        case VT_LPWSTR:
-            value32->ptr = params32->buffer;
-            break;
-        default:
-            FIXME("Unhandled vt %04x\n", value.vt);
-        }
-    }
-    return STATUS_SUCCESS;
-}
-
-const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
-{
-    unix_process_attach,
-    unix_not_implemented,
-    unix_wow64_main_loop,
+    NULL,
+    NULL,
+    NULL,
     unix_wow64_get_endpoint_ids,
     unix_wow64_create_stream,
     unix_wow64_release_stream,
     unix_start,
     unix_stop,
     unix_reset,
-    unix_timer_loop,
+    NULL,
     unix_wow64_get_render_buffer,
     unix_release_render_buffer,
     unix_wow64_get_capture_buffer,
     unix_release_capture_buffer,
     unix_wow64_is_format_supported,
     unix_wow64_get_mix_format,
-    unix_wow64_get_device_period,
+    NULL,
     unix_wow64_get_buffer_size,
     unix_wow64_get_latency,
     unix_wow64_get_current_padding,
@@ -2289,18 +2015,16 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
     unix_wow64_get_frequency,
     unix_wow64_get_position,
     unix_wow64_set_volumes,
-    unix_wow64_set_event_handle,
-    unix_not_implemented,
+    NULL,
+    NULL,
     unix_is_started,
-    unix_wow64_get_prop_value,
+    NULL,
     unix_wow64_midi_init,
     unix_midi_release,
     unix_wow64_midi_out_message,
     unix_wow64_midi_in_message,
     unix_wow64_midi_notify_wait,
-    unix_not_implemented,
+    NULL,
 };
 
-C_ASSERT(ARRAYSIZE(__wine_unix_call_wow64_funcs) == funcs_count);
-
 #endif /* _WIN64 */
diff --git a/dlls/winecoreaudio.drv/coreaudio.h b/dlls/winecoreaudio.drv/coreaudio.h
index 11111111111..11111111111 100644
--- a/dlls/winecoreaudio.drv/coreaudio.h
+++ b/dlls/winecoreaudio.drv/coreaudio.h
@@ -23,7 +23,7 @@
 #include "wine/debug.h"
 
 /* fourcc is in native order, where MSB is the first character. */
-static inline const char* coreaudio_dbgstr_fourcc(INT32 fourcc)
+static inline const char* wine_dbgstr_fourcc(INT32 fourcc)
 {
     char buf[4] = { (char) (fourcc >> 24), (char) (fourcc >> 16),
                     (char) (fourcc >> 8),  (char) fourcc };
diff --git a/dlls/winecoreaudio.drv/coremidi.c b/dlls/winecoreaudio.drv/coremidi.c
index 11111111111..11111111111 100644
--- a/dlls/winecoreaudio.drv/coremidi.c
+++ b/dlls/winecoreaudio.drv/coremidi.c
@@ -448,7 +448,7 @@ static BOOL synth_unit_create_default(AUGraph *graph, AudioUnit *synth)
     sc = NewAUGraph(graph);
     if (sc != noErr)
     {
-        ERR("NewAUGraph return %s\n", coreaudio_dbgstr_fourcc(sc));
+        ERR("NewAUGraph return %s\n", wine_dbgstr_fourcc(sc));
         return FALSE;
     }
 
@@ -463,7 +463,7 @@ static BOOL synth_unit_create_default(AUGraph *graph, AudioUnit *synth)
     sc = AUGraphAddNode(*graph, &desc, &synth_node);
     if (sc != noErr)
     {
-        ERR("AUGraphAddNode cannot create synthNode : %s\n", coreaudio_dbgstr_fourcc(sc));
+        ERR("AUGraphAddNode cannot create synthNode : %s\n", wine_dbgstr_fourcc(sc));
         return FALSE;
     }
 
@@ -474,14 +474,14 @@ static BOOL synth_unit_create_default(AUGraph *graph, AudioUnit *synth)
     sc = AUGraphAddNode(*graph, &desc, &out_node);
     if (sc != noErr)
     {
-        ERR("AUGraphAddNode cannot create outNode %s\n", coreaudio_dbgstr_fourcc(sc));
+        ERR("AUGraphAddNode cannot create outNode %s\n", wine_dbgstr_fourcc(sc));
         return FALSE;
     }
 
     sc = AUGraphOpen(*graph);
     if (sc != noErr)
     {
-        ERR("AUGraphOpen returns %s\n", coreaudio_dbgstr_fourcc(sc));
+        ERR("AUGraphOpen returns %s\n", wine_dbgstr_fourcc(sc));
         return FALSE;
     }
 
@@ -490,7 +490,7 @@ static BOOL synth_unit_create_default(AUGraph *graph, AudioUnit *synth)
     if (sc != noErr)
     {
         ERR("AUGraphConnectNodeInput cannot connect synthNode to outNode : %s\n",
-            coreaudio_dbgstr_fourcc(sc));
+            wine_dbgstr_fourcc(sc));
         return FALSE;
     }
 
@@ -498,7 +498,7 @@ static BOOL synth_unit_create_default(AUGraph *graph, AudioUnit *synth)
     sc = AUGraphNodeInfo(*graph, synth_node, 0, synth);
     if (sc != noErr)
     {
-        ERR("AUGraphNodeInfo return %s\n", coreaudio_dbgstr_fourcc(sc));
+        ERR("AUGraphNodeInfo return %s\n", wine_dbgstr_fourcc(sc));
         return FALSE;
     }
 
@@ -512,14 +512,14 @@ static BOOL synth_unit_init(AudioUnit synth, AUGraph graph)
     sc = AUGraphInitialize(graph);
     if (sc != noErr)
     {
-        ERR("AUGraphInitialize(%p) returns %s\n", graph, coreaudio_dbgstr_fourcc(sc));
+        ERR("AUGraphInitialize(%p) returns %s\n", graph, wine_dbgstr_fourcc(sc));
         return FALSE;
     }
 
     sc = AUGraphStart(graph);
     if (sc != noErr)
     {
-        ERR("AUGraphStart(%p) returns %s\n", graph, coreaudio_dbgstr_fourcc(sc));
+        ERR("AUGraphStart(%p) returns %s\n", graph, wine_dbgstr_fourcc(sc));
         return FALSE;
     }
 
@@ -533,14 +533,14 @@ static BOOL synth_unit_close(AUGraph graph)
     sc = AUGraphStop(graph);
     if (sc != noErr)
     {
-        ERR("AUGraphStop(%p) returns %s\n", graph, coreaudio_dbgstr_fourcc(sc));
+        ERR("AUGraphStop(%p) returns %s\n", graph, wine_dbgstr_fourcc(sc));
         return FALSE;
     }
 
     sc = DisposeAUGraph(graph);
     if (sc != noErr)
     {
-        ERR("DisposeAUGraph(%p) returns %s\n", graph, coreaudio_dbgstr_fourcc(sc));
+        ERR("DisposeAUGraph(%p) returns %s\n", graph, wine_dbgstr_fourcc(sc));
         return FALSE;
     }
 
@@ -686,7 +686,7 @@ static UINT midi_out_data(WORD dev_id, UINT data)
         sc = MusicDeviceMIDIEvent(dest->synth, bytes[0], bytes[1], bytes[2], 0);
         if (sc != noErr)
         {
-            ERR("MusicDeviceMIDIEvent returns %s\n", coreaudio_dbgstr_fourcc(sc));
+            ERR("MusicDeviceMIDIEvent returns %s\n", wine_dbgstr_fourcc(sc));
             return MMSYSERR_ERROR;
         }
     }
@@ -739,7 +739,7 @@ static UINT midi_out_long_data(WORD dev_id, MIDIHDR *hdr, UINT hdr_size, struct
         sc = MusicDeviceSysEx(dest->synth, (const UInt8 *)hdr->lpData, hdr->dwBufferLength);
         if (sc != noErr)
         {
-            ERR("MusicDeviceSysEx returns %s\n", coreaudio_dbgstr_fourcc(sc));
+            ERR("MusicDeviceSysEx returns %s\n", wine_dbgstr_fourcc(sc));
             return MMSYSERR_ERROR;
         }
     }
diff --git a/dlls/winecoreaudio.drv/mmdevdrv.c b/dlls/winecoreaudio.drv/mmdevdrv.c
index 11111111111..11111111111 100644
--- a/dlls/winecoreaudio.drv/mmdevdrv.c
+++ b/dlls/winecoreaudio.drv/mmdevdrv.c
@@ -18,7 +18,6 @@
 #define COBJMACROS
 
 #include <stdarg.h>
-#include <wchar.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -42,42 +41,183 @@
 #include "audiopolicy.h"
 #include "unixlib.h"
 
-#include "../mmdevapi/mmdevdrv.h"
-
 WINE_DEFAULT_DEBUG_CHANNEL(coreaudio);
 
-static WCHAR drv_key_devicesW[256];
+#define NULL_PTR_ERR MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER)
+
+static const REFERENCE_TIME DefaultPeriod = 100000;
+static const REFERENCE_TIME MinimumPeriod = 50000;
+
+struct ACImpl;
+typedef struct ACImpl ACImpl;
+
+typedef struct _AudioSession {
+    GUID guid;
+    struct list clients;
+
+    IMMDevice *device;
+
+    float master_vol;
+    UINT32 channel_count;
+    float *channel_vols;
+    BOOL mute;
+
+    struct list entry;
+} AudioSession;
+
+typedef struct _AudioSessionWrapper {
+    IAudioSessionControl2 IAudioSessionControl2_iface;
+    IChannelAudioVolume IChannelAudioVolume_iface;
+    ISimpleAudioVolume ISimpleAudioVolume_iface;
+
+    LONG ref;
+
+    ACImpl *client;
+    AudioSession *session;
+} AudioSessionWrapper;
+
+struct ACImpl {
+    IAudioClient3 IAudioClient3_iface;
+    IAudioRenderClient IAudioRenderClient_iface;
+    IAudioCaptureClient IAudioCaptureClient_iface;
+    IAudioClock IAudioClock_iface;
+    IAudioClock2 IAudioClock2_iface;
+    IAudioStreamVolume IAudioStreamVolume_iface;
+
+    LONG ref;
+
+    IMMDevice *parent;
+    IUnknown *pUnkFTMarshal;
+
+    EDataFlow dataflow;
+    UINT32 channel_count, period_ms;
+    DWORD flags;
+    HANDLE event;
+    float *vols;
+
+    HANDLE timer;
+
+    AudioSession *session;
+    AudioSessionWrapper *session_wrapper;
+
+    stream_handle stream;
+    struct list entry;
+
+    char device_name[1];
+};
+
+static const IAudioClient3Vtbl AudioClient3_Vtbl;
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl;
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl;
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl;
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl;
+static const IAudioClockVtbl AudioClock_Vtbl;
+static const IAudioClock2Vtbl AudioClock2_Vtbl;
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl;
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl;
+static const IAudioSessionManager2Vtbl AudioSessionManager2_Vtbl;
+
+typedef struct _SessionMgr {
+    IAudioSessionManager2 IAudioSessionManager2_iface;
+
+    LONG ref;
+
+    IMMDevice *device;
+} SessionMgr;
+
+static const WCHAR *drv_key_devicesW = L"Software\\Wine\\Drivers\\winecoreaudio.drv\\devices";
+
+static HANDLE g_timer_q;
+
+static CRITICAL_SECTION g_sessions_lock;
+static CRITICAL_SECTION_DEBUG g_sessions_lock_debug =
+{
+    0, 0, &g_sessions_lock,
+    { &g_sessions_lock_debug.ProcessLocksList, &g_sessions_lock_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": g_sessions_lock") }
+};
+static CRITICAL_SECTION g_sessions_lock = { &g_sessions_lock_debug, -1, 0, 0, 0, 0 };
+static struct list g_sessions = LIST_INIT(g_sessions);
+
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client);
+
+static inline ACImpl *impl_from_IAudioClient3(IAudioClient3 *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClient3_iface);
+}
+
+static inline ACImpl *impl_from_IAudioRenderClient(IAudioRenderClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioRenderClient_iface);
+}
+
+static inline ACImpl *impl_from_IAudioCaptureClient(IAudioCaptureClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioCaptureClient_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IAudioSessionControl2(IAudioSessionControl2 *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IAudioSessionControl2_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_ISimpleAudioVolume(ISimpleAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, ISimpleAudioVolume_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IChannelAudioVolume(IChannelAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IChannelAudioVolume_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock(IAudioClock *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock2(IAudioClock2 *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock2_iface);
+}
+
+static inline ACImpl *impl_from_IAudioStreamVolume(IAudioStreamVolume *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioStreamVolume_iface);
+}
+
+static inline SessionMgr *impl_from_IAudioSessionManager2(IAudioSessionManager2 *iface)
+{
+    return CONTAINING_RECORD(iface, SessionMgr, IAudioSessionManager2_iface);
+}
 
 BOOL WINAPI DllMain(HINSTANCE dll, DWORD reason, void *reserved)
 {
     switch (reason)
     {
     case DLL_PROCESS_ATTACH:
-    {
-        WCHAR buf[MAX_PATH];
-        WCHAR *filename;
-
         DisableThreadLibraryCalls(dll);
         if (__wine_init_unix_call())
             return FALSE;
-
-        GetModuleFileNameW(dll, buf, ARRAY_SIZE(buf));
-
-        filename = wcsrchr(buf, '\\');
-        filename = filename ? filename + 1 : buf;
-
-        swprintf(drv_key_devicesW, ARRAY_SIZE(drv_key_devicesW),
-                 L"Software\\Wine\\Drivers\\%s\\devices", filename);
-
+        g_timer_q = CreateTimerQueue();
+        if(!g_timer_q)
+            return FALSE;
         break;
-    }
+
     case DLL_PROCESS_DETACH:
         if (reserved) break;
+        DeleteCriticalSection(&g_sessions_lock);
+        CloseHandle(g_timer_q);
         break;
     }
     return TRUE;
 }
 
+int WINAPI AUDDRV_GetPriority(void)
+{
+    return Priority_Neutral;
+}
+
 static void set_device_guid(EDataFlow flow, HKEY drv_key, const WCHAR *key_name,
         GUID *guid)
 {
@@ -113,7 +253,7 @@ exit:
         RegCloseKey(drv_key);
 }
 
-void WINAPI get_device_guid(EDataFlow flow, const char *dev, GUID *guid)
+static void get_device_guid(EDataFlow flow, const char *dev, GUID *guid)
 {
     HKEY key = NULL, dev_key;
     DWORD type, size = sizeof(*guid);
@@ -151,7 +291,80 @@ void WINAPI get_device_guid(EDataFlow flow, const char *dev, GUID *guid)
         RegCloseKey(key);
 }
 
-BOOL WINAPI get_device_name_from_guid(const GUID *guid, char **name, EDataFlow *flow)
+static void set_stream_volumes(ACImpl *This, int channel)
+{
+    struct set_volumes_params params;
+
+    params.stream = This->stream;
+    params.master_volume = This->session->mute ? 0.0f : This->session->master_vol;
+    params.volumes = This->vols;
+    params.session_volumes = This->session->channel_vols;
+    params.channel = channel;
+
+    UNIX_CALL(set_volumes, &params);
+}
+
+HRESULT WINAPI AUDDRV_GetEndpointIDs(EDataFlow flow, WCHAR ***ids_out,
+        GUID **guids_out, UINT *num, UINT *def_index)
+{
+    struct get_endpoint_ids_params params;
+    unsigned int i;
+    GUID *guids = NULL;
+    WCHAR **ids = NULL;
+
+    TRACE("%d %p %p %p\n", flow, ids_out, num, def_index);
+
+    params.flow = flow;
+    params.size = 1000;
+    params.endpoints = NULL;
+    do{
+        heap_free(params.endpoints);
+        params.endpoints = heap_alloc(params.size);
+        UNIX_CALL(get_endpoint_ids, &params);
+    }while(params.result == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
+
+    if(FAILED(params.result)) goto end;
+
+    ids = heap_alloc_zero(params.num * sizeof(*ids));
+    guids = heap_alloc(params.num * sizeof(*guids));
+    if(!ids || !guids){
+        params.result = E_OUTOFMEMORY;
+        goto end;
+    }
+
+    for(i = 0; i < params.num; i++){
+        const WCHAR *name = (WCHAR *)((char *)params.endpoints + params.endpoints[i].name);
+        const char *device = (char *)params.endpoints + params.endpoints[i].device;
+        const unsigned int size = (wcslen(name) + 1) * sizeof(WCHAR);
+
+        ids[i] = heap_alloc(size);
+        if(!ids[i]){
+            params.result = E_OUTOFMEMORY;
+            goto end;
+        }
+        memcpy(ids[i], name, size);
+        get_device_guid(flow, device, guids + i);
+    }
+    *def_index = params.default_idx;
+
+end:
+    heap_free(params.endpoints);
+    if(FAILED(params.result)){
+        heap_free(guids);
+        if(ids){
+            for(i = 0; i < params.num; i++) heap_free(ids[i]);
+            heap_free(ids);
+        }
+    }else{
+        *ids_out = ids;
+        *guids_out = guids;
+        *num = params.num;
+    }
+
+    return params.result;
+}
+
+static BOOL get_device_name_by_guid(const GUID *guid, char *name, const SIZE_T name_size, EDataFlow *flow)
 {
     HKEY devices_key;
     UINT i = 0;
@@ -196,16 +409,7 @@ BOOL WINAPI get_device_name_from_guid(const GUID *guid, char **name, EDataFlow *
                     return FALSE;
                 }
 
-                if(!(size = WideCharToMultiByte(CP_UNIXCP, 0, key_name + 2, -1, NULL, 0, NULL, NULL)))
-                    return FALSE;
-
-                if(!(*name = malloc(size)))
-                    return FALSE;
-
-                if(!WideCharToMultiByte(CP_UNIXCP, 0, key_name + 2, -1, *name, size, NULL, NULL)){
-                    free(*name);
-                    return FALSE;
-                }
+                WideCharToMultiByte(CP_UNIXCP, 0, key_name + 2, -1, name, name_size, NULL, NULL);
 
                 return TRUE;
             }
@@ -220,3 +424,1991 @@ BOOL WINAPI get_device_name_from_guid(const GUID *guid, char **name, EDataFlow *
 
     return FALSE;
 }
+
+HRESULT WINAPI AUDDRV_GetAudioEndpoint(GUID *guid, IMMDevice *dev, IAudioClient **out)
+{
+    ACImpl *This;
+    char name[256];
+    SIZE_T name_len;
+    EDataFlow dataflow;
+    HRESULT hr;
+
+    TRACE("%s %p %p\n", debugstr_guid(guid), dev, out);
+
+    if(!get_device_name_by_guid(guid, name, sizeof(name), &dataflow))
+        return AUDCLNT_E_DEVICE_INVALIDATED;
+
+    if(dataflow != eRender && dataflow != eCapture)
+        return E_INVALIDARG;
+
+    name_len = strlen(name);
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, offsetof(ACImpl, device_name[name_len + 1]));
+    if(!This)
+        return E_OUTOFMEMORY;
+
+    This->IAudioClient3_iface.lpVtbl = &AudioClient3_Vtbl;
+    This->IAudioRenderClient_iface.lpVtbl = &AudioRenderClient_Vtbl;
+    This->IAudioCaptureClient_iface.lpVtbl = &AudioCaptureClient_Vtbl;
+    This->IAudioClock_iface.lpVtbl = &AudioClock_Vtbl;
+    This->IAudioClock2_iface.lpVtbl = &AudioClock2_Vtbl;
+    This->IAudioStreamVolume_iface.lpVtbl = &AudioStreamVolume_Vtbl;
+
+    This->dataflow = dataflow;
+    memcpy(This->device_name, name, name_len + 1);
+
+    hr = CoCreateFreeThreadedMarshaler((IUnknown *)&This->IAudioClient3_iface, &This->pUnkFTMarshal);
+    if (FAILED(hr)) {
+        HeapFree(GetProcessHeap(), 0, This);
+        return hr;
+    }
+
+    This->parent = dev;
+    IMMDevice_AddRef(This->parent);
+
+    *out = (IAudioClient *)&This->IAudioClient3_iface;
+    IAudioClient3_AddRef(&This->IAudioClient3_iface);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_QueryInterface(IAudioClient3 *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioClient) ||
+            IsEqualIID(riid, &IID_IAudioClient2) ||
+            IsEqualIID(riid, &IID_IAudioClient3))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->pUnkFTMarshal, riid, ppv);
+
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClient_AddRef(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioClient_Release(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct release_stream_params params;
+    ULONG ref;
+
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    if(!ref){
+        if(This->timer){
+            HANDLE event;
+            BOOL wait;
+            event = CreateEventW(NULL, TRUE, FALSE, NULL);
+            wait = !DeleteTimerQueueTimer(g_timer_q, This->timer, event);
+            wait = wait && GetLastError() == ERROR_IO_PENDING;
+            if(event && wait)
+                WaitForSingleObject(event, INFINITE);
+            CloseHandle(event);
+        }
+        if(This->stream){
+            params.stream = This->stream;
+            params.timer_thread = NULL;
+            UNIX_CALL(release_stream, &params);
+        }
+        if(This->session){
+            EnterCriticalSection(&g_sessions_lock);
+            list_remove(&This->entry);
+            LeaveCriticalSection(&g_sessions_lock);
+        }
+        HeapFree(GetProcessHeap(), 0, This->vols);
+        IMMDevice_Release(This->parent);
+        IUnknown_Release(This->pUnkFTMarshal);
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static void dump_fmt(const WAVEFORMATEX *fmt)
+{
+    TRACE("wFormatTag: 0x%x (", fmt->wFormatTag);
+    switch(fmt->wFormatTag){
+    case WAVE_FORMAT_PCM:
+        TRACE("WAVE_FORMAT_PCM");
+        break;
+    case WAVE_FORMAT_IEEE_FLOAT:
+        TRACE("WAVE_FORMAT_IEEE_FLOAT");
+        break;
+    case WAVE_FORMAT_EXTENSIBLE:
+        TRACE("WAVE_FORMAT_EXTENSIBLE");
+        break;
+    default:
+        TRACE("Unknown");
+        break;
+    }
+    TRACE(")\n");
+
+    TRACE("nChannels: %u\n", fmt->nChannels);
+    TRACE("nSamplesPerSec: %lu\n", fmt->nSamplesPerSec);
+    TRACE("nAvgBytesPerSec: %lu\n", fmt->nAvgBytesPerSec);
+    TRACE("nBlockAlign: %u\n", fmt->nBlockAlign);
+    TRACE("wBitsPerSample: %u\n", fmt->wBitsPerSample);
+    TRACE("cbSize: %u\n", fmt->cbSize);
+
+    if(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE){
+        WAVEFORMATEXTENSIBLE *fmtex = (void*)fmt;
+        TRACE("dwChannelMask: %08lx\n", fmtex->dwChannelMask);
+        TRACE("Samples: %04x\n", fmtex->Samples.wReserved);
+        TRACE("SubFormat: %s\n", wine_dbgstr_guid(&fmtex->SubFormat));
+    }
+}
+
+static void session_init_vols(AudioSession *session, UINT channels)
+{
+    if(session->channel_count < channels){
+        UINT i;
+
+        if(session->channel_vols)
+            session->channel_vols = HeapReAlloc(GetProcessHeap(), 0,
+                    session->channel_vols, sizeof(float) * channels);
+        else
+            session->channel_vols = HeapAlloc(GetProcessHeap(), 0,
+                    sizeof(float) * channels);
+        if(!session->channel_vols)
+            return;
+
+        for(i = session->channel_count; i < channels; ++i)
+            session->channel_vols[i] = 1.f;
+
+        session->channel_count = channels;
+    }
+}
+
+static AudioSession *create_session(const GUID *guid, IMMDevice *device,
+        UINT num_channels)
+{
+    AudioSession *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(AudioSession));
+    if(!ret)
+        return NULL;
+
+    memcpy(&ret->guid, guid, sizeof(GUID));
+
+    ret->device = device;
+
+    list_init(&ret->clients);
+
+    list_add_head(&g_sessions, &ret->entry);
+
+    session_init_vols(ret, num_channels);
+
+    ret->master_vol = 1.f;
+
+    return ret;
+}
+
+/* if channels == 0, then this will return or create a session with
+ * matching dataflow and GUID. otherwise, channels must also match */
+static HRESULT get_audio_session(const GUID *sessionguid,
+        IMMDevice *device, UINT channels, AudioSession **out)
+{
+    AudioSession *session;
+
+    if(!sessionguid || IsEqualGUID(sessionguid, &GUID_NULL)){
+        *out = create_session(&GUID_NULL, device, channels);
+        if(!*out)
+            return E_OUTOFMEMORY;
+
+        return S_OK;
+    }
+
+    *out = NULL;
+    LIST_FOR_EACH_ENTRY(session, &g_sessions, AudioSession, entry){
+        if(session->device == device &&
+                IsEqualGUID(sessionguid, &session->guid)){
+            session_init_vols(session, channels);
+            *out = session;
+            break;
+        }
+    }
+
+    if(!*out){
+        *out = create_session(sessionguid, device, channels);
+        if(!*out)
+            return E_OUTOFMEMORY;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Initialize(IAudioClient3 *iface,
+        AUDCLNT_SHAREMODE mode, DWORD flags, REFERENCE_TIME duration,
+        REFERENCE_TIME period, const WAVEFORMATEX *fmt,
+        const GUID *sessionguid)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct release_stream_params release_params;
+    struct create_stream_params params;
+    stream_handle stream;
+    UINT32 i;
+
+    TRACE("(%p)->(%x, %lx, %s, %s, %p, %s)\n", This, mode, flags,
+          wine_dbgstr_longlong(duration), wine_dbgstr_longlong(period), fmt, debugstr_guid(sessionguid));
+
+    if(!fmt)
+        return E_POINTER;
+
+    dump_fmt(fmt);
+
+    if(mode != AUDCLNT_SHAREMODE_SHARED && mode != AUDCLNT_SHAREMODE_EXCLUSIVE)
+        return E_INVALIDARG;
+
+    if(flags & ~(AUDCLNT_STREAMFLAGS_CROSSPROCESS |
+                AUDCLNT_STREAMFLAGS_LOOPBACK |
+                AUDCLNT_STREAMFLAGS_EVENTCALLBACK |
+                AUDCLNT_STREAMFLAGS_NOPERSIST |
+                AUDCLNT_STREAMFLAGS_RATEADJUST |
+                AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED |
+                AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY |
+                AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM)){
+        FIXME("Unknown flags: %08lx\n", flags);
+        return E_INVALIDARG;
+    }
+
+    if(mode == AUDCLNT_SHAREMODE_SHARED){
+        period = DefaultPeriod;
+        if( duration < 3 * period)
+            duration = 3 * period;
+    }else{
+        if(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE){
+            if(((WAVEFORMATEXTENSIBLE*)fmt)->dwChannelMask == 0 ||
+                    ((WAVEFORMATEXTENSIBLE*)fmt)->dwChannelMask & SPEAKER_RESERVED)
+                return AUDCLNT_E_UNSUPPORTED_FORMAT;
+        }
+
+        if(!period)
+            period = DefaultPeriod; /* not minimum */
+        if(period < MinimumPeriod || period > 5000000)
+            return AUDCLNT_E_INVALID_DEVICE_PERIOD;
+        if(duration > 20000000) /* the smaller the period, the lower this limit */
+            return AUDCLNT_E_BUFFER_SIZE_ERROR;
+        if(flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK){
+            if(duration != period)
+                return AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
+            FIXME("EXCLUSIVE mode with EVENTCALLBACK\n");
+            return AUDCLNT_E_DEVICE_IN_USE;
+        }else{
+            if( duration < 8 * period)
+                duration = 8 * period; /* may grow above 2s */
+        }
+    }
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(This->stream){
+        LeaveCriticalSection(&g_sessions_lock);
+        return AUDCLNT_E_ALREADY_INITIALIZED;
+    }
+
+    params.name = NULL;
+    params.device = This->device_name;
+    params.flow = This->dataflow;
+    params.share = mode;
+    params.flags = flags;
+    params.duration = duration;
+    params.period = period;
+    params.fmt = fmt;
+    params.channel_count = NULL;
+    params.stream = &stream;
+
+    UNIX_CALL(create_stream, &params);
+    if(FAILED(params.result)){
+        LeaveCriticalSection(&g_sessions_lock);
+        return params.result;
+    }
+
+    This->flags = flags;
+    This->channel_count = fmt->nChannels;
+    This->period_ms = period / 10000;
+
+    This->vols = HeapAlloc(GetProcessHeap(), 0, This->channel_count * sizeof(float));
+    if(!This->vols){
+        params.result = E_OUTOFMEMORY;
+        goto end;
+    }
+
+    for(i = 0; i < This->channel_count; ++i)
+        This->vols[i] = 1.f;
+
+    params.result = get_audio_session(sessionguid, This->parent, fmt->nChannels, &This->session);
+    if(FAILED(params.result)) goto end;
+
+    list_add_tail(&This->session->clients, &This->entry);
+
+end:
+    if(FAILED(params.result)){
+        release_params.stream = stream;
+        UNIX_CALL(release_stream, &release_params);
+        HeapFree(GetProcessHeap(), 0, This->vols);
+        This->vols = NULL;
+    }else{
+        This->stream = stream;
+        set_stream_volumes(This, -1);
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetBufferSize(IAudioClient3 *iface,
+        UINT32 *frames)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_buffer_size_params params;
+
+    TRACE("(%p)->(%p)\n", This, frames);
+
+    if(!frames)
+        return E_POINTER;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    params.frames = frames;
+    UNIX_CALL(get_buffer_size, &params);
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetStreamLatency(IAudioClient3 *iface,
+        REFERENCE_TIME *out)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_latency_params params;
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if(!out)
+        return E_POINTER;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    params.latency = out;
+    UNIX_CALL(get_latency, &params);
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetCurrentPadding(IAudioClient3 *iface,
+        UINT32 *numpad)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_current_padding_params params;
+
+    TRACE("(%p)->(%p)\n", This, numpad);
+
+    if(!numpad)
+        return E_POINTER;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    params.padding = numpad;
+    UNIX_CALL(get_current_padding, &params);
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_IsFormatSupported(IAudioClient3 *iface,
+        AUDCLNT_SHAREMODE mode, const WAVEFORMATEX *pwfx,
+        WAVEFORMATEX **outpwfx)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct is_format_supported_params params;
+
+    TRACE("(%p)->(%x, %p, %p)\n", This, mode, pwfx, outpwfx);
+    if(pwfx) dump_fmt(pwfx);
+
+    params.device = This->device_name;
+    params.flow = This->dataflow;
+    params.share = mode;
+    params.fmt_in = pwfx;
+    params.fmt_out = NULL;
+
+    if(outpwfx){
+        *outpwfx = NULL;
+        if(mode == AUDCLNT_SHAREMODE_SHARED)
+            params.fmt_out = CoTaskMemAlloc(sizeof(*params.fmt_out));
+    }
+    UNIX_CALL(is_format_supported, &params);
+
+    if(params.result == S_FALSE)
+        *outpwfx = &params.fmt_out->Format;
+    else
+        CoTaskMemFree(params.fmt_out);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetMixFormat(IAudioClient3 *iface,
+        WAVEFORMATEX **pwfx)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_mix_format_params params;
+
+    TRACE("(%p)->(%p)\n", This, pwfx);
+
+    if(!pwfx)
+        return E_POINTER;
+    *pwfx = NULL;
+
+    params.device = This->device_name;
+    params.flow = This->dataflow;
+    params.fmt = CoTaskMemAlloc(sizeof(WAVEFORMATEXTENSIBLE));
+    if(!params.fmt)
+        return E_OUTOFMEMORY;
+
+    UNIX_CALL(get_mix_format, &params);
+
+    if(SUCCEEDED(params.result)){
+        *pwfx = &params.fmt->Format;
+        dump_fmt(*pwfx);
+    }else
+        CoTaskMemFree(params.fmt);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetDevicePeriod(IAudioClient3 *iface,
+        REFERENCE_TIME *defperiod, REFERENCE_TIME *minperiod)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    TRACE("(%p)->(%p, %p)\n", This, defperiod, minperiod);
+
+    if(!defperiod && !minperiod)
+        return E_POINTER;
+
+    if(defperiod)
+        *defperiod = DefaultPeriod;
+    if(minperiod)
+        *minperiod = MinimumPeriod;
+
+    return S_OK;
+}
+
+void CALLBACK ca_period_cb(void *user, BOOLEAN timer)
+{
+    ACImpl *This = user;
+
+    if(This->event)
+        SetEvent(This->event);
+}
+
+static HRESULT WINAPI AudioClient_Start(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct start_params params;
+
+    TRACE("(%p)\n", This);
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    if((This->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) && !This->event)
+        return AUDCLNT_E_EVENTHANDLE_NOT_SET;
+
+    params.stream = This->stream;
+    UNIX_CALL(start, &params);
+
+    if(SUCCEEDED(params.result)){
+        if(This->event && !This->timer){
+            if(!CreateTimerQueueTimer(&This->timer, g_timer_q, ca_period_cb, This, 0,
+                                      This->period_ms, WT_EXECUTEINTIMERTHREAD)){
+                This->timer = NULL;
+                IAudioClient3_Stop(iface);
+                WARN("Unable to create timer: %lu\n", GetLastError());
+                return E_OUTOFMEMORY;
+            }
+        }
+    }
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_Stop(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct stop_params params;
+
+    TRACE("(%p)\n", This);
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    UNIX_CALL(stop, &params);
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_Reset(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct reset_params params;
+
+    TRACE("(%p)\n", This);
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    UNIX_CALL(reset, &params);
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_SetEventHandle(IAudioClient3 *iface,
+        HANDLE event)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("(%p)->(%p)\n", This, event);
+
+    if(!event)
+        return E_INVALIDARG;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(!(This->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK))
+        hr = AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED;
+    else if(This->event){
+        FIXME("called twice\n");
+        hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
+    }else
+        This->event = event;
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetService(IAudioClient3 *iface, REFIID riid,
+        void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(IsEqualIID(riid, &IID_IAudioRenderClient)){
+        if(This->dataflow != eRender){
+            hr = AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+            goto end;
+        }
+        IAudioRenderClient_AddRef(&This->IAudioRenderClient_iface);
+        *ppv = &This->IAudioRenderClient_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioCaptureClient)){
+        if(This->dataflow != eCapture){
+            hr = AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+            goto end;
+        }
+        IAudioCaptureClient_AddRef(&This->IAudioCaptureClient_iface);
+        *ppv = &This->IAudioCaptureClient_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioClock)){
+        IAudioClock_AddRef(&This->IAudioClock_iface);
+        *ppv = &This->IAudioClock_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioStreamVolume)){
+        IAudioStreamVolume_AddRef(&This->IAudioStreamVolume_iface);
+        *ppv = &This->IAudioStreamVolume_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioSessionControl)){
+        if(!This->session_wrapper){
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if(!This->session_wrapper){
+                hr = E_OUTOFMEMORY;
+                goto end;
+            }
+        }else
+            IAudioSessionControl2_AddRef(&This->session_wrapper->IAudioSessionControl2_iface);
+
+        *ppv = &This->session_wrapper->IAudioSessionControl2_iface;
+    }else if(IsEqualIID(riid, &IID_IChannelAudioVolume)){
+        if(!This->session_wrapper){
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if(!This->session_wrapper){
+                hr = E_OUTOFMEMORY;
+                goto end;
+            }
+        }else
+            IChannelAudioVolume_AddRef(&This->session_wrapper->IChannelAudioVolume_iface);
+
+        *ppv = &This->session_wrapper->IChannelAudioVolume_iface;
+    }else if(IsEqualIID(riid, &IID_ISimpleAudioVolume)){
+        if(!This->session_wrapper){
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if(!This->session_wrapper){
+                hr = E_OUTOFMEMORY;
+                goto end;
+            }
+        }else
+            ISimpleAudioVolume_AddRef(&This->session_wrapper->ISimpleAudioVolume_iface);
+
+        *ppv = &This->session_wrapper->ISimpleAudioVolume_iface;
+    }
+
+    if(*ppv) hr = S_OK;
+    else{
+        FIXME("stub %s\n", debugstr_guid(riid));
+        hr = E_NOINTERFACE;
+    }
+
+end:
+    LeaveCriticalSection(&g_sessions_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_IsOffloadCapable(IAudioClient3 *iface,
+        AUDIO_STREAM_CATEGORY category, BOOL *offload_capable)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    TRACE("(%p)->(0x%x, %p)\n", This, category, offload_capable);
+
+    if(!offload_capable)
+        return E_INVALIDARG;
+
+    *offload_capable = FALSE;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_SetClientProperties(IAudioClient3 *iface,
+        const AudioClientProperties *prop)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    const Win8AudioClientProperties *legacy_prop = (const Win8AudioClientProperties *)prop;
+
+    TRACE("(%p)->(%p)\n", This, prop);
+
+    if(!legacy_prop)
+        return E_POINTER;
+
+    if(legacy_prop->cbSize == sizeof(AudioClientProperties)){
+        TRACE("{ bIsOffload: %u, eCategory: 0x%x, Options: 0x%x }\n",
+                legacy_prop->bIsOffload,
+                legacy_prop->eCategory,
+                prop->Options);
+    }else if(legacy_prop->cbSize == sizeof(Win8AudioClientProperties)){
+        TRACE("{ bIsOffload: %u, eCategory: 0x%x }\n",
+                legacy_prop->bIsOffload,
+                legacy_prop->eCategory);
+    }else{
+        WARN("Unsupported Size = %d\n", legacy_prop->cbSize);
+        return E_INVALIDARG;
+    }
+
+
+    if(legacy_prop->bIsOffload)
+        return AUDCLNT_E_ENDPOINT_OFFLOAD_NOT_CAPABLE;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_GetBufferSizeLimits(IAudioClient3 *iface,
+        const WAVEFORMATEX *format, BOOL event_driven, REFERENCE_TIME *min_duration,
+        REFERENCE_TIME *max_duration)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(%p, %u, %p, %p)\n", This, format, event_driven, min_duration, max_duration);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioClient_GetSharedModeEnginePeriod(IAudioClient3 *iface,
+        const WAVEFORMATEX *format, UINT32 *default_period_frames, UINT32 *unit_period_frames,
+        UINT32 *min_period_frames, UINT32 *max_period_frames)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(%p, %p, %p, %p, %p)\n", This, format, default_period_frames, unit_period_frames,
+            min_period_frames, max_period_frames);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioClient_GetCurrentSharedModeEnginePeriod(IAudioClient3 *iface,
+        WAVEFORMATEX **cur_format, UINT32 *cur_period_frames)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(%p, %p)\n", This, cur_format, cur_period_frames);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioClient_InitializeSharedAudioStream(IAudioClient3 *iface,
+        DWORD flags, UINT32 period_frames, const WAVEFORMATEX *format,
+        const GUID *session_guid)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(0x%lx, %u, %p, %s)\n", This, flags, period_frames, format, debugstr_guid(session_guid));
+
+    return E_NOTIMPL;
+}
+
+static const IAudioClient3Vtbl AudioClient3_Vtbl =
+{
+    AudioClient_QueryInterface,
+    AudioClient_AddRef,
+    AudioClient_Release,
+    AudioClient_Initialize,
+    AudioClient_GetBufferSize,
+    AudioClient_GetStreamLatency,
+    AudioClient_GetCurrentPadding,
+    AudioClient_IsFormatSupported,
+    AudioClient_GetMixFormat,
+    AudioClient_GetDevicePeriod,
+    AudioClient_Start,
+    AudioClient_Stop,
+    AudioClient_Reset,
+    AudioClient_SetEventHandle,
+    AudioClient_GetService,
+    AudioClient_IsOffloadCapable,
+    AudioClient_SetClientProperties,
+    AudioClient_GetBufferSizeLimits,
+    AudioClient_GetSharedModeEnginePeriod,
+    AudioClient_GetCurrentSharedModeEnginePeriod,
+    AudioClient_InitializeSharedAudioStream,
+};
+
+static HRESULT WINAPI AudioRenderClient_QueryInterface(
+        IAudioRenderClient *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioRenderClient))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->pUnkFTMarshal, riid, ppv);
+
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioRenderClient_AddRef(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioRenderClient_Release(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioRenderClient_GetBuffer(IAudioRenderClient *iface,
+        UINT32 frames, BYTE **data)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    struct get_render_buffer_params params;
+
+    TRACE("(%p)->(%u, %p)\n", This, frames, data);
+
+    if(!data)
+        return E_POINTER;
+    *data = NULL;
+
+    params.stream = This->stream;
+    params.frames = frames;
+    params.data = data;
+    UNIX_CALL(get_render_buffer, &params);
+    return params.result;
+}
+
+static HRESULT WINAPI AudioRenderClient_ReleaseBuffer(
+        IAudioRenderClient *iface, UINT32 frames, DWORD flags)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    struct release_render_buffer_params params;
+
+    TRACE("(%p)->(%u, %lx)\n", This, frames, flags);
+
+    params.stream = This->stream;
+    params.written_frames = frames;
+    params.flags = flags;
+    UNIX_CALL(release_render_buffer, &params);
+    return params.result;
+}
+
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl = {
+    AudioRenderClient_QueryInterface,
+    AudioRenderClient_AddRef,
+    AudioRenderClient_Release,
+    AudioRenderClient_GetBuffer,
+    AudioRenderClient_ReleaseBuffer
+};
+
+static HRESULT WINAPI AudioCaptureClient_QueryInterface(
+        IAudioCaptureClient *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioCaptureClient))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->pUnkFTMarshal, riid, ppv);
+
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioCaptureClient_AddRef(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioCaptureClient_Release(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetBuffer(IAudioCaptureClient *iface,
+        BYTE **data, UINT32 *frames, DWORD *flags, UINT64 *devpos,
+        UINT64 *qpcpos)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    struct get_capture_buffer_params params;
+
+    TRACE("(%p)->(%p, %p, %p, %p, %p)\n", This, data, frames, flags,
+            devpos, qpcpos);
+
+    if(!data)
+        return E_POINTER;
+
+    *data = NULL;
+
+    if(!frames || !flags)
+        return E_POINTER;
+
+    params.stream = This->stream;
+    params.data = data;
+    params.frames = frames;
+    params.flags = (UINT *)flags;
+    params.devpos = devpos;
+    params.qpcpos = qpcpos;
+    UNIX_CALL(get_capture_buffer, &params);
+    return params.result;
+}
+
+static HRESULT WINAPI AudioCaptureClient_ReleaseBuffer(
+        IAudioCaptureClient *iface, UINT32 done)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    struct release_capture_buffer_params params;
+
+    TRACE("(%p)->(%u)\n", This, done);
+
+    params.stream = This->stream;
+    params.done = done;
+    UNIX_CALL(release_capture_buffer, &params);
+    return params.result;
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetNextPacketSize(
+        IAudioCaptureClient *iface, UINT32 *frames)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    struct get_next_packet_size_params params;
+
+    TRACE("(%p)->(%p)\n", This, frames);
+
+    if(!frames)
+        return E_POINTER;
+
+    params.stream = This->stream;
+    params.frames = frames;
+    UNIX_CALL(get_next_packet_size, &params);
+    return params.result;
+}
+
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl =
+{
+    AudioCaptureClient_QueryInterface,
+    AudioCaptureClient_AddRef,
+    AudioCaptureClient_Release,
+    AudioCaptureClient_GetBuffer,
+    AudioCaptureClient_ReleaseBuffer,
+    AudioCaptureClient_GetNextPacketSize
+};
+
+static HRESULT WINAPI AudioClock_QueryInterface(IAudioClock *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IAudioClock))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IAudioClock2))
+        *ppv = &This->IAudioClock2_iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClock_AddRef(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioClock_Release(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioClock_GetFrequency(IAudioClock *iface, UINT64 *freq)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    struct get_frequency_params params;
+
+    TRACE("(%p)->(%p)\n", This, freq);
+
+    params.stream = This->stream;
+    params.freq = freq;
+    UNIX_CALL(get_frequency, &params);
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClock_GetPosition(IAudioClock *iface, UINT64 *pos,
+        UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    struct get_position_params params;
+
+    TRACE("(%p)->(%p, %p)\n", This, pos, qpctime);
+
+    if(!pos)
+        return E_POINTER;
+
+    params.stream = This->stream;
+    params.pos = pos;
+    params.qpctime = qpctime;
+    UNIX_CALL(get_position, &params);
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClock_GetCharacteristics(IAudioClock *iface,
+        DWORD *chars)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%p)\n", This, chars);
+
+    if(!chars)
+        return E_POINTER;
+
+    *chars = AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ;
+
+    return S_OK;
+}
+
+static const IAudioClockVtbl AudioClock_Vtbl =
+{
+    AudioClock_QueryInterface,
+    AudioClock_AddRef,
+    AudioClock_Release,
+    AudioClock_GetFrequency,
+    AudioClock_GetPosition,
+    AudioClock_GetCharacteristics
+};
+
+static HRESULT WINAPI AudioClock2_QueryInterface(IAudioClock2 *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClock_QueryInterface(&This->IAudioClock_iface, riid, ppv);
+}
+
+static ULONG WINAPI AudioClock2_AddRef(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioClock2_Release(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioClock2_GetDevicePosition(IAudioClock2 *iface,
+        UINT64 *pos, UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+
+    FIXME("(%p)->(%p, %p)\n", This, pos, qpctime);
+
+    return E_NOTIMPL;
+}
+
+static const IAudioClock2Vtbl AudioClock2_Vtbl =
+{
+    AudioClock2_QueryInterface,
+    AudioClock2_AddRef,
+    AudioClock2_Release,
+    AudioClock2_GetDevicePosition
+};
+
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client)
+{
+    AudioSessionWrapper *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(AudioSessionWrapper));
+    if(!ret)
+        return NULL;
+
+    ret->IAudioSessionControl2_iface.lpVtbl = &AudioSessionControl2_Vtbl;
+    ret->ISimpleAudioVolume_iface.lpVtbl = &SimpleAudioVolume_Vtbl;
+    ret->IChannelAudioVolume_iface.lpVtbl = &ChannelAudioVolume_Vtbl;
+
+    ret->ref = 1;
+
+    ret->client = client;
+    if(client){
+        ret->session = client->session;
+        IAudioClient3_AddRef(&client->IAudioClient3_iface);
+    }
+
+    return ret;
+}
+
+static HRESULT WINAPI AudioSessionControl_QueryInterface(
+        IAudioSessionControl2 *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioSessionControl) ||
+            IsEqualIID(riid, &IID_IAudioSessionControl2))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioSessionControl_AddRef(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionControl_Release(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    if(!ref){
+        if(This->client){
+            This->client->session_wrapper = NULL;
+            AudioClient_Release(&This->client->IAudioClient3_iface);
+        }
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetState(IAudioSessionControl2 *iface,
+        AudioSessionState *state)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    struct is_started_params params;
+    ACImpl *client;
+
+    TRACE("(%p)->(%p)\n", This, state);
+
+    if(!state)
+        return NULL_PTR_ERR;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(list_empty(&This->session->clients)){
+        *state = AudioSessionStateExpired;
+        LeaveCriticalSection(&g_sessions_lock);
+        return S_OK;
+    }
+
+    LIST_FOR_EACH_ENTRY(client, &This->session->clients, ACImpl, entry){
+        params.stream = client->stream;
+        UNIX_CALL(is_started, &params);
+        if(params.result == S_OK){
+            *state = AudioSessionStateActive;
+            LeaveCriticalSection(&g_sessions_lock);
+            return S_OK;
+        }
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    *state = AudioSessionStateInactive;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetDisplayName(
+        IAudioSessionControl2 *iface, WCHAR **name)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, name);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDisplayName(
+        IAudioSessionControl2 *iface, const WCHAR *name, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, name, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetIconPath(
+        IAudioSessionControl2 *iface, WCHAR **path)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, path);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetIconPath(
+        IAudioSessionControl2 *iface, const WCHAR *path, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, path, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetGroupingParam(
+        IAudioSessionControl2 *iface, GUID *group)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, group);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetGroupingParam(
+        IAudioSessionControl2 *iface, const GUID *group, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%s, %s) - stub\n", This, debugstr_guid(group),
+            debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_RegisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_UnregisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionInstanceIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetProcessId(
+        IAudioSessionControl2 *iface, DWORD *pid)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%p)\n", This, pid);
+
+    if(!pid)
+        return E_POINTER;
+
+    *pid = GetCurrentProcessId();
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_IsSystemSoundsSession(
+        IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)\n", This);
+
+    return S_FALSE;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDuckingPreference(
+        IAudioSessionControl2 *iface, BOOL optout)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%d)\n", This, optout);
+
+    return S_OK;
+}
+
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl =
+{
+    AudioSessionControl_QueryInterface,
+    AudioSessionControl_AddRef,
+    AudioSessionControl_Release,
+    AudioSessionControl_GetState,
+    AudioSessionControl_GetDisplayName,
+    AudioSessionControl_SetDisplayName,
+    AudioSessionControl_GetIconPath,
+    AudioSessionControl_SetIconPath,
+    AudioSessionControl_GetGroupingParam,
+    AudioSessionControl_SetGroupingParam,
+    AudioSessionControl_RegisterAudioSessionNotification,
+    AudioSessionControl_UnregisterAudioSessionNotification,
+    AudioSessionControl_GetSessionIdentifier,
+    AudioSessionControl_GetSessionInstanceIdentifier,
+    AudioSessionControl_GetProcessId,
+    AudioSessionControl_IsSystemSoundsSession,
+    AudioSessionControl_SetDuckingPreference
+};
+
+static HRESULT WINAPI SimpleAudioVolume_QueryInterface(
+        ISimpleAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_ISimpleAudioVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI SimpleAudioVolume_AddRef(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI SimpleAudioVolume_Release(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMasterVolume(
+        ISimpleAudioVolume *iface, float level, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+    ACImpl *client;
+
+    TRACE("(%p)->(%f, %s)\n", session, level, wine_dbgstr_guid(context));
+
+    if(level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    session->master_vol = level;
+
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client, -1);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMasterVolume(
+        ISimpleAudioVolume *iface, float *level)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, level);
+
+    if(!level)
+        return NULL_PTR_ERR;
+
+    *level = session->master_vol;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMute(ISimpleAudioVolume *iface,
+        BOOL mute, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+    ACImpl *client;
+
+    TRACE("(%p)->(%u, %s)\n", session, mute, debugstr_guid(context));
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    session->mute = mute;
+
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client, -1);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMute(ISimpleAudioVolume *iface,
+        BOOL *mute)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, mute);
+
+    if(!mute)
+        return NULL_PTR_ERR;
+
+    *mute = session->mute;
+
+    return S_OK;
+}
+
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl  =
+{
+    SimpleAudioVolume_QueryInterface,
+    SimpleAudioVolume_AddRef,
+    SimpleAudioVolume_Release,
+    SimpleAudioVolume_SetMasterVolume,
+    SimpleAudioVolume_GetMasterVolume,
+    SimpleAudioVolume_SetMute,
+    SimpleAudioVolume_GetMute
+};
+
+static HRESULT WINAPI AudioStreamVolume_QueryInterface(
+        IAudioStreamVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioStreamVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioStreamVolume_AddRef(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioStreamVolume_Release(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelCount(
+        IAudioStreamVolume *iface, UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if(!out)
+        return E_POINTER;
+
+    *out = This->channel_count;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_SetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%d, %f)\n", This, index, level);
+
+    if(level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if(index >= This->channel_count)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    This->vols[index] = level;
+
+    WARN("CoreAudio doesn't support per-channel volume control\n");
+    set_stream_volumes(This, index);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float *level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%d, %p)\n", This, index, level);
+
+    if(!level)
+        return E_POINTER;
+
+    if(index >= This->channel_count)
+        return E_INVALIDARG;
+
+    *level = This->vols[index];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_SetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, const float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    UINT32 i;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if(!levels)
+        return E_POINTER;
+
+    if(count != This->channel_count)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    for(i = 0; i < count; ++i)
+        This->vols[i] = levels[i];
+
+    set_stream_volumes(This, -1);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    UINT32 i;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if(!levels)
+        return E_POINTER;
+
+    if(count != This->channel_count)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    for(i = 0; i < count; ++i)
+        levels[i] = This->vols[i];
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl =
+{
+    AudioStreamVolume_QueryInterface,
+    AudioStreamVolume_AddRef,
+    AudioStreamVolume_Release,
+    AudioStreamVolume_GetChannelCount,
+    AudioStreamVolume_SetChannelVolume,
+    AudioStreamVolume_GetChannelVolume,
+    AudioStreamVolume_SetAllVolumes,
+    AudioStreamVolume_GetAllVolumes
+};
+
+static HRESULT WINAPI ChannelAudioVolume_QueryInterface(
+        IChannelAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IChannelAudioVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI ChannelAudioVolume_AddRef(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI ChannelAudioVolume_Release(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelCount(
+        IChannelAudioVolume *iface, UINT32 *out)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, out);
+
+    if(!out)
+        return NULL_PTR_ERR;
+
+    *out = session->channel_count;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float level,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    ACImpl *client;
+
+    TRACE("(%p)->(%d, %f, %s)\n", session, index, level,
+            wine_dbgstr_guid(context));
+
+    if(level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if(index >= session->channel_count)
+        return E_INVALIDARG;
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    session->channel_vols[index] = level;
+
+    WARN("CoreAudio doesn't support per-channel volume control\n");
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client, index);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float *level)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%d, %p)\n", session, index, level);
+
+    if(!level)
+        return NULL_PTR_ERR;
+
+    if(index >= session->channel_count)
+        return E_INVALIDARG;
+
+    *level = session->channel_vols[index];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, const float *levels,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    ACImpl *client;
+    UINT32 i;
+
+    TRACE("(%p)->(%d, %p, %s)\n", session, count, levels,
+            wine_dbgstr_guid(context));
+
+    if(!levels)
+        return NULL_PTR_ERR;
+
+    if(count != session->channel_count)
+        return E_INVALIDARG;
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    for(i = 0; i < count; ++i)
+        session->channel_vols[i] = levels[i];
+
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client, -1);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, float *levels)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    int i;
+
+    TRACE("(%p)->(%d, %p)\n", session, count, levels);
+
+    if(!levels)
+        return NULL_PTR_ERR;
+
+    if(count != session->channel_count)
+        return E_INVALIDARG;
+
+    for(i = 0; i < count; ++i)
+        levels[i] = session->channel_vols[i];
+
+    return S_OK;
+}
+
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl =
+{
+    ChannelAudioVolume_QueryInterface,
+    ChannelAudioVolume_AddRef,
+    ChannelAudioVolume_Release,
+    ChannelAudioVolume_GetChannelCount,
+    ChannelAudioVolume_SetChannelVolume,
+    ChannelAudioVolume_GetChannelVolume,
+    ChannelAudioVolume_SetAllVolumes,
+    ChannelAudioVolume_GetAllVolumes
+};
+
+static HRESULT WINAPI AudioSessionManager_QueryInterface(IAudioSessionManager2 *iface,
+        REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioSessionManager) ||
+            IsEqualIID(riid, &IID_IAudioSessionManager2))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioSessionManager_AddRef(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionManager_Release(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    if(!ref)
+        HeapFree(GetProcessHeap(), 0, This);
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetAudioSessionControl(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        IAudioSessionControl **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %lx, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if(FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if(!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = (IAudioSessionControl*)&wrapper->IAudioSessionControl2_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSimpleAudioVolume(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        ISimpleAudioVolume **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %lx, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if(FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if(!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = &wrapper->ISimpleAudioVolume_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSessionEnumerator(
+        IAudioSessionManager2 *iface, IAudioSessionEnumerator **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, out);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterDuckNotification(
+        IAudioSessionManager2 *iface, const WCHAR *session_id,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterDuckNotification(
+        IAudioSessionManager2 *iface,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static const IAudioSessionManager2Vtbl AudioSessionManager2_Vtbl =
+{
+    AudioSessionManager_QueryInterface,
+    AudioSessionManager_AddRef,
+    AudioSessionManager_Release,
+    AudioSessionManager_GetAudioSessionControl,
+    AudioSessionManager_GetSimpleAudioVolume,
+    AudioSessionManager_GetSessionEnumerator,
+    AudioSessionManager_RegisterSessionNotification,
+    AudioSessionManager_UnregisterSessionNotification,
+    AudioSessionManager_RegisterDuckNotification,
+    AudioSessionManager_UnregisterDuckNotification
+};
+
+HRESULT WINAPI AUDDRV_GetAudioSessionManager(IMMDevice *device,
+        IAudioSessionManager2 **out)
+{
+    SessionMgr *This;
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(SessionMgr));
+    if(!This)
+        return E_OUTOFMEMORY;
+
+    This->IAudioSessionManager2_iface.lpVtbl = &AudioSessionManager2_Vtbl;
+    This->device = device;
+    This->ref = 1;
+
+    *out = &This->IAudioSessionManager2_iface;
+
+    return S_OK;
+}
diff --git a/dlls/winecoreaudio.drv/unixlib.h b/dlls/winecoreaudio.drv/unixlib.h
index 11111111111..11111111111 100644
--- a/dlls/winecoreaudio.drv/unixlib.h
+++ b/dlls/winecoreaudio.drv/unixlib.h
@@ -20,17 +20,17 @@
 
 #include "../mmdevapi/unixlib.h"
 
-NTSTATUS unix_midi_init( void * ) DECLSPEC_HIDDEN;
-NTSTATUS unix_midi_release( void * ) DECLSPEC_HIDDEN;
-NTSTATUS unix_midi_out_message( void * ) DECLSPEC_HIDDEN;
-NTSTATUS unix_midi_in_message( void * ) DECLSPEC_HIDDEN;
-NTSTATUS unix_midi_notify_wait( void * ) DECLSPEC_HIDDEN;
+NTSTATUS unix_midi_init( void * );
+NTSTATUS unix_midi_release( void * );
+NTSTATUS unix_midi_out_message( void * );
+NTSTATUS unix_midi_in_message( void * );
+NTSTATUS unix_midi_notify_wait( void * );
 
 #ifdef _WIN64
-NTSTATUS unix_wow64_midi_init(void *args) DECLSPEC_HIDDEN;
-NTSTATUS unix_wow64_midi_out_message(void *args) DECLSPEC_HIDDEN;
-NTSTATUS unix_wow64_midi_in_message(void *args) DECLSPEC_HIDDEN;
-NTSTATUS unix_wow64_midi_notify_wait(void *args) DECLSPEC_HIDDEN;
+NTSTATUS unix_wow64_midi_init(void *args);
+NTSTATUS unix_wow64_midi_out_message(void *args);
+NTSTATUS unix_wow64_midi_in_message(void *args);
+NTSTATUS unix_wow64_midi_notify_wait(void *args);
 #endif
 
 #define UNIX_CALL( func, params ) WINE_UNIX_CALL( func, params )
diff --git a/dlls/winecoreaudio.drv/winecoreaudio.drv.spec b/dlls/winecoreaudio.drv/winecoreaudio.drv.spec
index 11111111111..11111111111 100644
--- a/dlls/winecoreaudio.drv/winecoreaudio.drv.spec
+++ b/dlls/winecoreaudio.drv/winecoreaudio.drv.spec
@@ -4,5 +4,7 @@
 @ stdcall -private modMessage(long long long long long) CoreAudio_modMessage
 
 # MMDevAPI driver functions
-@ stdcall -private get_device_guid(long ptr ptr) get_device_guid
-@ stdcall -private get_device_name_from_guid(ptr ptr ptr) get_device_name_from_guid
+@ stdcall -private GetPriority() AUDDRV_GetPriority
+@ stdcall -private GetEndpointIDs(long ptr ptr ptr ptr) AUDDRV_GetEndpointIDs
+@ stdcall -private GetAudioEndpoint(ptr ptr ptr) AUDDRV_GetAudioEndpoint
+@ stdcall -private GetAudioSessionManager(ptr ptr) AUDDRV_GetAudioSessionManager
diff --git a/dlls/wineoss.drv/Makefile.in b/dlls/wineoss.drv/Makefile.in
index 11111111111..11111111111 100644
--- a/dlls/wineoss.drv/Makefile.in
+++ b/dlls/wineoss.drv/Makefile.in
@@ -5,7 +5,7 @@ DELAYIMPORTS = winmm
 UNIX_LIBS    = $(OSS4_LIBS) $(PTHREAD_LIBS)
 UNIX_CFLAGS  = $(OSS4_CFLAGS)
 
-C_SRCS = \
+SOURCES = \
 	midi.c \
 	midipatch.c \
 	mmaux.c \
diff --git a/dlls/wineoss.drv/mmdevdrv.c b/dlls/wineoss.drv/mmdevdrv.c
index 11111111111..11111111111 100644
--- a/dlls/wineoss.drv/mmdevdrv.c
+++ b/dlls/wineoss.drv/mmdevdrv.c
@@ -19,7 +19,6 @@
 
 #define COBJMACROS
 #include <stdarg.h>
-#include <wchar.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -44,10 +43,78 @@
 
 #include "unixlib.h"
 
-#include "../mmdevapi/mmdevdrv.h"
-
 WINE_DEFAULT_DEBUG_CHANNEL(oss);
 
+#define NULL_PTR_ERR MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER)
+
+static const REFERENCE_TIME DefaultPeriod = 100000;
+static const REFERENCE_TIME MinimumPeriod = 50000;
+
+struct ACImpl;
+typedef struct ACImpl ACImpl;
+
+typedef struct _AudioSession {
+    GUID guid;
+    struct list clients;
+
+    IMMDevice *device;
+
+    float master_vol;
+    UINT32 channel_count;
+    float *channel_vols;
+    BOOL mute;
+
+    struct list entry;
+} AudioSession;
+
+typedef struct _AudioSessionWrapper {
+    IAudioSessionControl2 IAudioSessionControl2_iface;
+    IChannelAudioVolume IChannelAudioVolume_iface;
+    ISimpleAudioVolume ISimpleAudioVolume_iface;
+
+    LONG ref;
+
+    ACImpl *client;
+    AudioSession *session;
+} AudioSessionWrapper;
+
+struct ACImpl {
+    IAudioClient3 IAudioClient3_iface;
+    IAudioRenderClient IAudioRenderClient_iface;
+    IAudioCaptureClient IAudioCaptureClient_iface;
+    IAudioClock IAudioClock_iface;
+    IAudioClock2 IAudioClock2_iface;
+    IAudioStreamVolume IAudioStreamVolume_iface;
+
+    LONG ref;
+
+    IMMDevice *parent;
+    IUnknown *pUnkFTMarshal;
+
+    EDataFlow dataflow;
+    float *vols;
+    UINT32 channel_count;
+    stream_handle stream;
+
+    HANDLE timer_thread;
+
+    AudioSession *session;
+    AudioSessionWrapper *session_wrapper;
+
+    struct list entry;
+
+    /* Keep at end */
+    char devnode[0];
+};
+
+typedef struct _SessionMgr {
+    IAudioSessionManager2 IAudioSessionManager2_iface;
+
+    LONG ref;
+
+    IMMDevice *device;
+} SessionMgr;
+
 typedef struct _OSSDevice {
     struct list entry;
     EDataFlow flow;
@@ -57,35 +124,99 @@ typedef struct _OSSDevice {
 
 static struct list g_devices = LIST_INIT(g_devices);
 
-static WCHAR drv_key_devicesW[256];
+static const WCHAR drv_key_devicesW[] = {'S','o','f','t','w','a','r','e','\\',
+    'W','i','n','e','\\','D','r','i','v','e','r','s','\\',
+    'w','i','n','e','o','s','s','.','d','r','v','\\','d','e','v','i','c','e','s',0};
 static const WCHAR guidW[] = {'g','u','i','d',0};
 
-BOOL WINAPI DllMain(HINSTANCE dll, DWORD reason, void *reserved)
+static CRITICAL_SECTION g_sessions_lock;
+static CRITICAL_SECTION_DEBUG g_sessions_lock_debug =
 {
-    switch (reason)
-    {
-    case DLL_PROCESS_ATTACH:
-    {
-        WCHAR buf[MAX_PATH];
-        WCHAR *filename;
+    0, 0, &g_sessions_lock,
+    { &g_sessions_lock_debug.ProcessLocksList, &g_sessions_lock_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": g_sessions_lock") }
+};
+static CRITICAL_SECTION g_sessions_lock = { &g_sessions_lock_debug, -1, 0, 0, 0, 0 };
+static struct list g_sessions = LIST_INIT(g_sessions);
 
-        if(__wine_init_unix_call()) return FALSE;
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client);
 
-        GetModuleFileNameW(dll, buf, ARRAY_SIZE(buf));
+static const IAudioClient3Vtbl AudioClient3_Vtbl;
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl;
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl;
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl;
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl;
+static const IAudioClockVtbl AudioClock_Vtbl;
+static const IAudioClock2Vtbl AudioClock2_Vtbl;
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl;
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl;
+static const IAudioSessionManager2Vtbl AudioSessionManager2_Vtbl;
 
-        filename = wcsrchr(buf, '\\');
-        filename = filename ? filename + 1 : buf;
+static inline ACImpl *impl_from_IAudioClient3(IAudioClient3 *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClient3_iface);
+}
+
+static inline ACImpl *impl_from_IAudioRenderClient(IAudioRenderClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioRenderClient_iface);
+}
+
+static inline ACImpl *impl_from_IAudioCaptureClient(IAudioCaptureClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioCaptureClient_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IAudioSessionControl2(IAudioSessionControl2 *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IAudioSessionControl2_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_ISimpleAudioVolume(ISimpleAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, ISimpleAudioVolume_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IChannelAudioVolume(IChannelAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IChannelAudioVolume_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock(IAudioClock *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock2(IAudioClock2 *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock2_iface);
+}
+
+static inline ACImpl *impl_from_IAudioStreamVolume(IAudioStreamVolume *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioStreamVolume_iface);
+}
 
-        swprintf(drv_key_devicesW, ARRAY_SIZE(drv_key_devicesW),
-                 L"Software\\Wine\\Drivers\\%s\\devices", filename);
+static inline SessionMgr *impl_from_IAudioSessionManager2(IAudioSessionManager2 *iface)
+{
+    return CONTAINING_RECORD(iface, SessionMgr, IAudioSessionManager2_iface);
+}
 
+BOOL WINAPI DllMain(HINSTANCE dll, DWORD reason, void *reserved)
+{
+    switch (reason)
+    {
+    case DLL_PROCESS_ATTACH:
+        if(__wine_init_unix_call()) return FALSE;
         break;
-    }
+
     case DLL_PROCESS_DETACH:
         if (!reserved)
         {
             OSSDevice *iter, *iter2;
 
+            DeleteCriticalSection(&g_sessions_lock);
+
             LIST_FOR_EACH_ENTRY_SAFE(iter, iter2, &g_devices, OSSDevice, entry){
                 HeapFree(GetProcessHeap(), 0, iter);
             }
@@ -95,16 +226,37 @@ BOOL WINAPI DllMain(HINSTANCE dll, DWORD reason, void *reserved)
     return TRUE;
 }
 
-static void device_add(OSSDevice *oss_dev)
+int WINAPI AUDDRV_GetPriority(void)
 {
-    OSSDevice *dev_item;
-    LIST_FOR_EACH_ENTRY(dev_item, &g_devices, OSSDevice, entry)
-        if(IsEqualGUID(&oss_dev->guid, &dev_item->guid)){ /* already in list */
-            HeapFree(GetProcessHeap(), 0, oss_dev);
-            return;
-        }
+    struct test_connect_params params;
+
+    params.name = NULL;
+
+    OSS_CALL(test_connect, &params);
+
+    return params.priority;
+}
+
+static HRESULT stream_release(stream_handle stream, HANDLE timer_thread)
+{
+    struct release_stream_params params;
+
+    params.stream = stream;
+    params.timer_thread = timer_thread;
+    OSS_CALL(release_stream, &params);
+
+    return params.result;
+}
 
-    list_add_tail(&g_devices, &oss_dev->entry);
+static DWORD WINAPI timer_thread(void *user)
+{
+    struct timer_loop_params params;
+    struct ACImpl *This = user;
+
+    params.stream = This->stream;
+    OSS_CALL(timer_loop, &params);
+
+    return 0;
 }
 
 static void set_device_guid(EDataFlow flow, HKEY drv_key, const WCHAR *key_name,
@@ -142,20 +294,11 @@ exit:
         RegCloseKey(drv_key);
 }
 
-void WINAPI get_device_guid(EDataFlow flow, const char *device, GUID *guid)
+static void get_device_guid(EDataFlow flow, const char *device, GUID *guid)
 {
     HKEY key = NULL, dev_key;
     DWORD type, size = sizeof(*guid);
     WCHAR key_name[256];
-    const unsigned int dev_size = strlen(device) + 1;
-    OSSDevice *oss_dev = HeapAlloc(GetProcessHeap(), 0, offsetof(OSSDevice, devnode[dev_size]));
-
-    if(oss_dev){
-        oss_dev->flow = flow;
-        oss_dev->guid = *guid;
-        memcpy(oss_dev->devnode, device, dev_size);
-        device_add(oss_dev);
-    }
 
     if(flow == eCapture)
         key_name[0] = '1';
@@ -188,20 +331,2055 @@ void WINAPI get_device_guid(EDataFlow flow, const char *device, GUID *guid)
         RegCloseKey(key);
 }
 
-BOOL WINAPI get_device_name_from_guid(GUID *guid, char **name, EDataFlow *flow)
+static void set_stream_volumes(ACImpl *This)
+{
+    struct set_volumes_params params;
+
+    params.stream = This->stream;
+    params.master_volume = (This->session->mute ? 0.0f : This->session->master_vol);
+    params.volumes = This->vols;
+    params.session_volumes = This->session->channel_vols;
+    params.channel = 0;
+    OSS_CALL(set_volumes, &params);
+}
+
+static const OSSDevice *get_ossdevice_from_guid(const GUID *guid)
 {
     OSSDevice *dev_item;
-    LIST_FOR_EACH_ENTRY(dev_item, &g_devices, OSSDevice, entry){
-        if(!IsEqualGUID(guid, &dev_item->guid))
-            continue;
+    LIST_FOR_EACH_ENTRY(dev_item, &g_devices, OSSDevice, entry)
+        if(IsEqualGUID(guid, &dev_item->guid))
+            return dev_item;
+    return NULL;
+}
+
+static void device_add(OSSDevice *oss_dev)
+{
+    if(get_ossdevice_from_guid(&oss_dev->guid)) /* already in list */
+        HeapFree(GetProcessHeap(), 0, oss_dev);
+    else
+        list_add_tail(&g_devices, &oss_dev->entry);
+}
+
+HRESULT WINAPI AUDDRV_GetEndpointIDs(EDataFlow flow, WCHAR ***ids_out, GUID **guids_out,
+        UINT *num, UINT *def_index)
+{
+    struct get_endpoint_ids_params params;
+    GUID *guids = NULL;
+    WCHAR **ids = NULL;
+    unsigned int i;
+
+    TRACE("%d %p %p %p %p\n", flow, ids, guids, num, def_index);
+
+    params.flow = flow;
+    params.size = 1000;
+    params.endpoints = NULL;
+    do{
+        HeapFree(GetProcessHeap(), 0, params.endpoints);
+        params.endpoints = HeapAlloc(GetProcessHeap(), 0, params.size);
+        OSS_CALL(get_endpoint_ids, &params);
+    }while(params.result == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
+
+    if(FAILED(params.result)) goto end;
+
+    ids = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, params.num * sizeof(*ids));
+    guids = HeapAlloc(GetProcessHeap(), 0, params.num * sizeof(*guids));
+    if(!ids || !guids){
+        params.result = E_OUTOFMEMORY;
+        goto end;
+    }
+
+    for(i = 0; i < params.num; i++){
+        WCHAR *name = (WCHAR *)((char *)params.endpoints + params.endpoints[i].name);
+        char *device = (char *)params.endpoints + params.endpoints[i].device;
+        unsigned int name_size = (wcslen(name) + 1) * sizeof(WCHAR);
+        unsigned int dev_size = strlen(device) + 1;
+        OSSDevice *oss_dev;
+
+        ids[i] = HeapAlloc(GetProcessHeap(), 0, name_size);
+        oss_dev = HeapAlloc(GetProcessHeap(), 0, offsetof(OSSDevice, devnode[dev_size]));
+        if(!ids[i] || !oss_dev){
+            HeapFree(GetProcessHeap(), 0, oss_dev);
+            params.result = E_OUTOFMEMORY;
+            goto end;
+        }
+        memcpy(ids[i], name, name_size);
+        get_device_guid(flow, device, guids + i);
+
+        oss_dev->flow = flow;
+        oss_dev->guid = guids[i];
+        memcpy(oss_dev->devnode, device, dev_size);
+        device_add(oss_dev);
+    }
+    *def_index = params.default_idx;
+
+end:
+    HeapFree(GetProcessHeap(), 0, params.endpoints);
+    if(FAILED(params.result)){
+        HeapFree(GetProcessHeap(), 0, guids);
+        if(ids){
+            for(i = 0; i < params.num; i++)
+                HeapFree(GetProcessHeap(), 0, ids[i]);
+            HeapFree(GetProcessHeap(), 0, ids);
+        }
+    }else{
+        *ids_out = ids;
+        *guids_out = guids;
+        *num = params.num;
+    }
+
+    return params.result;
+}
+
+HRESULT WINAPI AUDDRV_GetAudioEndpoint(GUID *guid, IMMDevice *dev,
+        IAudioClient **out)
+{
+    ACImpl *This;
+    const OSSDevice *oss_dev;
+    HRESULT hr;
+    int len;
+
+    TRACE("%s %p %p\n", debugstr_guid(guid), dev, out);
+
+    oss_dev = get_ossdevice_from_guid(guid);
+    if(!oss_dev){
+        WARN("Unknown GUID: %s\n", debugstr_guid(guid));
+        return AUDCLNT_E_DEVICE_INVALIDATED;
+    }
+    len = strlen(oss_dev->devnode);
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, offsetof(ACImpl, devnode[len + 1]));
+    if(!This)
+        return E_OUTOFMEMORY;
+
+    hr = CoCreateFreeThreadedMarshaler((IUnknown *)&This->IAudioClient3_iface, &This->pUnkFTMarshal);
+    if (FAILED(hr)) {
+         HeapFree(GetProcessHeap(), 0, This);
+         return hr;
+    }
+
+    This->dataflow = oss_dev->flow;
+    strcpy(This->devnode, oss_dev->devnode);
+
+    This->IAudioClient3_iface.lpVtbl = &AudioClient3_Vtbl;
+    This->IAudioRenderClient_iface.lpVtbl = &AudioRenderClient_Vtbl;
+    This->IAudioCaptureClient_iface.lpVtbl = &AudioCaptureClient_Vtbl;
+    This->IAudioClock_iface.lpVtbl = &AudioClock_Vtbl;
+    This->IAudioClock2_iface.lpVtbl = &AudioClock2_Vtbl;
+    This->IAudioStreamVolume_iface.lpVtbl = &AudioStreamVolume_Vtbl;
+
+    This->parent = dev;
+    IMMDevice_AddRef(This->parent);
+
+    *out = (IAudioClient *)&This->IAudioClient3_iface;
+    IAudioClient3_AddRef(&This->IAudioClient3_iface);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_QueryInterface(IAudioClient3 *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioClient) ||
+            IsEqualIID(riid, &IID_IAudioClient2) ||
+            IsEqualIID(riid, &IID_IAudioClient3))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->pUnkFTMarshal, riid, ppv);
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClient_AddRef(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioClient_Release(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    ULONG ref;
+
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    if(!ref){
+        IAudioClient3_Stop(iface);
+        IMMDevice_Release(This->parent);
+        IUnknown_Release(This->pUnkFTMarshal);
+        if(This->session){
+            EnterCriticalSection(&g_sessions_lock);
+            list_remove(&This->entry);
+            LeaveCriticalSection(&g_sessions_lock);
+        }
+        HeapFree(GetProcessHeap(), 0, This->vols);
+        if(This->stream)
+            stream_release(This->stream, This->timer_thread);
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static void dump_fmt(const WAVEFORMATEX *fmt)
+{
+    TRACE("wFormatTag: 0x%x (", fmt->wFormatTag);
+    switch(fmt->wFormatTag){
+    case WAVE_FORMAT_PCM:
+        TRACE("WAVE_FORMAT_PCM");
+        break;
+    case WAVE_FORMAT_IEEE_FLOAT:
+        TRACE("WAVE_FORMAT_IEEE_FLOAT");
+        break;
+    case WAVE_FORMAT_EXTENSIBLE:
+        TRACE("WAVE_FORMAT_EXTENSIBLE");
+        break;
+    default:
+        TRACE("Unknown");
+        break;
+    }
+    TRACE(")\n");
+
+    TRACE("nChannels: %u\n", fmt->nChannels);
+    TRACE("nSamplesPerSec: %lu\n", fmt->nSamplesPerSec);
+    TRACE("nAvgBytesPerSec: %lu\n", fmt->nAvgBytesPerSec);
+    TRACE("nBlockAlign: %u\n", fmt->nBlockAlign);
+    TRACE("wBitsPerSample: %u\n", fmt->wBitsPerSample);
+    TRACE("cbSize: %u\n", fmt->cbSize);
+
+    if(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE){
+        WAVEFORMATEXTENSIBLE *fmtex = (void*)fmt;
+        TRACE("dwChannelMask: %08lx\n", fmtex->dwChannelMask);
+        TRACE("Samples: %04x\n", fmtex->Samples.wReserved);
+        TRACE("SubFormat: %s\n", wine_dbgstr_guid(&fmtex->SubFormat));
+    }
+}
+
+static void session_init_vols(AudioSession *session, UINT channels)
+{
+    if(session->channel_count < channels){
+        UINT i;
+
+        if(session->channel_vols)
+            session->channel_vols = HeapReAlloc(GetProcessHeap(), 0,
+                    session->channel_vols, sizeof(float) * channels);
+        else
+            session->channel_vols = HeapAlloc(GetProcessHeap(), 0,
+                    sizeof(float) * channels);
+        if(!session->channel_vols)
+            return;
+
+        for(i = session->channel_count; i < channels; ++i)
+            session->channel_vols[i] = 1.f;
+
+        session->channel_count = channels;
+    }
+}
+
+static AudioSession *create_session(const GUID *guid, IMMDevice *device,
+        UINT num_channels)
+{
+    AudioSession *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(AudioSession));
+    if(!ret)
+        return NULL;
+
+    memcpy(&ret->guid, guid, sizeof(GUID));
+
+    ret->device = device;
+
+    list_init(&ret->clients);
+
+    list_add_head(&g_sessions, &ret->entry);
+
+    session_init_vols(ret, num_channels);
+
+    ret->master_vol = 1.f;
+
+    return ret;
+}
+
+/* if channels == 0, then this will return or create a session with
+ * matching dataflow and GUID. otherwise, channels must also match */
+static HRESULT get_audio_session(const GUID *sessionguid,
+        IMMDevice *device, UINT channels, AudioSession **out)
+{
+    AudioSession *session;
+
+    if(!sessionguid || IsEqualGUID(sessionguid, &GUID_NULL)){
+        *out = create_session(&GUID_NULL, device, channels);
+        if(!*out)
+            return E_OUTOFMEMORY;
+
+        return S_OK;
+    }
+
+    *out = NULL;
+    LIST_FOR_EACH_ENTRY(session, &g_sessions, AudioSession, entry){
+        if(session->device == device &&
+                IsEqualGUID(sessionguid, &session->guid)){
+            session_init_vols(session, channels);
+            *out = session;
+            break;
+        }
+    }
+
+    if(!*out){
+        *out = create_session(sessionguid, device, channels);
+        if(!*out)
+            return E_OUTOFMEMORY;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Initialize(IAudioClient3 *iface,
+        AUDCLNT_SHAREMODE mode, DWORD flags, REFERENCE_TIME duration,
+        REFERENCE_TIME period, const WAVEFORMATEX *fmt,
+        const GUID *sessionguid)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct create_stream_params params;
+    stream_handle stream;
+    unsigned int i;
+
+    TRACE("(%p)->(%x, %lx, %s, %s, %p, %s)\n", This, mode, flags,
+          wine_dbgstr_longlong(duration), wine_dbgstr_longlong(period), fmt, debugstr_guid(sessionguid));
+
+    if(!fmt)
+        return E_POINTER;
+
+    dump_fmt(fmt);
+
+    if(mode != AUDCLNT_SHAREMODE_SHARED && mode != AUDCLNT_SHAREMODE_EXCLUSIVE)
+        return E_INVALIDARG;
+
+    if(flags & ~(AUDCLNT_STREAMFLAGS_CROSSPROCESS |
+                AUDCLNT_STREAMFLAGS_LOOPBACK |
+                AUDCLNT_STREAMFLAGS_EVENTCALLBACK |
+                AUDCLNT_STREAMFLAGS_NOPERSIST |
+                AUDCLNT_STREAMFLAGS_RATEADJUST |
+                AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED |
+                AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY |
+                AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM)){
+        FIXME("Unknown flags: %08lx\n", flags);
+        return E_INVALIDARG;
+    }
+
+    if(mode == AUDCLNT_SHAREMODE_SHARED){
+        period = DefaultPeriod;
+        if( duration < 3 * period)
+            duration = 3 * period;
+    }else{
+        if(!period)
+            period = DefaultPeriod; /* not minimum */
+        if(period < MinimumPeriod || period > 5000000)
+            return AUDCLNT_E_INVALID_DEVICE_PERIOD;
+        if(duration > 20000000) /* the smaller the period, the lower this limit */
+            return AUDCLNT_E_BUFFER_SIZE_ERROR;
+        if(flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK){
+            if(duration != period)
+                return AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
+            FIXME("EXCLUSIVE mode with EVENTCALLBACK\n");
+            return AUDCLNT_E_DEVICE_IN_USE;
+        }else{
+            if( duration < 8 * period)
+                duration = 8 * period; /* may grow above 2s */
+        }
+    }
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(This->stream){
+        LeaveCriticalSection(&g_sessions_lock);
+        return AUDCLNT_E_ALREADY_INITIALIZED;
+    }
+
+    params.name = NULL;
+    params.device = This->devnode;
+    params.flow = This->dataflow;
+    params.share = mode;
+    params.flags = flags;
+    params.duration = duration;
+    params.period = period;
+    params.fmt = fmt;
+    params.channel_count = NULL;
+    params.stream = &stream;
+
+    OSS_CALL(create_stream, &params);
+    if(FAILED(params.result)){
+        LeaveCriticalSection(&g_sessions_lock);
+        return params.result;
+    }
+
+    This->channel_count = fmt->nChannels;
+    This->vols = HeapAlloc(GetProcessHeap(), 0, This->channel_count * sizeof(float));
+    if(!This->vols){
+        params.result = E_OUTOFMEMORY;
+        goto exit;
+    }
+    for(i = 0; i < This->channel_count; ++i)
+        This->vols[i] = 1.f;
+
+    params.result = get_audio_session(sessionguid, This->parent, This->channel_count,
+            &This->session);
+
+exit:
+    if(FAILED(params.result)){
+        stream_release(stream, NULL);
+        HeapFree(GetProcessHeap(), 0, This->vols);
+        This->vols = NULL;
+    } else {
+        list_add_tail(&This->session->clients, &This->entry);
+        This->stream = stream;
+        set_stream_volumes(This);
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetBufferSize(IAudioClient3 *iface,
+        UINT32 *frames)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_buffer_size_params params;
+
+    TRACE("(%p)->(%p)\n", This, frames);
+
+    if(!frames)
+        return E_POINTER;
 
-        if(!(*name = strdup(dev_item->devnode)))
-            return FALSE;
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
 
-        *flow = dev_item->flow;
+    params.stream = This->stream;
+    params.frames = frames;
 
-        return TRUE;
+    OSS_CALL(get_buffer_size, &params);
+    TRACE("buffer size: %u\n", *frames);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetStreamLatency(IAudioClient3 *iface,
+        REFERENCE_TIME *latency)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_latency_params params;
+
+    TRACE("(%p)->(%p)\n", This, latency);
+
+    if(!latency)
+        return E_POINTER;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    params.latency = latency;
+    OSS_CALL(get_latency, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetCurrentPadding(IAudioClient3 *iface,
+        UINT32 *numpad)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_current_padding_params params;
+
+    TRACE("(%p)->(%p)\n", This, numpad);
+
+    if(!numpad)
+        return E_POINTER;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    params.padding = numpad;
+    OSS_CALL(get_current_padding, &params);
+    TRACE("padding: %u\n", *numpad);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_IsFormatSupported(IAudioClient3 *iface,
+        AUDCLNT_SHAREMODE mode, const WAVEFORMATEX *fmt,
+        WAVEFORMATEX **out)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct is_format_supported_params params;
+
+    TRACE("(%p)->(%x, %p, %p)\n", This, mode, fmt, out);
+    if(fmt) dump_fmt(fmt);
+
+    params.device = This->devnode;
+    params.flow = This->dataflow;
+    params.share = mode;
+    params.fmt_in = fmt;
+    params.fmt_out = NULL;
+
+    if(out){
+        *out = NULL;
+        if(mode == AUDCLNT_SHAREMODE_SHARED)
+            params.fmt_out = CoTaskMemAlloc(sizeof(*params.fmt_out));
     }
+    OSS_CALL(is_format_supported, &params);
+
+    if(params.result == S_FALSE)
+        *out = &params.fmt_out->Format;
+    else
+        CoTaskMemFree(params.fmt_out);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetMixFormat(IAudioClient3 *iface,
+        WAVEFORMATEX **pwfx)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct get_mix_format_params params;
+
+    TRACE("(%p)->(%p)\n", This, pwfx);
+
+    if(!pwfx)
+        return E_POINTER;
+    *pwfx = NULL;
+
+    params.device = This->devnode;
+    params.flow = This->dataflow;
+    params.fmt = CoTaskMemAlloc(sizeof(WAVEFORMATEXTENSIBLE));
+    if(!params.fmt)
+        return E_OUTOFMEMORY;
+
+    OSS_CALL(get_mix_format, &params);
+
+    if(SUCCEEDED(params.result)){
+        *pwfx = &params.fmt->Format;
+        dump_fmt(*pwfx);
+    } else
+        CoTaskMemFree(params.fmt);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetDevicePeriod(IAudioClient3 *iface,
+        REFERENCE_TIME *defperiod, REFERENCE_TIME *minperiod)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    TRACE("(%p)->(%p, %p)\n", This, defperiod, minperiod);
+
+    if(!defperiod && !minperiod)
+        return E_POINTER;
+
+    if(defperiod)
+        *defperiod = DefaultPeriod;
+    if(minperiod)
+        *minperiod = MinimumPeriod;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Start(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct start_params params;
+
+    TRACE("(%p)\n", This);
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(!This->stream){
+        LeaveCriticalSection(&g_sessions_lock);
+        return AUDCLNT_E_NOT_INITIALIZED;
+    }
+
+    params.stream = This->stream;
+    OSS_CALL(start, &params);
+
+    if(SUCCEEDED(params.result) && !This->timer_thread){
+        This->timer_thread = CreateThread(NULL, 0, timer_thread, This, 0, NULL);
+        SetThreadPriority(This->timer_thread, THREAD_PRIORITY_TIME_CRITICAL);
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_Stop(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct stop_params params;
+
+    TRACE("(%p)\n", This);
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    OSS_CALL(stop, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_Reset(IAudioClient3 *iface)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct reset_params params;
+
+    TRACE("(%p)\n", This);
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    OSS_CALL(reset, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_SetEventHandle(IAudioClient3 *iface,
+        HANDLE event)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    struct set_event_handle_params params;
+
+    TRACE("(%p)->(%p)\n", This, event);
+
+    if(!event)
+        return E_INVALIDARG;
+
+    if(!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+
+    params.stream = This->stream;
+    params.event = event;
+    OSS_CALL(set_event_handle, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClient_GetService(IAudioClient3 *iface, REFIID riid,
+        void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(!This->stream){
+        LeaveCriticalSection(&g_sessions_lock);
+        return AUDCLNT_E_NOT_INITIALIZED;
+    }
+
+    if(IsEqualIID(riid, &IID_IAudioRenderClient)){
+        if(This->dataflow != eRender){
+            LeaveCriticalSection(&g_sessions_lock);
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        }
+        IAudioRenderClient_AddRef(&This->IAudioRenderClient_iface);
+        *ppv = &This->IAudioRenderClient_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioCaptureClient)){
+        if(This->dataflow != eCapture){
+            LeaveCriticalSection(&g_sessions_lock);
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        }
+        IAudioCaptureClient_AddRef(&This->IAudioCaptureClient_iface);
+        *ppv = &This->IAudioCaptureClient_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioClock)){
+        IAudioClock_AddRef(&This->IAudioClock_iface);
+        *ppv = &This->IAudioClock_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioStreamVolume)){
+        IAudioStreamVolume_AddRef(&This->IAudioStreamVolume_iface);
+        *ppv = &This->IAudioStreamVolume_iface;
+    }else if(IsEqualIID(riid, &IID_IAudioSessionControl)){
+        if(!This->session_wrapper){
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if(!This->session_wrapper){
+                LeaveCriticalSection(&g_sessions_lock);
+                return E_OUTOFMEMORY;
+            }
+        }else
+            IAudioSessionControl2_AddRef(&This->session_wrapper->IAudioSessionControl2_iface);
+
+        *ppv = &This->session_wrapper->IAudioSessionControl2_iface;
+    }else if(IsEqualIID(riid, &IID_IChannelAudioVolume)){
+        if(!This->session_wrapper){
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if(!This->session_wrapper){
+                LeaveCriticalSection(&g_sessions_lock);
+                return E_OUTOFMEMORY;
+            }
+        }else
+            IChannelAudioVolume_AddRef(&This->session_wrapper->IChannelAudioVolume_iface);
+
+        *ppv = &This->session_wrapper->IChannelAudioVolume_iface;
+    }else if(IsEqualIID(riid, &IID_ISimpleAudioVolume)){
+        if(!This->session_wrapper){
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if(!This->session_wrapper){
+                LeaveCriticalSection(&g_sessions_lock);
+                return E_OUTOFMEMORY;
+            }
+        }else
+            ISimpleAudioVolume_AddRef(&This->session_wrapper->ISimpleAudioVolume_iface);
+
+        *ppv = &This->session_wrapper->ISimpleAudioVolume_iface;
+    }
+
+    if(*ppv){
+        LeaveCriticalSection(&g_sessions_lock);
+        return S_OK;
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    FIXME("stub %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static HRESULT WINAPI AudioClient_IsOffloadCapable(IAudioClient3 *iface,
+        AUDIO_STREAM_CATEGORY category, BOOL *offload_capable)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    TRACE("(%p)->(0x%x, %p)\n", This, category, offload_capable);
+
+    if(!offload_capable)
+        return E_INVALIDARG;
+
+    *offload_capable = FALSE;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_SetClientProperties(IAudioClient3 *iface,
+        const AudioClientProperties *prop)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+    const Win8AudioClientProperties *legacy_prop = (const Win8AudioClientProperties *)prop;
+
+    TRACE("(%p)->(%p)\n", This, prop);
+
+    if(!legacy_prop)
+        return E_POINTER;
+
+    if(legacy_prop->cbSize == sizeof(AudioClientProperties)){
+        TRACE("{ bIsOffload: %u, eCategory: 0x%x, Options: 0x%x }\n",
+                legacy_prop->bIsOffload,
+                legacy_prop->eCategory,
+                prop->Options);
+    }else if(legacy_prop->cbSize == sizeof(Win8AudioClientProperties)){
+        TRACE("{ bIsOffload: %u, eCategory: 0x%x }\n",
+                legacy_prop->bIsOffload,
+                legacy_prop->eCategory);
+    }else{
+        WARN("Unsupported Size = %d\n", legacy_prop->cbSize);
+        return E_INVALIDARG;
+    }
+
+
+    if(legacy_prop->bIsOffload)
+        return AUDCLNT_E_ENDPOINT_OFFLOAD_NOT_CAPABLE;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_GetBufferSizeLimits(IAudioClient3 *iface,
+        const WAVEFORMATEX *format, BOOL event_driven, REFERENCE_TIME *min_duration,
+        REFERENCE_TIME *max_duration)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(%p, %u, %p, %p)\n", This, format, event_driven, min_duration, max_duration);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioClient_GetSharedModeEnginePeriod(IAudioClient3 *iface,
+        const WAVEFORMATEX *format, UINT32 *default_period_frames, UINT32 *unit_period_frames,
+        UINT32 *min_period_frames, UINT32 *max_period_frames)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(%p, %p, %p, %p, %p)\n", This, format, default_period_frames, unit_period_frames,
+            min_period_frames, max_period_frames);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioClient_GetCurrentSharedModeEnginePeriod(IAudioClient3 *iface,
+        WAVEFORMATEX **cur_format, UINT32 *cur_period_frames)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(%p, %p)\n", This, cur_format, cur_period_frames);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioClient_InitializeSharedAudioStream(IAudioClient3 *iface,
+        DWORD flags, UINT32 period_frames, const WAVEFORMATEX *format,
+        const GUID *session_guid)
+{
+    ACImpl *This = impl_from_IAudioClient3(iface);
+
+    FIXME("(%p)->(0x%lx, %u, %p, %s)\n", This, flags, period_frames, format, debugstr_guid(session_guid));
+
+    return E_NOTIMPL;
+}
+
+static const IAudioClient3Vtbl AudioClient3_Vtbl =
+{
+    AudioClient_QueryInterface,
+    AudioClient_AddRef,
+    AudioClient_Release,
+    AudioClient_Initialize,
+    AudioClient_GetBufferSize,
+    AudioClient_GetStreamLatency,
+    AudioClient_GetCurrentPadding,
+    AudioClient_IsFormatSupported,
+    AudioClient_GetMixFormat,
+    AudioClient_GetDevicePeriod,
+    AudioClient_Start,
+    AudioClient_Stop,
+    AudioClient_Reset,
+    AudioClient_SetEventHandle,
+    AudioClient_GetService,
+    AudioClient_IsOffloadCapable,
+    AudioClient_SetClientProperties,
+    AudioClient_GetBufferSizeLimits,
+    AudioClient_GetSharedModeEnginePeriod,
+    AudioClient_GetCurrentSharedModeEnginePeriod,
+    AudioClient_InitializeSharedAudioStream,
+};
+
+static HRESULT WINAPI AudioRenderClient_QueryInterface(
+        IAudioRenderClient *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioRenderClient))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->pUnkFTMarshal, riid, ppv);
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioRenderClient_AddRef(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioRenderClient_Release(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioRenderClient_GetBuffer(IAudioRenderClient *iface,
+        UINT32 frames, BYTE **data)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    struct get_render_buffer_params params;
+
+    TRACE("(%p)->(%u, %p)\n", This, frames, data);
+
+    if(!data)
+        return E_POINTER;
+
+    *data = NULL;
+
+    params.stream = This->stream;
+    params.frames = frames;
+    params.data = data;
+    OSS_CALL(get_render_buffer, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioRenderClient_ReleaseBuffer(
+        IAudioRenderClient *iface, UINT32 written_frames, DWORD flags)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    struct release_render_buffer_params params;
+
+    TRACE("(%p)->(%u, %lx)\n", This, written_frames, flags);
+
+    params.stream = This->stream;
+    params.written_frames = written_frames;
+    params.flags = flags;
+    OSS_CALL(release_render_buffer, &params);
+
+    return params.result;
+}
+
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl = {
+    AudioRenderClient_QueryInterface,
+    AudioRenderClient_AddRef,
+    AudioRenderClient_Release,
+    AudioRenderClient_GetBuffer,
+    AudioRenderClient_ReleaseBuffer
+};
+
+static HRESULT WINAPI AudioCaptureClient_QueryInterface(
+        IAudioCaptureClient *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioCaptureClient))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->pUnkFTMarshal, riid, ppv);
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioCaptureClient_AddRef(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioCaptureClient_Release(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetBuffer(IAudioCaptureClient *iface,
+        BYTE **data, UINT32 *frames, DWORD *flags, UINT64 *devpos,
+        UINT64 *qpcpos)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    struct get_capture_buffer_params params;
+
+    TRACE("(%p)->(%p, %p, %p, %p, %p)\n", This, data, frames, flags,
+            devpos, qpcpos);
+
+    if(!data)
+        return E_POINTER;
+
+    *data = NULL;
+
+    if(!frames || !flags)
+        return E_POINTER;
+
+    params.stream = This->stream;
+    params.data = data;
+    params.frames = frames;
+    params.flags = (UINT*)flags;
+    params.devpos = devpos;
+    params.qpcpos = qpcpos;
+    OSS_CALL(get_capture_buffer, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioCaptureClient_ReleaseBuffer(
+        IAudioCaptureClient *iface, UINT32 done)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    struct release_capture_buffer_params params;
+
+    TRACE("(%p)->(%u)\n", This, done);
+
+    params.stream = This->stream;
+    params.done = done;
+    OSS_CALL(release_capture_buffer, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetNextPacketSize(
+        IAudioCaptureClient *iface, UINT32 *frames)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    struct get_next_packet_size_params params;
+
+    TRACE("(%p)->(%p)\n", This, frames);
+
+    if(!frames)
+        return E_POINTER;
+
+    params.stream = This->stream;
+    params.frames = frames;
+    OSS_CALL(get_next_packet_size, &params);
+
+    return params.result;
+}
+
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl =
+{
+    AudioCaptureClient_QueryInterface,
+    AudioCaptureClient_AddRef,
+    AudioCaptureClient_Release,
+    AudioCaptureClient_GetBuffer,
+    AudioCaptureClient_ReleaseBuffer,
+    AudioCaptureClient_GetNextPacketSize
+};
+
+static HRESULT WINAPI AudioClock_QueryInterface(IAudioClock *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IAudioClock))
+        *ppv = iface;
+    else if(IsEqualIID(riid, &IID_IAudioClock2))
+        *ppv = &This->IAudioClock2_iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClock_AddRef(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioClock_Release(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioClock_GetFrequency(IAudioClock *iface, UINT64 *freq)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    struct get_frequency_params params;
+
+    TRACE("(%p)->(%p)\n", This, freq);
+
+    params.stream = This->stream;
+    params.freq = freq;
+    OSS_CALL(get_frequency, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClock_GetPosition(IAudioClock *iface, UINT64 *pos,
+        UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    struct get_position_params params;
+
+    TRACE("(%p)->(%p, %p)\n", This, pos, qpctime);
+
+    if(!pos)
+        return E_POINTER;
+
+    params.stream = This->stream;
+    params.device = FALSE;
+    params.pos = pos;
+    params.qpctime = qpctime;
+    OSS_CALL(get_position, &params);
+
+    return params.result;
+}
+
+static HRESULT WINAPI AudioClock_GetCharacteristics(IAudioClock *iface,
+        DWORD *chars)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%p)\n", This, chars);
+
+    if(!chars)
+        return E_POINTER;
+
+    *chars = AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ;
+
+    return S_OK;
+}
+
+static const IAudioClockVtbl AudioClock_Vtbl =
+{
+    AudioClock_QueryInterface,
+    AudioClock_AddRef,
+    AudioClock_Release,
+    AudioClock_GetFrequency,
+    AudioClock_GetPosition,
+    AudioClock_GetCharacteristics
+};
+
+static HRESULT WINAPI AudioClock2_QueryInterface(IAudioClock2 *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClock_QueryInterface(&This->IAudioClock_iface, riid, ppv);
+}
+
+static ULONG WINAPI AudioClock2_AddRef(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioClock2_Release(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioClock2_GetDevicePosition(IAudioClock2 *iface,
+        UINT64 *pos, UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+
+    FIXME("(%p)->(%p, %p)\n", This, pos, qpctime);
+
+    return E_NOTIMPL;
+}
+
+static const IAudioClock2Vtbl AudioClock2_Vtbl =
+{
+    AudioClock2_QueryInterface,
+    AudioClock2_AddRef,
+    AudioClock2_Release,
+    AudioClock2_GetDevicePosition
+};
+
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client)
+{
+    AudioSessionWrapper *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(AudioSessionWrapper));
+    if(!ret)
+        return NULL;
+
+    ret->IAudioSessionControl2_iface.lpVtbl = &AudioSessionControl2_Vtbl;
+    ret->ISimpleAudioVolume_iface.lpVtbl = &SimpleAudioVolume_Vtbl;
+    ret->IChannelAudioVolume_iface.lpVtbl = &ChannelAudioVolume_Vtbl;
+
+    ret->ref = 1;
+
+    ret->client = client;
+    if(client){
+        ret->session = client->session;
+        AudioClient_AddRef(&client->IAudioClient3_iface);
+    }
+
+    return ret;
+}
+
+static HRESULT WINAPI AudioSessionControl_QueryInterface(
+        IAudioSessionControl2 *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioSessionControl) ||
+            IsEqualIID(riid, &IID_IAudioSessionControl2))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioSessionControl_AddRef(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionControl_Release(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    if(!ref){
+        if(This->client){
+            EnterCriticalSection(&g_sessions_lock);
+            This->client->session_wrapper = NULL;
+            LeaveCriticalSection(&g_sessions_lock);
+            AudioClient_Release(&This->client->IAudioClient3_iface);
+        }
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetState(IAudioSessionControl2 *iface,
+        AudioSessionState *state)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    struct is_started_params params;
+    ACImpl *client;
+
+    TRACE("(%p)->(%p)\n", This, state);
+
+    if(!state)
+        return NULL_PTR_ERR;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    if(list_empty(&This->session->clients)){
+        *state = AudioSessionStateExpired;
+        LeaveCriticalSection(&g_sessions_lock);
+        return S_OK;
+    }
+
+    LIST_FOR_EACH_ENTRY(client, &This->session->clients, ACImpl, entry){
+        params.stream = client->stream;
+        OSS_CALL(is_started, &params);
+        if(params.result == S_OK){
+            *state = AudioSessionStateActive;
+            LeaveCriticalSection(&g_sessions_lock);
+            return S_OK;
+        }
+    }
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    *state = AudioSessionStateInactive;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetDisplayName(
+        IAudioSessionControl2 *iface, WCHAR **name)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, name);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDisplayName(
+        IAudioSessionControl2 *iface, const WCHAR *name, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, name, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetIconPath(
+        IAudioSessionControl2 *iface, WCHAR **path)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, path);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetIconPath(
+        IAudioSessionControl2 *iface, const WCHAR *path, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, path, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetGroupingParam(
+        IAudioSessionControl2 *iface, GUID *group)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, group);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetGroupingParam(
+        IAudioSessionControl2 *iface, const GUID *group, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%s, %s) - stub\n", This, debugstr_guid(group),
+            debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_RegisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_UnregisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionInstanceIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetProcessId(
+        IAudioSessionControl2 *iface, DWORD *pid)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%p)\n", This, pid);
+
+    if(!pid)
+        return E_POINTER;
+
+    *pid = GetCurrentProcessId();
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_IsSystemSoundsSession(
+        IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)\n", This);
+
+    return S_FALSE;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDuckingPreference(
+        IAudioSessionControl2 *iface, BOOL optout)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%d)\n", This, optout);
+
+    return S_OK;
+}
+
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl =
+{
+    AudioSessionControl_QueryInterface,
+    AudioSessionControl_AddRef,
+    AudioSessionControl_Release,
+    AudioSessionControl_GetState,
+    AudioSessionControl_GetDisplayName,
+    AudioSessionControl_SetDisplayName,
+    AudioSessionControl_GetIconPath,
+    AudioSessionControl_SetIconPath,
+    AudioSessionControl_GetGroupingParam,
+    AudioSessionControl_SetGroupingParam,
+    AudioSessionControl_RegisterAudioSessionNotification,
+    AudioSessionControl_UnregisterAudioSessionNotification,
+    AudioSessionControl_GetSessionIdentifier,
+    AudioSessionControl_GetSessionInstanceIdentifier,
+    AudioSessionControl_GetProcessId,
+    AudioSessionControl_IsSystemSoundsSession,
+    AudioSessionControl_SetDuckingPreference
+};
+
+static HRESULT WINAPI SimpleAudioVolume_QueryInterface(
+        ISimpleAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_ISimpleAudioVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI SimpleAudioVolume_AddRef(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI SimpleAudioVolume_Release(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMasterVolume(
+        ISimpleAudioVolume *iface, float level, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+    ACImpl *client;
+
+    TRACE("(%p)->(%f, %s)\n", session, level, wine_dbgstr_guid(context));
+
+    if(level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    session->master_vol = level;
+
+    TRACE("OSS doesn't support setting volume\n");
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMasterVolume(
+        ISimpleAudioVolume *iface, float *level)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, level);
+
+    if(!level)
+        return NULL_PTR_ERR;
+
+    *level = session->master_vol;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMute(ISimpleAudioVolume *iface,
+        BOOL mute, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+    ACImpl *client;
+
+    TRACE("(%p)->(%u, %s)\n", session, mute, debugstr_guid(context));
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    session->mute = mute;
+
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMute(ISimpleAudioVolume *iface,
+        BOOL *mute)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, mute);
+
+    if(!mute)
+        return NULL_PTR_ERR;
+
+    *mute = This->session->mute;
+
+    return S_OK;
+}
+
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl  =
+{
+    SimpleAudioVolume_QueryInterface,
+    SimpleAudioVolume_AddRef,
+    SimpleAudioVolume_Release,
+    SimpleAudioVolume_SetMasterVolume,
+    SimpleAudioVolume_GetMasterVolume,
+    SimpleAudioVolume_SetMute,
+    SimpleAudioVolume_GetMute
+};
+
+static HRESULT WINAPI AudioStreamVolume_QueryInterface(
+        IAudioStreamVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioStreamVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioStreamVolume_AddRef(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient3_AddRef(&This->IAudioClient3_iface);
+}
+
+static ULONG WINAPI AudioStreamVolume_Release(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient3_Release(&This->IAudioClient3_iface);
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelCount(
+        IAudioStreamVolume *iface, UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if(!out)
+        return E_POINTER;
+
+    *out = This->channel_count;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_SetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%d, %f)\n", This, index, level);
+
+    if(level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if(index >= This->channel_count)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    This->vols[index] = level;
+
+    TRACE("OSS doesn't support setting volume\n");
+    set_stream_volumes(This);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float *level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%d, %p)\n", This, index, level);
+
+    if(!level)
+        return E_POINTER;
+
+    if(index >= This->channel_count)
+        return E_INVALIDARG;
+
+    *level = This->vols[index];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_SetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, const float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    int i;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if(!levels)
+        return E_POINTER;
+
+    if(count != This->channel_count)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    for(i = 0; i < count; ++i)
+        This->vols[i] = levels[i];
+
+    TRACE("OSS doesn't support setting volume\n");
+    set_stream_volumes(This);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    int i;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if(!levels)
+        return E_POINTER;
+
+    if(count != This->channel_count)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    for(i = 0; i < count; ++i)
+        levels[i] = This->vols[i];
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl =
+{
+    AudioStreamVolume_QueryInterface,
+    AudioStreamVolume_AddRef,
+    AudioStreamVolume_Release,
+    AudioStreamVolume_GetChannelCount,
+    AudioStreamVolume_SetChannelVolume,
+    AudioStreamVolume_GetChannelVolume,
+    AudioStreamVolume_SetAllVolumes,
+    AudioStreamVolume_GetAllVolumes
+};
+
+static HRESULT WINAPI ChannelAudioVolume_QueryInterface(
+        IChannelAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IChannelAudioVolume))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI ChannelAudioVolume_AddRef(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI ChannelAudioVolume_Release(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelCount(
+        IChannelAudioVolume *iface, UINT32 *out)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, out);
+
+    if(!out)
+        return NULL_PTR_ERR;
+
+    *out = session->channel_count;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float level,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    ACImpl *client;
+
+    TRACE("(%p)->(%d, %f, %s)\n", session, index, level,
+            wine_dbgstr_guid(context));
+
+    if(level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if(index >= session->channel_count)
+        return E_INVALIDARG;
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    session->channel_vols[index] = level;
+
+    TRACE("OSS doesn't support setting volume\n");
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float *level)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%d, %p)\n", session, index, level);
+
+    if(!level)
+        return NULL_PTR_ERR;
+
+    if(index >= session->channel_count)
+        return E_INVALIDARG;
+
+    *level = session->channel_vols[index];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, const float *levels,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    ACImpl *client;
+    int i;
+
+    TRACE("(%p)->(%d, %p, %s)\n", session, count, levels,
+            wine_dbgstr_guid(context));
+
+    if(!levels)
+        return NULL_PTR_ERR;
+
+    if(count != session->channel_count)
+        return E_INVALIDARG;
+
+    if(context)
+        FIXME("Notifications not supported yet\n");
+
+    EnterCriticalSection(&g_sessions_lock);
+
+    for(i = 0; i < count; ++i)
+        session->channel_vols[i] = levels[i];
+
+    TRACE("OSS doesn't support setting volume\n");
+    LIST_FOR_EACH_ENTRY(client, &session->clients, ACImpl, entry)
+        set_stream_volumes(client);
+
+    LeaveCriticalSection(&g_sessions_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, float *levels)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    int i;
+
+    TRACE("(%p)->(%d, %p)\n", session, count, levels);
+
+    if(!levels)
+        return NULL_PTR_ERR;
+
+    if(count != session->channel_count)
+        return E_INVALIDARG;
+
+    for(i = 0; i < count; ++i)
+        levels[i] = session->channel_vols[i];
+
+    return S_OK;
+}
+
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl =
+{
+    ChannelAudioVolume_QueryInterface,
+    ChannelAudioVolume_AddRef,
+    ChannelAudioVolume_Release,
+    ChannelAudioVolume_GetChannelCount,
+    ChannelAudioVolume_SetChannelVolume,
+    ChannelAudioVolume_GetChannelVolume,
+    ChannelAudioVolume_SetAllVolumes,
+    ChannelAudioVolume_GetAllVolumes
+};
+
+static HRESULT WINAPI AudioSessionManager_QueryInterface(IAudioSessionManager2 *iface,
+        REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if(!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_IAudioSessionManager) ||
+            IsEqualIID(riid, &IID_IAudioSessionManager2))
+        *ppv = iface;
+    if(*ppv){
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioSessionManager_AddRef(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionManager_Release(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %lu\n", This, ref);
+    if(!ref)
+        HeapFree(GetProcessHeap(), 0, This);
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetAudioSessionControl(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        IAudioSessionControl **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %lx, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if(FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if(!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = (IAudioSessionControl*)&wrapper->IAudioSessionControl2_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSimpleAudioVolume(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        ISimpleAudioVolume **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %lx, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if(FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if(!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = &wrapper->ISimpleAudioVolume_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSessionEnumerator(
+        IAudioSessionManager2 *iface, IAudioSessionEnumerator **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, out);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterDuckNotification(
+        IAudioSessionManager2 *iface, const WCHAR *session_id,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterDuckNotification(
+        IAudioSessionManager2 *iface,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static const IAudioSessionManager2Vtbl AudioSessionManager2_Vtbl =
+{
+    AudioSessionManager_QueryInterface,
+    AudioSessionManager_AddRef,
+    AudioSessionManager_Release,
+    AudioSessionManager_GetAudioSessionControl,
+    AudioSessionManager_GetSimpleAudioVolume,
+    AudioSessionManager_GetSessionEnumerator,
+    AudioSessionManager_RegisterSessionNotification,
+    AudioSessionManager_UnregisterSessionNotification,
+    AudioSessionManager_RegisterDuckNotification,
+    AudioSessionManager_UnregisterDuckNotification
+};
+
+HRESULT WINAPI AUDDRV_GetAudioSessionManager(IMMDevice *device,
+        IAudioSessionManager2 **out)
+{
+    SessionMgr *This;
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(SessionMgr));
+    if(!This)
+        return E_OUTOFMEMORY;
+
+    This->IAudioSessionManager2_iface.lpVtbl = &AudioSessionManager2_Vtbl;
+    This->device = device;
+    This->ref = 1;
+
+    *out = &This->IAudioSessionManager2_iface;
 
-    return FALSE;
+    return S_OK;
 }
diff --git a/dlls/wineoss.drv/oss.c b/dlls/wineoss.drv/oss.c
index 11111111111..11111111111 100644
--- a/dlls/wineoss.drv/oss.c
+++ b/dlls/wineoss.drv/oss.c
@@ -69,16 +69,6 @@ struct oss_stream
 
 WINE_DEFAULT_DEBUG_CHANNEL(oss);
 
-static const REFERENCE_TIME def_period = 100000;
-static const REFERENCE_TIME min_period = 50000;
-
-static ULONG_PTR zero_bits = 0;
-
-static NTSTATUS oss_not_implemented(void *args)
-{
-    return STATUS_SUCCESS;
-}
-
 /* copied from kernelbase */
 static int muldiv( int a, int b, int c )
 {
@@ -223,27 +213,6 @@ static void get_default_device(EDataFlow flow, char device[OSS_DEVNODE_SIZE])
     return;
 }
 
-static NTSTATUS oss_process_attach(void *args)
-{
-#ifdef _WIN64
-    if (NtCurrentTeb()->WowTebOffset)
-    {
-        SYSTEM_BASIC_INFORMATION info;
-
-        NtQuerySystemInformation(SystemEmulationBasicInformation, &info, sizeof(info), NULL);
-        zero_bits = (ULONG_PTR)info.HighestUserAddress | 0x7fffffff;
-    }
-#endif
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS oss_main_loop(void *args)
-{
-    struct main_loop_params *params = args;
-    NtSetEvent(params->event, NULL);
-    return STATUS_SUCCESS;
-}
-
 static NTSTATUS oss_get_endpoint_ids(void *args)
 {
     struct get_endpoint_ids_params *params = args;
@@ -566,46 +535,23 @@ static HRESULT setup_oss_device(AUDCLNT_SHAREMODE share, int fd,
     return ret;
 }
 
+static ULONG_PTR zero_bits(void)
+{
+#ifdef _WIN64
+    return !NtCurrentTeb()->WowTebOffset ? 0 : 0x7fffffff;
+#else
+    return 0;
+#endif
+}
+
 static NTSTATUS oss_create_stream(void *args)
 {
     struct create_stream_params *params = args;
-    WAVEFORMATEXTENSIBLE *fmtex = (WAVEFORMATEXTENSIBLE *)params->fmt;
+    WAVEFORMATEXTENSIBLE *fmtex;
     struct oss_stream *stream;
     oss_audioinfo ai;
     SIZE_T size;
 
-    params->result = S_OK;
-
-    if (params->share == AUDCLNT_SHAREMODE_SHARED) {
-        params->period = def_period;
-        if (params->duration < 3 * params->period)
-            params->duration = 3 * params->period;
-    } else {
-        if (fmtex->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
-           (fmtex->dwChannelMask == 0 || fmtex->dwChannelMask & SPEAKER_RESERVED))
-            params->result = AUDCLNT_E_UNSUPPORTED_FORMAT;
-        else {
-            if (!params->period)
-                params->period = def_period;
-            if (params->period < min_period || params->period > 5000000)
-                params->result = AUDCLNT_E_INVALID_DEVICE_PERIOD;
-            else if (params->duration > 20000000) /* The smaller the period, the lower this limit. */
-                params->result = AUDCLNT_E_BUFFER_SIZE_ERROR;
-            else if (params->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) {
-                if (params->duration != params->period)
-                    params->result = AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
-
-                FIXME("EXCLUSIVE mode with EVENTCALLBACK\n");
-
-                params->result = AUDCLNT_E_DEVICE_IN_USE;
-            } else if (params->duration < 8 * params->period)
-                params->duration = 8 * params->period; /* May grow above 2s. */
-        }
-    }
-
-    if (FAILED(params->result))
-        return STATUS_SUCCESS;
-
     stream = calloc(1, sizeof(*stream));
     if(!stream){
         params->result = E_OUTOFMEMORY;
@@ -660,7 +606,7 @@ static NTSTATUS oss_create_stream(void *args)
     if(params->share == AUDCLNT_SHAREMODE_EXCLUSIVE)
         stream->bufsize_frames -= stream->bufsize_frames % stream->period_frames;
     size = stream->bufsize_frames * params->fmt->nBlockAlign;
-    if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->local_buffer, zero_bits,
+    if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->local_buffer, zero_bits(),
                                &size, MEM_COMMIT, PAGE_READWRITE)){
         params->result = E_OUTOFMEMORY;
         goto exit;
@@ -681,7 +627,6 @@ exit:
         free(stream->fmt);
         free(stream);
     }else{
-        *params->channel_count = params->fmt->nChannels;
         *params->stream = (stream_handle)(UINT_PTR)stream;
     }
 
@@ -995,7 +940,7 @@ static NTSTATUS oss_get_render_buffer(void *args)
                 stream->tmp_buffer = NULL;
             }
             size = frames * stream->fmt->nBlockAlign;
-            if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer, zero_bits,
+            if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer, zero_bits(),
                                        &size, MEM_COMMIT, PAGE_READWRITE)){
                 stream->tmp_buffer_frames = 0;
                 return oss_unlock_result(stream, &params->result, E_OUTOFMEMORY);
@@ -1105,7 +1050,7 @@ static NTSTATUS oss_get_capture_buffer(void *args)
                 stream->tmp_buffer = NULL;
             }
             size = *frames * stream->fmt->nBlockAlign;
-            if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer, zero_bits,
+            if(NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer, zero_bits(),
                                        &size, MEM_COMMIT, PAGE_READWRITE)){
                 stream->tmp_buffer_frames = 0;
                 return oss_unlock_result(stream, &params->result, E_OUTOFMEMORY);
@@ -1295,20 +1240,6 @@ static NTSTATUS oss_get_mix_format(void *args)
     return STATUS_SUCCESS;
 }
 
-static NTSTATUS oss_get_device_period(void *args)
-{
-    struct get_device_period_params *params = args;
-
-    if (params->def_period)
-        *params->def_period = def_period;
-    if (params->min_period)
-        *params->min_period = min_period;
-
-    params->result = S_OK;
-
-    return STATUS_SUCCESS;
-}
-
 static NTSTATUS oss_get_buffer_size(void *args)
 {
     struct get_buffer_size_params *params = args;
@@ -1382,12 +1313,6 @@ static NTSTATUS oss_get_position(void *args)
     struct oss_stream *stream = handle_get_stream(params->stream);
     UINT64 *pos = params->pos, *qpctime = params->qpctime;
 
-    if (params->device) {
-        FIXME("Device position reporting not implemented\n");
-        params->result = E_NOTIMPL;
-        return STATUS_SUCCESS;
-    }
-
     oss_lock(stream);
 
     if(stream->flow == eRender){
@@ -1430,16 +1355,6 @@ static NTSTATUS oss_set_volumes(void *args)
 {
     struct set_volumes_params *params = args;
     struct oss_stream *stream = handle_get_stream(params->stream);
-    UINT16 i;
-
-    if (params->master_volume) {
-        for (i = 0; i < stream->fmt->nChannels; ++i) {
-            if (params->master_volume * params->volumes[i] * params->session_volumes[i] != 1.0f) {
-                FIXME("Volume control is not implemented\n");
-                break;
-            }
-        }
-    }
 
     oss_lock(stream);
     stream->mute = !params->master_volume;
@@ -1478,15 +1393,6 @@ static NTSTATUS oss_is_started(void *args)
     return oss_unlock_result(stream, &params->result, stream->playing ? S_OK : S_FALSE);
 }
 
-static NTSTATUS oss_get_prop_value(void *args)
-{
-    struct get_prop_value_params *params = args;
-
-    params->result = E_NOTIMPL;
-
-    return STATUS_SUCCESS;
-}
-
 /* Aux driver */
 
 static unsigned int num_aux;
@@ -1704,11 +1610,11 @@ static NTSTATUS oss_aux_message(void *args)
     return STATUS_SUCCESS;
 }
 
-const unixlib_entry_t __wine_unix_call_funcs[] =
+unixlib_entry_t __wine_unix_call_funcs[] =
 {
-    oss_process_attach,
-    oss_not_implemented,
-    oss_main_loop,
+    NULL,
+    NULL,
+    NULL,
     oss_get_endpoint_ids,
     oss_create_stream,
     oss_release_stream,
@@ -1722,7 +1628,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     oss_release_capture_buffer,
     oss_is_format_supported,
     oss_get_mix_format,
-    oss_get_device_period,
+    NULL,
     oss_get_buffer_size,
     oss_get_latency,
     oss_get_current_padding,
@@ -1733,8 +1639,8 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     oss_set_event_handle,
     oss_test_connect,
     oss_is_started,
-    oss_get_prop_value,
-    oss_not_implemented,
+    NULL,
+    NULL,
     oss_midi_release,
     oss_midi_out_message,
     oss_midi_in_message,
@@ -1742,8 +1648,6 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     oss_aux_message,
 };
 
-C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == funcs_count);
-
 #ifdef _WIN64
 
 typedef UINT PTR32;
@@ -1764,19 +1668,6 @@ static NTSTATUS oss_wow64_test_connect(void *args)
     return STATUS_SUCCESS;
 }
 
-static NTSTATUS oss_wow64_main_loop(void *args)
-{
-    struct
-    {
-        PTR32 event;
-    } *params32 = args;
-    struct main_loop_params params =
-    {
-        .event = ULongToHandle(params32->event)
-    };
-    return oss_main_loop(&params);
-}
-
 static NTSTATUS oss_wow64_get_endpoint_ids(void *args)
 {
     struct
@@ -1948,28 +1839,6 @@ static NTSTATUS oss_wow64_get_mix_format(void *args)
     return STATUS_SUCCESS;
 }
 
-static NTSTATUS oss_wow64_get_device_period(void *args)
-{
-    struct
-    {
-        PTR32 device;
-        EDataFlow flow;
-        HRESULT result;
-        PTR32 def_period;
-        PTR32 min_period;
-    } *params32 = args;
-    struct get_device_period_params params =
-    {
-        .device = ULongToPtr(params32->device),
-        .flow = params32->flow,
-        .def_period = ULongToPtr(params32->def_period),
-        .min_period = ULongToPtr(params32->min_period),
-    };
-    oss_get_device_period(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
 static NTSTATUS oss_wow64_get_buffer_size(void *args)
 {
     struct
@@ -2090,6 +1959,7 @@ static NTSTATUS oss_wow64_set_volumes(void *args)
         float master_volume;
         PTR32 volumes;
         PTR32 session_volumes;
+        int channel;
     } *params32 = args;
     struct set_volumes_params params =
     {
@@ -2097,6 +1967,7 @@ static NTSTATUS oss_wow64_set_volumes(void *args)
         .master_volume = params32->master_volume,
         .volumes = ULongToPtr(params32->volumes),
         .session_volumes = ULongToPtr(params32->session_volumes),
+        .channel = params32->channel
     };
     return oss_set_volumes(&params);
 }
@@ -2120,62 +1991,6 @@ static NTSTATUS oss_wow64_set_event_handle(void *args)
     return STATUS_SUCCESS;
 }
 
-static NTSTATUS oss_wow64_get_prop_value(void *args)
-{
-    struct propvariant32
-    {
-        WORD vt;
-        WORD pad1, pad2, pad3;
-        union
-        {
-            ULONG ulVal;
-            PTR32 ptr;
-            ULARGE_INTEGER uhVal;
-        };
-    } *value32;
-    struct
-    {
-        PTR32 device;
-        EDataFlow flow;
-        PTR32 guid;
-        PTR32 prop;
-        HRESULT result;
-        PTR32 value;
-        PTR32 buffer; /* caller allocated buffer to hold value's strings */
-        PTR32 buffer_size;
-    } *params32 = args;
-    PROPVARIANT value;
-    struct get_prop_value_params params =
-    {
-        .device = ULongToPtr(params32->device),
-        .flow = params32->flow,
-        .guid = ULongToPtr(params32->guid),
-        .prop = ULongToPtr(params32->prop),
-        .value = &value,
-        .buffer = ULongToPtr(params32->buffer),
-        .buffer_size = ULongToPtr(params32->buffer_size)
-    };
-    oss_get_prop_value(&params);
-    params32->result = params.result;
-    if (SUCCEEDED(params.result))
-    {
-        value32 = UlongToPtr(params32->value);
-        value32->vt = value.vt;
-        switch (value.vt)
-        {
-        case VT_UI4:
-            value32->ulVal = value.ulVal;
-            break;
-        case VT_LPWSTR:
-            value32->ptr = params32->buffer;
-            break;
-        default:
-            FIXME("Unhandled vt %04x\n", value.vt);
-        }
-    }
-    return STATUS_SUCCESS;
-}
-
 static NTSTATUS oss_wow64_aux_message(void *args)
 {
     struct
@@ -2199,11 +2014,11 @@ static NTSTATUS oss_wow64_aux_message(void *args)
     return oss_aux_message(&params);
 }
 
-const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
+unixlib_entry_t __wine_unix_call_wow64_funcs[] =
 {
-    oss_process_attach,
-    oss_not_implemented,
-    oss_wow64_main_loop,
+    NULL,
+    NULL,
+    NULL,
     oss_wow64_get_endpoint_ids,
     oss_wow64_create_stream,
     oss_wow64_release_stream,
@@ -2217,7 +2032,7 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
     oss_release_capture_buffer,
     oss_wow64_is_format_supported,
     oss_wow64_get_mix_format,
-    oss_wow64_get_device_period,
+    NULL,
     oss_wow64_get_buffer_size,
     oss_wow64_get_latency,
     oss_wow64_get_current_padding,
@@ -2228,8 +2043,8 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
     oss_wow64_set_event_handle,
     oss_wow64_test_connect,
     oss_is_started,
-    oss_wow64_get_prop_value,
-    oss_not_implemented,
+    NULL,
+    NULL,
     oss_midi_release,
     oss_wow64_midi_out_message,
     oss_wow64_midi_in_message,
@@ -2237,6 +2052,4 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
     oss_wow64_aux_message,
 };
 
-C_ASSERT(ARRAYSIZE(__wine_unix_call_wow64_funcs) == funcs_count);
-
 #endif /* _WIN64 */
diff --git a/dlls/wineoss.drv/unixlib.h b/dlls/wineoss.drv/unixlib.h
index 11111111111..11111111111 100644
--- a/dlls/wineoss.drv/unixlib.h
+++ b/dlls/wineoss.drv/unixlib.h
@@ -18,15 +18,15 @@
 
 #include "../mmdevapi/unixlib.h"
 
-NTSTATUS oss_midi_release(void *args) DECLSPEC_HIDDEN;
-NTSTATUS oss_midi_out_message(void *args) DECLSPEC_HIDDEN;
-NTSTATUS oss_midi_in_message(void *args) DECLSPEC_HIDDEN;
-NTSTATUS oss_midi_notify_wait(void *args) DECLSPEC_HIDDEN;
+NTSTATUS oss_midi_release(void *args);
+NTSTATUS oss_midi_out_message(void *args);
+NTSTATUS oss_midi_in_message(void *args);
+NTSTATUS oss_midi_notify_wait(void *args);
 
 #ifdef _WIN64
-NTSTATUS oss_wow64_midi_out_message(void *args) DECLSPEC_HIDDEN;
-NTSTATUS oss_wow64_midi_in_message(void *args) DECLSPEC_HIDDEN;
-NTSTATUS oss_wow64_midi_notify_wait(void *args) DECLSPEC_HIDDEN;
+NTSTATUS oss_wow64_midi_out_message(void *args);
+NTSTATUS oss_wow64_midi_in_message(void *args);
+NTSTATUS oss_wow64_midi_notify_wait(void *args);
 #endif
 
 #define OSS_CALL(func, params) WINE_UNIX_CALL(func, params)
diff --git a/dlls/wineoss.drv/wineoss.drv.spec b/dlls/wineoss.drv/wineoss.drv.spec
index 11111111111..11111111111 100644
--- a/dlls/wineoss.drv/wineoss.drv.spec
+++ b/dlls/wineoss.drv/wineoss.drv.spec
@@ -5,5 +5,7 @@
 @ stdcall -private modMessage(long long long long long) OSS_modMessage
 
 # MMDevAPI driver functions
-@ stdcall -private get_device_guid(long ptr ptr) get_device_guid
-@ stdcall -private get_device_name_from_guid(ptr ptr ptr) get_device_name_from_guid
+@ stdcall -private GetPriority() AUDDRV_GetPriority
+@ stdcall -private GetEndpointIDs(long ptr ptr ptr ptr) AUDDRV_GetEndpointIDs
+@ stdcall -private GetAudioEndpoint(ptr ptr ptr) AUDDRV_GetAudioEndpoint
+@ stdcall -private GetAudioSessionManager(ptr ptr) AUDDRV_GetAudioSessionManager
diff --git a/dlls/winepulse.drv/Makefile.in b/dlls/winepulse.drv/Makefile.in
index 11111111111..11111111111 100644
--- a/dlls/winepulse.drv/Makefile.in
+++ b/dlls/winepulse.drv/Makefile.in
@@ -1,9 +1,9 @@
 MODULE    = winepulse.drv
-UNIXLIB   = winepulse.so
 IMPORTS   = dxguid uuid winmm user32 advapi32 ole32
-UNIX_LIBS    = $(PULSE_LIBS) $(PTHREAD_LIBS) -lm
+UNIX_LIBS    = $(PULSE_LIBS) $(PTHREAD_LIBS)
 UNIX_CFLAGS  = $(PULSE_CFLAGS)
 
-C_SRCS = \
-	mmdevdrv.c \
-	pulse.c
+EXTRADLLFLAGS = -mcygwin
+
+SOURCES = \
+	mmdevdrv.c
diff --git a/dlls/winepulse.drv/mmdevdrv.c b/dlls/winepulse.drv/mmdevdrv.c
index 11111111111..11111111111 100644
--- a/dlls/winepulse.drv/mmdevdrv.c
+++ b/dlls/winepulse.drv/mmdevdrv.c
@@ -2,7 +2,6 @@
  * Copyright 2011-2012 Maarten Lankhorst
  * Copyright 2010-2011 Maarten Lankhorst for CodeWeavers
  * Copyright 2011 Andrew Eikum for CodeWeavers
- * Copyright 2022 Huw Davies
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -19,27 +18,38 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#define NONAMELESSUNION
 #define COBJMACROS
+#undef  WINE_UNIX_LIB
+
+#include "config.h"
+#include <poll.h>
+#include <pthread.h>
 
 #include <stdarg.h>
-#include <assert.h>
-#include <wchar.h>
+#include <unistd.h>
+#include <math.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include <pulse/pulseaudio.h>
 
 #include "windef.h"
 #include "winbase.h"
-#include "winternl.h"
+#include "winnls.h"
+#include "winreg.h"
 #include "wine/debug.h"
+#include "wine/unicode.h"
 #include "wine/list.h"
-#include "wine/unixlib.h"
 
 #include "ole2.h"
-#include "mimeole.h"
 #include "dshow.h"
 #include "dsound.h"
 #include "propsys.h"
 #include "propkey.h"
 
 #include "initguid.h"
+#include "propkeydef.h"
 #include "ks.h"
 #include "ksmedia.h"
 #include "mmdeviceapi.h"
@@ -47,197 +57,5607 @@
 #include "endpointvolume.h"
 #include "audiopolicy.h"
 
-#include "../mmdevapi/unixlib.h"
-#include "../mmdevapi/mmdevdrv.h"
-
 WINE_DEFAULT_DEBUG_CHANNEL(pulse);
 
-#define MAX_PULSE_NAME_LEN 256
-
-static struct list g_devices_cache = LIST_INIT(g_devices_cache);
+#define NULL_PTR_ERR MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER)
 
-struct device_cache {
-    struct list entry;
-    GUID guid;
-    EDataFlow dataflow;
-    char pulse_name[0];
+/* From <dlls/mmdevapi/mmdevapi.h> */
+enum DriverPriority {
+    Priority_Unavailable = 0,
+    Priority_Low,
+    Priority_Neutral,
+    Priority_Preferred
 };
 
+static pa_context *pulse_ctx;
+static pa_mainloop *pulse_ml;
+
+static HANDLE pulse_thread;
+static pthread_mutex_t pulse_lock;
+static pthread_cond_t pulse_cond = PTHREAD_COND_INITIALIZER;
+static struct list g_sessions = LIST_INIT(g_sessions);
+
+static UINT g_phys_speakers_mask = 0;
+
+/* Mixer format + period times */
+static WAVEFORMATEXTENSIBLE pulse_fmt[2];
+static REFERENCE_TIME pulse_min_period[2], pulse_def_period[2];
+
 static GUID pulse_render_guid =
 { 0xfd47d9cc, 0x4218, 0x4135, { 0x9c, 0xe2, 0x0c, 0x19, 0x5c, 0x87, 0x40, 0x5b } };
 static GUID pulse_capture_guid =
 { 0x25da76d0, 0x033c, 0x4235, { 0x90, 0x02, 0x19, 0xf4, 0x88, 0x94, 0xac, 0x6f } };
 
-static WCHAR drv_key_devicesW[256];
+static UINT8 mult_alaw_sample(UINT8, float);
+static UINT8 mult_ulaw_sample(UINT8, float);
 
 BOOL WINAPI DllMain(HINSTANCE dll, DWORD reason, void *reserved)
 {
     if (reason == DLL_PROCESS_ATTACH) {
-        WCHAR buf[MAX_PATH];
-        WCHAR *filename;
+        pthread_mutexattr_t attr;
 
         DisableThreadLibraryCalls(dll);
-        if (__wine_init_unix_call())
-            return FALSE;
-
-        GetModuleFileNameW(dll, buf, ARRAY_SIZE(buf));
 
-        filename = wcsrchr(buf, '\\');
-        filename = filename ? filename + 1 : buf;
+        pthread_mutexattr_init(&attr);
+        pthread_mutexattr_setprotocol(&attr, PTHREAD_PRIO_INHERIT);
 
-        swprintf(drv_key_devicesW, ARRAY_SIZE(drv_key_devicesW),
-                 L"Software\\Wine\\Drivers\\%s\\devices", filename);
+        if (pthread_mutex_init(&pulse_lock, &attr) != 0)
+            pthread_mutex_init(&pulse_lock, NULL);
     } else if (reason == DLL_PROCESS_DETACH) {
-        struct device_cache *device, *device_next;
-
-        LIST_FOR_EACH_ENTRY_SAFE(device, device_next, &g_devices_cache, struct device_cache, entry)
-            free(device);
+        if (pulse_thread)
+           SetThreadPriority(pulse_thread, 0);
+        if (pulse_ctx) {
+            pa_context_disconnect(pulse_ctx);
+            pa_context_unref(pulse_ctx);
+        }
+        if (pulse_ml)
+            pa_mainloop_quit(pulse_ml, 0);
+        if (pulse_thread) {
+            WaitForSingleObject(pulse_thread, INFINITE);
+            CloseHandle(pulse_thread);
+        }
     }
     return TRUE;
 }
 
-void WINAPI get_device_guid(EDataFlow flow, const char *pulse_name, GUID *guid)
+typedef struct ACImpl ACImpl;
+
+typedef struct _AudioSession {
+    GUID guid;
+    struct list clients;
+
+    IMMDevice *device;
+
+    float master_vol;
+    UINT32 channel_count;
+    float *channel_vols;
+    BOOL mute;
+
+    struct list entry;
+} AudioSession;
+
+typedef struct _AudioSessionWrapper {
+    IAudioSessionControl2 IAudioSessionControl2_iface;
+    IChannelAudioVolume IChannelAudioVolume_iface;
+    ISimpleAudioVolume ISimpleAudioVolume_iface;
+
+    LONG ref;
+
+    ACImpl *client;
+    AudioSession *session;
+} AudioSessionWrapper;
+
+typedef struct _ACPacket {
+    struct list entry;
+    UINT64 qpcpos;
+    BYTE *data;
+    UINT32 discont;
+} ACPacket;
+
+struct ACImpl {
+    IAudioClient IAudioClient_iface;
+    IAudioRenderClient IAudioRenderClient_iface;
+    IAudioCaptureClient IAudioCaptureClient_iface;
+    IAudioClock IAudioClock_iface;
+    IAudioClock2 IAudioClock2_iface;
+    IAudioStreamVolume IAudioStreamVolume_iface;
+    IUnknown *marshal;
+    IMMDevice *parent;
+    struct list entry;
+    float vol[PA_CHANNELS_MAX];
+
+    LONG ref;
+    EDataFlow dataflow;
+    DWORD flags;
+    AUDCLNT_SHAREMODE share;
+    HANDLE event;
+
+    INT32 locked;
+    UINT32 bufsize_frames, bufsize_bytes, capture_period, pad, started, peek_ofs, wri_offs_bytes, lcl_offs_bytes;
+    UINT32 tmp_buffer_bytes, held_bytes, peek_len, peek_buffer_len;
+    BYTE *local_buffer, *tmp_buffer, *peek_buffer;
+    void *locked_ptr;
+
+    pa_stream *stream;
+    pa_sample_spec ss;
+    pa_channel_map map;
+    pa_buffer_attr attr;
+
+    INT64 clock_lastpos, clock_written;
+
+    AudioSession *session;
+    AudioSessionWrapper *session_wrapper;
+    struct list packet_free_head;
+    struct list packet_filled_head;
+};
+
+static const WCHAR defaultW[] = {'P','u','l','s','e','a','u','d','i','o',0};
+
+static const IAudioClientVtbl AudioClient_Vtbl;
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl;
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl;
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl;
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl;
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl;
+static const IAudioClockVtbl AudioClock_Vtbl;
+static const IAudioClock2Vtbl AudioClock2_Vtbl;
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl;
+
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client);
+
+static inline ACImpl *impl_from_IAudioClient(IAudioClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClient_iface);
+}
+
+static inline ACImpl *impl_from_IAudioRenderClient(IAudioRenderClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioRenderClient_iface);
+}
+
+static inline ACImpl *impl_from_IAudioCaptureClient(IAudioCaptureClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioCaptureClient_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IAudioSessionControl2(IAudioSessionControl2 *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IAudioSessionControl2_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_ISimpleAudioVolume(ISimpleAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, ISimpleAudioVolume_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IChannelAudioVolume(IChannelAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IChannelAudioVolume_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock(IAudioClock *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock2(IAudioClock2 *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock2_iface);
+}
+
+static inline ACImpl *impl_from_IAudioStreamVolume(IAudioStreamVolume *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioStreamVolume_iface);
+}
+
+/* Following pulseaudio design here, mainloop has the lock taken whenever
+ * it is handling something for pulse, and the lock is required whenever
+ * doing any pa_* call that can affect the state in any way
+ *
+ * pa_cond_wait is used when waiting on results, because the mainloop needs
+ * the same lock taken to affect the state
+ *
+ * This is basically the same as the pa_threaded_mainloop implementation,
+ * but that cannot be used because it uses pthread_create directly
+ *
+ * pa_threaded_mainloop_(un)lock -> pthread_mutex_(un)lock
+ * pa_threaded_mainloop_signal -> pthread_cond_broadcast
+ * pa_threaded_mainloop_wait -> pthread_cond_wait
+ */
+
+static int pulse_poll_func(struct pollfd *ufds, unsigned long nfds, int timeout, void *userdata) {
+    int r;
+    pthread_mutex_unlock(&pulse_lock);
+    r = poll(ufds, nfds, timeout);
+    pthread_mutex_lock(&pulse_lock);
+    return r;
+}
+
+static DWORD CALLBACK pulse_mainloop_thread(void *tmp) {
+    int ret;
+    pulse_ml = pa_mainloop_new();
+    pa_mainloop_set_poll_func(pulse_ml, pulse_poll_func, NULL);
+    pthread_mutex_lock(&pulse_lock);
+    pthread_cond_broadcast(&pulse_cond);
+    pa_mainloop_run(pulse_ml, &ret);
+    pthread_mutex_unlock(&pulse_lock);
+    pa_mainloop_free(pulse_ml);
+    return ret;
+}
+
+static void pulse_contextcallback(pa_context *c, void *userdata)
+{
+    switch (pa_context_get_state(c)) {
+        default:
+            FIXME("Unhandled state: %i\n", pa_context_get_state(c));
+            return;
+
+        case PA_CONTEXT_CONNECTING:
+        case PA_CONTEXT_UNCONNECTED:
+        case PA_CONTEXT_AUTHORIZING:
+        case PA_CONTEXT_SETTING_NAME:
+        case PA_CONTEXT_TERMINATED:
+            TRACE("State change to %i\n", pa_context_get_state(c));
+            return;
+
+        case PA_CONTEXT_READY:
+            TRACE("Ready\n");
+            break;
+
+        case PA_CONTEXT_FAILED:
+            WARN("Context failed: %s\n", pa_strerror(pa_context_errno(c)));
+            break;
+    }
+    pthread_cond_broadcast(&pulse_cond);
+}
+
+static void pulse_stream_state(pa_stream *s, void *user)
+{
+    pa_stream_state_t state = pa_stream_get_state(s);
+    TRACE("Stream state changed to %i\n", state);
+    pthread_cond_broadcast(&pulse_cond);
+}
+
+static const enum pa_channel_position pulse_pos_from_wfx[] = {
+    PA_CHANNEL_POSITION_FRONT_LEFT,
+    PA_CHANNEL_POSITION_FRONT_RIGHT,
+    PA_CHANNEL_POSITION_FRONT_CENTER,
+    PA_CHANNEL_POSITION_LFE,
+    PA_CHANNEL_POSITION_REAR_LEFT,
+    PA_CHANNEL_POSITION_REAR_RIGHT,
+    PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,
+    PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,
+    PA_CHANNEL_POSITION_REAR_CENTER,
+    PA_CHANNEL_POSITION_SIDE_LEFT,
+    PA_CHANNEL_POSITION_SIDE_RIGHT,
+    PA_CHANNEL_POSITION_TOP_CENTER,
+    PA_CHANNEL_POSITION_TOP_FRONT_LEFT,
+    PA_CHANNEL_POSITION_TOP_FRONT_CENTER,
+    PA_CHANNEL_POSITION_TOP_FRONT_RIGHT,
+    PA_CHANNEL_POSITION_TOP_REAR_LEFT,
+    PA_CHANNEL_POSITION_TOP_REAR_CENTER,
+    PA_CHANNEL_POSITION_TOP_REAR_RIGHT
+};
+
+static DWORD pulse_channel_map_to_channel_mask(const pa_channel_map *map)
+{
+    int i;
+    DWORD mask = 0;
+
+    for (i = 0; i < map->channels; ++i) {
+        switch (map->map[i]) {
+            default: FIXME("Unhandled channel %s\n", pa_channel_position_to_string(map->map[i])); break;
+            case PA_CHANNEL_POSITION_FRONT_LEFT: mask |= SPEAKER_FRONT_LEFT; break;
+            case PA_CHANNEL_POSITION_MONO:
+            case PA_CHANNEL_POSITION_FRONT_CENTER: mask |= SPEAKER_FRONT_CENTER; break;
+            case PA_CHANNEL_POSITION_FRONT_RIGHT: mask |= SPEAKER_FRONT_RIGHT; break;
+            case PA_CHANNEL_POSITION_REAR_LEFT: mask |= SPEAKER_BACK_LEFT; break;
+            case PA_CHANNEL_POSITION_REAR_CENTER: mask |= SPEAKER_BACK_CENTER; break;
+            case PA_CHANNEL_POSITION_REAR_RIGHT: mask |= SPEAKER_BACK_RIGHT; break;
+            case PA_CHANNEL_POSITION_LFE: mask |= SPEAKER_LOW_FREQUENCY; break;
+            case PA_CHANNEL_POSITION_SIDE_LEFT: mask |= SPEAKER_SIDE_LEFT; break;
+            case PA_CHANNEL_POSITION_SIDE_RIGHT: mask |= SPEAKER_SIDE_RIGHT; break;
+            case PA_CHANNEL_POSITION_TOP_CENTER: mask |= SPEAKER_TOP_CENTER; break;
+            case PA_CHANNEL_POSITION_TOP_FRONT_LEFT: mask |= SPEAKER_TOP_FRONT_LEFT; break;
+            case PA_CHANNEL_POSITION_TOP_FRONT_CENTER: mask |= SPEAKER_TOP_FRONT_CENTER; break;
+            case PA_CHANNEL_POSITION_TOP_FRONT_RIGHT: mask |= SPEAKER_TOP_FRONT_RIGHT; break;
+            case PA_CHANNEL_POSITION_TOP_REAR_LEFT: mask |= SPEAKER_TOP_BACK_LEFT; break;
+            case PA_CHANNEL_POSITION_TOP_REAR_CENTER: mask |= SPEAKER_TOP_BACK_CENTER; break;
+            case PA_CHANNEL_POSITION_TOP_REAR_RIGHT: mask |= SPEAKER_TOP_BACK_RIGHT; break;
+            case PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER: mask |= SPEAKER_FRONT_LEFT_OF_CENTER; break;
+            case PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER: mask |= SPEAKER_FRONT_RIGHT_OF_CENTER; break;
+        }
+    }
+
+    return mask;
+}
+
+/* For most hardware on Windows, users must choose a configuration with an even
+ * number of channels (stereo, quad, 5.1, 7.1). Users can then disable
+ * channels, but those channels are still reported to applications from
+ * GetMixFormat! Some applications behave badly if given an odd number of
+ * channels (e.g. 2.1).  Here, we find the nearest configuration that Windows
+ * would report for a given channel layout. */
+static void convert_channel_map(const pa_channel_map *pa_map, WAVEFORMATEXTENSIBLE *fmt)
 {
-    WCHAR key_name[MAX_PULSE_NAME_LEN + 2];
-    DWORD type, size = sizeof(*guid);
-    LSTATUS status;
-    HKEY drv_key, dev_key;
+    DWORD pa_mask = pulse_channel_map_to_channel_mask(pa_map);
 
-    if (!pulse_name[0]) {
-        *guid = (flow == eRender) ? pulse_render_guid : pulse_capture_guid;
+    TRACE("got mask for PA: 0x%x\n", pa_mask);
+
+    if (pa_map->channels == 1)
+    {
+        fmt->Format.nChannels = 1;
+        fmt->dwChannelMask = pa_mask;
+        return;
+    }
+
+    /* compare against known configurations and find smallest configuration
+     * which is a superset of the given speakers */
+
+    if (pa_map->channels <= 2 &&
+            (pa_mask & ~KSAUDIO_SPEAKER_STEREO) == 0)
+    {
+        fmt->Format.nChannels = 2;
+        fmt->dwChannelMask = KSAUDIO_SPEAKER_STEREO;
+        return;
+    }
+
+    if (pa_map->channels <= 4 &&
+            (pa_mask & ~KSAUDIO_SPEAKER_QUAD) == 0)
+    {
+        fmt->Format.nChannels = 4;
+        fmt->dwChannelMask = KSAUDIO_SPEAKER_QUAD;
         return;
     }
 
-    status = RegCreateKeyExW(HKEY_CURRENT_USER, drv_key_devicesW, 0, NULL, 0,
-                             KEY_WRITE | KEY_WOW64_64KEY, NULL, &drv_key, NULL);
-    if (status != ERROR_SUCCESS) {
-        ERR("Failed to open devices registry key: %lu\n", status);
-        CoCreateGuid(guid);
+    if (pa_map->channels <= 4 &&
+            (pa_mask & ~KSAUDIO_SPEAKER_SURROUND) == 0)
+    {
+        fmt->Format.nChannels = 4;
+        fmt->dwChannelMask = KSAUDIO_SPEAKER_SURROUND;
         return;
     }
 
-    key_name[0] = (flow == eRender) ? '0' : '1';
-    key_name[1] = ',';
-    MultiByteToWideChar(CP_UNIXCP, 0, pulse_name, -1, key_name + 2, ARRAY_SIZE(key_name) - 2);
+    if (pa_map->channels <= 6 &&
+            (pa_mask & ~KSAUDIO_SPEAKER_5POINT1) == 0)
+    {
+        fmt->Format.nChannels = 6;
+        fmt->dwChannelMask = KSAUDIO_SPEAKER_5POINT1;
+        return;
+    }
+
+    if (pa_map->channels <= 6 &&
+            (pa_mask & ~KSAUDIO_SPEAKER_5POINT1_SURROUND) == 0)
+    {
+        fmt->Format.nChannels = 6;
+        fmt->dwChannelMask = KSAUDIO_SPEAKER_5POINT1_SURROUND;
+        return;
+    }
 
-    status = RegCreateKeyExW(drv_key, key_name, 0, NULL, 0, KEY_READ | KEY_WRITE | KEY_WOW64_64KEY,
-                             NULL, &dev_key, NULL);
-    if (status != ERROR_SUCCESS) {
-        ERR("Failed to open registry key for device %s: %lu\n", pulse_name, status);
-        RegCloseKey(drv_key);
-        CoCreateGuid(guid);
+    if (pa_map->channels <= 8 &&
+            (pa_mask & ~KSAUDIO_SPEAKER_7POINT1) == 0)
+    {
+        fmt->Format.nChannels = 8;
+        fmt->dwChannelMask = KSAUDIO_SPEAKER_7POINT1;
         return;
     }
 
-    status = RegQueryValueExW(dev_key, L"guid", 0, &type, (BYTE*)guid, &size);
-    if (status != ERROR_SUCCESS || type != REG_BINARY || size != sizeof(*guid)) {
-        CoCreateGuid(guid);
-        status = RegSetValueExW(dev_key, L"guid", 0, REG_BINARY, (BYTE*)guid, sizeof(*guid));
-        if (status != ERROR_SUCCESS)
-            ERR("Failed to store device GUID for %s to registry: %lu\n", pulse_name, status);
+    if (pa_map->channels <= 8 &&
+            (pa_mask & ~KSAUDIO_SPEAKER_7POINT1_SURROUND) == 0)
+    {
+        fmt->Format.nChannels = 8;
+        fmt->dwChannelMask = KSAUDIO_SPEAKER_7POINT1_SURROUND;
+        return;
     }
-    RegCloseKey(dev_key);
-    RegCloseKey(drv_key);
+
+    /* oddball format, report truthfully */
+    fmt->Format.nChannels = pa_map->channels;
+    fmt->dwChannelMask = pa_mask;
 }
 
-BOOL WINAPI get_device_name_from_guid(GUID *guid, char **name, EDataFlow *flow)
-{
-    struct device_cache *device;
-    WCHAR key_name[MAX_PULSE_NAME_LEN + 2];
-    DWORD key_name_size;
-    DWORD index = 0;
-    HKEY key;
+static void pulse_probe_settings(int render, WAVEFORMATEXTENSIBLE *fmt) {
+    WAVEFORMATEX *wfx = &fmt->Format;
+    pa_stream *stream;
+    pa_channel_map map;
+    pa_sample_spec ss;
+    pa_buffer_attr attr;
+    int ret;
+    unsigned int length = 0;
 
-    *name = NULL;
+    pa_channel_map_init_auto(&map, 2, PA_CHANNEL_MAP_ALSA);
+    ss.rate = 48000;
+    ss.format = PA_SAMPLE_FLOAT32LE;
+    ss.channels = map.channels;
 
-    /* Return empty string for default PulseAudio device */
-    if (IsEqualGUID(guid, &pulse_render_guid)) {
-        *flow = eRender;
-        if (!(*name = malloc(1)))
-            return FALSE;
-    } else if (IsEqualGUID(guid, &pulse_capture_guid)) {
-        *flow = eCapture;
-        if (!(*name = malloc(1)))
-            return FALSE;
+    attr.maxlength = -1;
+    attr.tlength = -1;
+    attr.minreq = attr.fragsize = pa_frame_size(&ss);
+    attr.prebuf = 0;
+
+    stream = pa_stream_new(pulse_ctx, "format test stream", &ss, &map);
+    if (stream)
+        pa_stream_set_state_callback(stream, pulse_stream_state, NULL);
+    if (!stream)
+        ret = -1;
+    else if (render)
+        ret = pa_stream_connect_playback(stream, NULL, &attr,
+        PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS, NULL, NULL);
+    else
+        ret = pa_stream_connect_record(stream, NULL, &attr, PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS);
+    if (ret >= 0) {
+        while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0 &&
+                pa_stream_get_state(stream) == PA_STREAM_CREATING)
+        {}
+        if (pa_stream_get_state(stream) == PA_STREAM_READY) {
+            ss = *pa_stream_get_sample_spec(stream);
+            map = *pa_stream_get_channel_map(stream);
+            if (render)
+                length = pa_stream_get_buffer_attr(stream)->minreq;
+            else
+                length = pa_stream_get_buffer_attr(stream)->fragsize;
+            pa_stream_disconnect(stream);
+            while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0 &&
+                    pa_stream_get_state(stream) == PA_STREAM_READY)
+            {}
+        }
     }
 
-    if (*name) {
-        *name[0] = '\0';
-        return TRUE;
+    if (stream)
+        pa_stream_unref(stream);
+
+    if (length)
+        pulse_def_period[!render] = pulse_min_period[!render] = pa_bytes_to_usec(10 * length, &ss);
+
+    const char* penv = getenv("STAGING_AUDIO_PERIOD");
+    if (penv) {
+        int val = atoi(penv);
+        pulse_def_period[!render] = pulse_min_period[!render] = val;
+        printf("Staging audio period set to %d.\n", val);
     }
 
-    /* Check the cache first */
-    LIST_FOR_EACH_ENTRY(device, &g_devices_cache, struct device_cache, entry) {
-        if (!IsEqualGUID(guid, &device->guid))
-            continue;
-        *flow = device->dataflow;
-        if ((*name = strdup(device->pulse_name)))
-            return TRUE;
+    wfx->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
+    wfx->cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
+
+    convert_channel_map(&map, fmt);
+
+    wfx->wBitsPerSample = 8 * pa_sample_size_of_format(ss.format);
+    wfx->nSamplesPerSec = ss.rate;
+    wfx->nBlockAlign = wfx->nChannels * wfx->wBitsPerSample / 8;
+    wfx->nAvgBytesPerSec = wfx->nSamplesPerSec * wfx->nBlockAlign;
+    if (ss.format != PA_SAMPLE_S24_32LE)
+        fmt->Samples.wValidBitsPerSample = wfx->wBitsPerSample;
+    else
+        fmt->Samples.wValidBitsPerSample = 24;
+    if (ss.format == PA_SAMPLE_FLOAT32LE)
+        fmt->SubFormat = KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
+    else
+        fmt->SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
+}
+
+static HRESULT pulse_connect(void)
+{
+    int len;
+    WCHAR path[MAX_PATH], *name;
+    char *str;
 
-        return FALSE;
+    if (!pulse_thread)
+    {
+        if (!(pulse_thread = CreateThread(NULL, 0, pulse_mainloop_thread, NULL, 0, NULL)))
+        {
+            ERR("Failed to create mainloop thread.\n");
+            return E_FAIL;
+        }
+        SetThreadPriority(pulse_thread, THREAD_PRIORITY_TIME_CRITICAL);
+        pthread_cond_wait(&pulse_cond, &pulse_lock);
     }
 
-    if (RegOpenKeyExW(HKEY_CURRENT_USER, drv_key_devicesW, 0, KEY_READ | KEY_WOW64_64KEY, &key) != ERROR_SUCCESS) {
-        WARN("No devices found in registry\n");
-        return FALSE;
+    if (pulse_ctx && PA_CONTEXT_IS_GOOD(pa_context_get_state(pulse_ctx)))
+        return S_OK;
+    if (pulse_ctx)
+        pa_context_unref(pulse_ctx);
+
+    GetModuleFileNameW(NULL, path, ARRAY_SIZE(path));
+    name = strrchrW(path, '\\');
+    if (!name)
+        name = path;
+    else
+        name++;
+    len = WideCharToMultiByte(CP_UNIXCP, 0, name, -1, NULL, 0, NULL, NULL);
+    str = pa_xmalloc(len);
+    WideCharToMultiByte(CP_UNIXCP, 0, name, -1, str, len, NULL, NULL);
+    TRACE("Name: %s\n", str);
+    pulse_ctx = pa_context_new(pa_mainloop_get_api(pulse_ml), str);
+    pa_xfree(str);
+    if (!pulse_ctx) {
+        ERR("Failed to create context\n");
+        return E_FAIL;
     }
 
-    for (;;) {
-        DWORD size, type;
-        LSTATUS status;
-        GUID reg_guid;
-        HKEY dev_key;
-        int len;
+    pa_context_set_state_callback(pulse_ctx, pulse_contextcallback, NULL);
+
+    TRACE("libpulse protocol version: %u. API Version %u\n", pa_context_get_protocol_version(pulse_ctx), PA_API_VERSION);
+    if (pa_context_connect(pulse_ctx, NULL, 0, NULL) < 0)
+        goto fail;
 
-        key_name_size = ARRAY_SIZE(key_name);
-        if (RegEnumKeyExW(key, index++, key_name, &key_name_size, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
+    /* Wait for connection */
+    while (pthread_cond_wait(&pulse_cond, &pulse_lock)) {
+        pa_context_state_t state = pa_context_get_state(pulse_ctx);
+
+        if (state == PA_CONTEXT_FAILED || state == PA_CONTEXT_TERMINATED)
+            goto fail;
+
+        if (state == PA_CONTEXT_READY)
             break;
+    }
 
-        if (RegOpenKeyExW(key, key_name, 0, KEY_READ | KEY_WOW64_64KEY, &dev_key) != ERROR_SUCCESS) {
-            ERR("Couldn't open key: %s\n", wine_dbgstr_w(key_name));
-            continue;
-        }
+    TRACE("Connected to server %s with protocol version: %i.\n",
+        pa_context_get_server(pulse_ctx),
+        pa_context_get_server_protocol_version(pulse_ctx));
+    return S_OK;
 
-        size = sizeof(reg_guid);
-        status = RegQueryValueExW(dev_key, L"guid", 0, &type, (BYTE *)&reg_guid, &size);
-        RegCloseKey(dev_key);
+fail:
+    pa_context_unref(pulse_ctx);
+    pulse_ctx = NULL;
+    return E_FAIL;
+}
+
+/* For default PulseAudio render device, OR together all of the
+ * PKEY_AudioEndpoint_PhysicalSpeakers values of the sinks. */
+static void pulse_phys_speakers_cb(pa_context *c, const pa_sink_info *i, int eol, void *userdata)
+{
+    if (i)
+        g_phys_speakers_mask |= pulse_channel_map_to_channel_mask(&i->channel_map);
+}
 
-        if (status == ERROR_SUCCESS && type == REG_BINARY && size == sizeof(reg_guid) && IsEqualGUID(&reg_guid, guid)) {
-            RegCloseKey(key);
+/* some poorly-behaved applications call audio functions during DllMain, so we
+ * have to do as much as possible without creating a new thread. this function
+ * sets up a synchronous connection to verify the server is running and query
+ * static data. */
+static HRESULT pulse_test_connect(void)
+{
+    int len, ret;
+    WCHAR path[MAX_PATH], *name;
+    char *str;
+    pa_operation *o;
 
-            TRACE("Found matching device key: %s\n", wine_dbgstr_w(key_name));
+    pulse_ml = pa_mainloop_new();
 
-            if (key_name[0] == '0')
-                *flow = eRender;
-            else if (key_name[0] == '1')
-                *flow = eCapture;
-            else {
-                WARN("Unknown device type: %c\n", key_name[0]);
-                return FALSE;
-            }
+    pa_mainloop_set_poll_func(pulse_ml, pulse_poll_func, NULL);
+
+    GetModuleFileNameW(NULL, path, ARRAY_SIZE(path));
+    name = strrchrW(path, '\\');
+    if (!name)
+        name = path;
+    else
+        name++;
+    len = WideCharToMultiByte(CP_UNIXCP, 0, name, -1, NULL, 0, NULL, NULL);
+    str = pa_xmalloc(len);
+    WideCharToMultiByte(CP_UNIXCP, 0, name, -1, str, len, NULL, NULL);
+    TRACE("Name: %s\n", str);
+    pulse_ctx = pa_context_new(pa_mainloop_get_api(pulse_ml), str);
+    pa_xfree(str);
+    if (!pulse_ctx) {
+        ERR("Failed to create context\n");
+        pa_mainloop_free(pulse_ml);
+        pulse_ml = NULL;
+        return E_FAIL;
+    }
+
+    pa_context_set_state_callback(pulse_ctx, pulse_contextcallback, NULL);
+
+    TRACE("libpulse protocol version: %u. API Version %u\n", pa_context_get_protocol_version(pulse_ctx), PA_API_VERSION);
+    if (pa_context_connect(pulse_ctx, NULL, 0, NULL) < 0)
+        goto fail;
+
+    /* Wait for connection */
+    while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0) {
+        pa_context_state_t state = pa_context_get_state(pulse_ctx);
+
+        if (state == PA_CONTEXT_FAILED || state == PA_CONTEXT_TERMINATED)
+            goto fail;
+
+        if (state == PA_CONTEXT_READY)
+            break;
+    }
+
+    if (pa_context_get_state(pulse_ctx) != PA_CONTEXT_READY)
+        goto fail;
+
+    TRACE("Test-connected to server %s with protocol version: %i.\n",
+        pa_context_get_server(pulse_ctx),
+        pa_context_get_server_protocol_version(pulse_ctx));
+
+    pulse_probe_settings(1, &pulse_fmt[0]);
+    pulse_probe_settings(0, &pulse_fmt[1]);
+
+    g_phys_speakers_mask = 0;
+    o = pa_context_get_sink_info_list(pulse_ctx, &pulse_phys_speakers_cb, NULL);
+    if (o) {
+        while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0 &&
+                pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+        {}
+        pa_operation_unref(o);
+    }
+
+    pa_context_unref(pulse_ctx);
+    pulse_ctx = NULL;
+    pa_mainloop_free(pulse_ml);
+    pulse_ml = NULL;
+
+    return S_OK;
+
+fail:
+    pa_context_unref(pulse_ctx);
+    pulse_ctx = NULL;
+    pa_mainloop_free(pulse_ml);
+    pulse_ml = NULL;
+
+    return E_FAIL;
+}
+
+static HRESULT pulse_stream_valid(ACImpl *This) {
+    if (!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+    if (pa_stream_get_state(This->stream) != PA_STREAM_READY)
+        return AUDCLNT_E_DEVICE_INVALIDATED;
+    return S_OK;
+}
+
+static void silence_buffer(pa_sample_format_t format, BYTE *buffer, UINT32 bytes)
+{
+    memset(buffer, format == PA_SAMPLE_U8 ? 0x80 : 0, bytes);
+}
+
+static void pulse_free_noop(void *buf)
+{
+}
+
+enum write_buffer_flags
+{
+    WINEPULSE_WRITE_NOFREE = 0x01,
+    WINEPULSE_WRITE_SILENT = 0x02
+};
+
+static int write_buffer(const ACImpl *This, BYTE *buffer, UINT32 bytes,
+                        enum write_buffer_flags flags)
+{
+    float vol[PA_CHANNELS_MAX];
+    BOOL adjust = FALSE;
+    UINT32 i, channels;
+    BYTE *end;
+
+    if (!bytes) return 0;
+    if (This->session->mute || (flags & WINEPULSE_WRITE_SILENT))
+    {
+        silence_buffer(This->ss.format, buffer, bytes);
+        goto write;
+    }
 
-            if (!(len = WideCharToMultiByte(CP_UNIXCP, 0, key_name + 2, -1, NULL, 0, NULL, NULL)))
-                    return FALSE;
+    /* Adjust the buffer based on the volume for each channel */
+    channels = This->ss.channels;
+    for (i = 0; i < channels; i++)
+    {
+        vol[i] = This->vol[i] * This->session->master_vol * This->session->channel_vols[i];
+        adjust |= vol[i] != 1.0f;
+    }
+    if (!adjust) goto write;
 
-            if (!(*name = malloc(len)))
-                return FALSE;
+    end = buffer + bytes;
+    switch (This->ss.format)
+    {
+#ifndef WORDS_BIGENDIAN
+#define PROCESS_BUFFER(type) do         \
+{                                       \
+    type *p = (type*)buffer;            \
+    do                                  \
+    {                                   \
+        for (i = 0; i < channels; i++)  \
+            p[i] = p[i] * vol[i];       \
+        p += i;                         \
+    } while ((BYTE*)p != end);          \
+} while (0)
+    case PA_SAMPLE_S16LE:
+        PROCESS_BUFFER(INT16);
+        break;
+    case PA_SAMPLE_S32LE:
+        PROCESS_BUFFER(INT32);
+        break;
+    case PA_SAMPLE_FLOAT32LE:
+        PROCESS_BUFFER(float);
+        break;
+#undef PROCESS_BUFFER
+    case PA_SAMPLE_S24_32LE:
+    {
+        UINT32 *p = (UINT32*)buffer;
+        do
+        {
+            for (i = 0; i < channels; i++)
+            {
+                p[i] = (INT32)((INT32)(p[i] << 8) * vol[i]);
+                p[i] >>= 8;
+            }
+            p += i;
+        } while ((BYTE*)p != end);
+        break;
+    }
+    case PA_SAMPLE_S24LE:
+    {
+        /* do it 12 bytes at a time until it is no longer possible */
+        UINT32 *q = (UINT32*)buffer;
+        BYTE *p;
 
-            if (!WideCharToMultiByte(CP_UNIXCP, 0, key_name + 2, -1, *name, len, NULL, NULL)) {
-                free(*name);
-                return FALSE;
+        i = 0;
+        while (end - (BYTE*)q >= 12)
+        {
+            UINT32 v[4], k;
+            v[0] = q[0] << 8;
+            v[1] = q[1] << 16 | (q[0] >> 16 & ~0xff);
+            v[2] = q[2] << 24 | (q[1] >> 8  & ~0xff);
+            v[3] = q[2] & ~0xff;
+            for (k = 0; k < 4; k++)
+            {
+                v[k] = (INT32)((INT32)v[k] * vol[i]);
+                if (++i == channels) i = 0;
             }
+            *q++ = v[0] >> 8  | (v[1] & ~0xff) << 16;
+            *q++ = v[1] >> 16 | (v[2] & ~0xff) << 8;
+            *q++ = v[2] >> 24 | (v[3] & ~0xff);
+        }
+        p = (BYTE*)q;
+        while (p != end)
+        {
+            UINT32 v = (INT32)((INT32)(p[0] << 8 | p[1] << 16 | p[2] << 24) * vol[i]);
+            *p++ = v >> 8  & 0xff;
+            *p++ = v >> 16 & 0xff;
+            *p++ = v >> 24;
+            if (++i == channels) i = 0;
+        }
+        break;
+    }
+#endif
+    case PA_SAMPLE_U8:
+    {
+        UINT8 *p = (UINT8*)buffer;
+        do
+        {
+            for (i = 0; i < channels; i++)
+                p[i] = (int)((p[i] - 128) * vol[i]) + 128;
+            p += i;
+        } while ((BYTE*)p != end);
+        break;
+    }
+    case PA_SAMPLE_ALAW:
+    {
+        UINT8 *p = (UINT8*)buffer;
+        do
+        {
+            for (i = 0; i < channels; i++)
+                p[i] = mult_alaw_sample(p[i], vol[i]);
+            p += i;
+        } while ((BYTE*)p != end);
+        break;
+    }
+    case PA_SAMPLE_ULAW:
+    {
+        UINT8 *p = (UINT8*)buffer;
+        do
+        {
+            for (i = 0; i < channels; i++)
+                p[i] = mult_ulaw_sample(p[i], vol[i]);
+            p += i;
+        } while ((BYTE*)p != end);
+        break;
+    }
+    default:
+        TRACE("Unhandled format %i, not adjusting volume.\n", This->ss.format);
+        break;
+    }
+
+write:
+    return pa_stream_write(This->stream, buffer, bytes,
+                           (flags & WINEPULSE_WRITE_NOFREE) ? pulse_free_noop : NULL,
+                           0, PA_SEEK_RELATIVE);
+}
+
+static void dump_attr(const pa_buffer_attr *attr) {
+    TRACE("maxlength: %u\n", attr->maxlength);
+    TRACE("minreq: %u\n", attr->minreq);
+    TRACE("fragsize: %u\n", attr->fragsize);
+    TRACE("tlength: %u\n", attr->tlength);
+    TRACE("prebuf: %u\n", attr->prebuf);
+}
+
+static void pulse_op_cb(pa_stream *s, int success, void *user) {
+    TRACE("Success: %i\n", success);
+    *(int*)user = success;
+    pthread_cond_broadcast(&pulse_cond);
+}
+
+static void pulse_attr_update(pa_stream *s, void *user) {
+    const pa_buffer_attr *attr = pa_stream_get_buffer_attr(s);
+    TRACE("New attributes or device moved:\n");
+    dump_attr(attr);
+}
+
+/* Here's the buffer setup:
+ *
+ *  vvvvvvvv sent to HW already
+ *          vvvvvvvv in Pulse buffer but rewindable
+ * [dddddddddddddddd] Pulse buffer
+ *         [dddddddddddddddd--------] mmdevapi buffer
+ *          ^^^^^^^^^^^^^^^^ pad
+ *                  ^ lcl_offs_bytes
+ *                  ^^^^^^^^^ held_bytes
+ *                          ^ wri_offs_bytes
+ *
+ * GetCurrentPadding is pad
+ *
+ * During pulse_wr_callback, we decrement pad, fill Pulse buffer, and move
+ *   lcl_offs forward
+ *
+ * During Stop, we flush the Pulse buffer
+ */
+static void pulse_wr_callback(pa_stream *s, size_t bytes, void *userdata)
+{
+    ACImpl *This = userdata;
+    UINT32 oldpad = This->pad;
+
+    if(This->local_buffer){
+        UINT32 to_write;
+        BYTE *buf = This->local_buffer + This->lcl_offs_bytes;
+
+        if(This->pad > bytes){
+            This->clock_written += bytes;
+            This->pad -= bytes;
+        }else{
+            This->clock_written += This->pad;
+            This->pad = 0;
+        }
+
+        bytes = min(bytes, This->held_bytes);
+
+        if(This->lcl_offs_bytes + bytes > This->bufsize_bytes){
+            to_write = This->bufsize_bytes - This->lcl_offs_bytes;
+            TRACE("writing small chunk of %u bytes\n", to_write);
+            write_buffer(This, buf, to_write, 0);
+            This->held_bytes -= to_write;
+            to_write = bytes - to_write;
+            This->lcl_offs_bytes = 0;
+            buf = This->local_buffer;
+        }else
+            to_write = bytes;
+
+        TRACE("writing main chunk of %u bytes\n", to_write);
+        write_buffer(This, buf, to_write, 0);
+        This->lcl_offs_bytes += to_write;
+        This->lcl_offs_bytes %= This->bufsize_bytes;
+        This->held_bytes -= to_write;
+    }else{
+        if (bytes < This->bufsize_bytes)
+            This->pad = This->bufsize_bytes - bytes;
+        else
+            This->pad = 0;
+
+        if (oldpad == This->pad)
+            return;
+
+        assert(oldpad > This->pad);
+
+        This->clock_written += oldpad - This->pad;
+        TRACE("New pad: %zu (-%zu)\n", This->pad / pa_frame_size(&This->ss), (oldpad - This->pad) / pa_frame_size(&This->ss));
+    }
+
+    if (This->event)
+        SetEvent(This->event);
+}
+
+static void pulse_underflow_callback(pa_stream *s, void *userdata)
+{
+    WARN("Underflow\n");
+}
+
+/* Latency is periodically updated even when nothing is played,
+ * because of PA_STREAM_AUTO_TIMING_UPDATE so use it as timer
+ *
+ * Perfect for passing all tests :)
+ */
+static void pulse_latency_callback(pa_stream *s, void *userdata)
+{
+    ACImpl *This = userdata;
+    if (!This->pad && This->event)
+        SetEvent(This->event);
+}
+
+static void pulse_started_callback(pa_stream *s, void *userdata)
+{
+    TRACE("(Re)started playing\n");
+}
+
+static void pulse_rd_loop(ACImpl *This, size_t bytes)
+{
+    while (bytes >= This->capture_period) {
+        ACPacket *p, *next;
+        LARGE_INTEGER stamp, freq;
+        BYTE *dst, *src;
+        size_t src_len, copy, rem = This->capture_period;
+        if (!(p = (ACPacket*)list_head(&This->packet_free_head))) {
+            p = (ACPacket*)list_head(&This->packet_filled_head);
+            if (!p->discont) {
+                next = (ACPacket*)p->entry.next;
+                next->discont = 1;
+            } else
+                p = (ACPacket*)list_tail(&This->packet_filled_head);
+            assert(This->pad == This->bufsize_bytes);
+        } else {
+            assert(This->pad < This->bufsize_bytes);
+            This->pad += This->capture_period;
+            assert(This->pad <= This->bufsize_bytes);
+        }
+        QueryPerformanceCounter(&stamp);
+        QueryPerformanceFrequency(&freq);
+        p->qpcpos = (stamp.QuadPart * (INT64)10000000) / freq.QuadPart;
+        p->discont = 0;
+        list_remove(&p->entry);
+        list_add_tail(&This->packet_filled_head, &p->entry);
+
+        dst = p->data;
+        while (rem) {
+            if (This->peek_len) {
+                copy = min(rem, This->peek_len - This->peek_ofs);
+
+                memcpy(dst, This->peek_buffer + This->peek_ofs, copy);
+
+                rem -= copy;
+                dst += copy;
+                This->peek_ofs += copy;
+                if(This->peek_len == This->peek_ofs)
+                    This->peek_len = 0;
+            } else {
+                pa_stream_peek(This->stream, (const void**)&src, &src_len);
+
+                copy = min(rem, src_len);
 
-            if ((device = malloc(FIELD_OFFSET(struct device_cache, pulse_name[len])))) {
-                device->guid = reg_guid;
-                device->dataflow = *flow;
-                memcpy(device->pulse_name, *name, len);
-                list_add_tail(&g_devices_cache, &device->entry);
+                memcpy(dst, src, rem);
+
+                dst += copy;
+                rem -= copy;
+
+                if (copy < src_len) {
+                    if (src_len > This->peek_buffer_len) {
+                        HeapFree(GetProcessHeap(), 0, This->peek_buffer);
+                        This->peek_buffer = HeapAlloc(GetProcessHeap(), 0, src_len);
+                        This->peek_buffer_len = src_len;
+                    }
+
+                    memcpy(This->peek_buffer, src + copy, src_len - copy);
+                    This->peek_len = src_len - copy;
+                    This->peek_ofs = 0;
+                }
+
+                pa_stream_drop(This->stream);
             }
-            return TRUE;
         }
+
+        bytes -= This->capture_period;
+    }
+}
+
+static void pulse_rd_drop(ACImpl *This, size_t bytes)
+{
+    while (bytes >= This->capture_period) {
+        size_t src_len, copy, rem = This->capture_period;
+        while (rem) {
+            const void *src;
+            pa_stream_peek(This->stream, &src, &src_len);
+            assert(src_len);
+            assert(This->peek_ofs < src_len);
+            src_len -= This->peek_ofs;
+            assert(src_len <= bytes);
+
+            copy = rem;
+            if (copy > src_len)
+                copy = src_len;
+
+            src_len -= copy;
+            rem -= copy;
+
+            if (!src_len) {
+                This->peek_ofs = 0;
+                pa_stream_drop(This->stream);
+            } else
+                This->peek_ofs += copy;
+            bytes -= copy;
+        }
+    }
+}
+
+static void pulse_rd_callback(pa_stream *s, size_t bytes, void *userdata)
+{
+    ACImpl *This = userdata;
+
+    TRACE("Readable total: %zu, fragsize: %u\n", bytes, pa_stream_get_buffer_attr(s)->fragsize);
+    assert(bytes >= This->peek_ofs);
+    bytes -= This->peek_ofs;
+    if (bytes < This->capture_period)
+        return;
+
+    if (This->started)
+        pulse_rd_loop(This, bytes);
+    else
+        pulse_rd_drop(This, bytes);
+
+    if (This->event)
+        SetEvent(This->event);
+}
+
+static HRESULT pulse_stream_connect(ACImpl *This, UINT32 period_bytes) {
+    int ret;
+    char buffer[64];
+    static LONG number;
+    pa_buffer_attr attr;
+    if (This->stream) {
+        pa_stream_disconnect(This->stream);
+        while (pa_stream_get_state(This->stream) == PA_STREAM_READY)
+            pthread_cond_wait(&pulse_cond, &pulse_lock);
+        pa_stream_unref(This->stream);
+    }
+    ret = InterlockedIncrement(&number);
+    sprintf(buffer, "audio stream #%i", ret);
+    This->stream = pa_stream_new(pulse_ctx, buffer, &This->ss, &This->map);
+
+    if (!This->stream) {
+        WARN("pa_stream_new returned error %i\n", pa_context_errno(pulse_ctx));
+        return AUDCLNT_E_ENDPOINT_CREATE_FAILED;
+    }
+
+    pa_stream_set_state_callback(This->stream, pulse_stream_state, This);
+    pa_stream_set_buffer_attr_callback(This->stream, pulse_attr_update, This);
+    pa_stream_set_moved_callback(This->stream, pulse_attr_update, This);
+
+    /* PulseAudio will fill in correct values */
+    attr.minreq = attr.fragsize = period_bytes;
+    attr.maxlength = attr.tlength = This->bufsize_bytes;
+    attr.prebuf = pa_frame_size(&This->ss);
+    dump_attr(&attr);
+    if (This->dataflow == eRender)
+        ret = pa_stream_connect_playback(This->stream, NULL, &attr,
+        PA_STREAM_START_CORKED|PA_STREAM_START_UNMUTED|PA_STREAM_AUTO_TIMING_UPDATE|PA_STREAM_INTERPOLATE_TIMING|PA_STREAM_EARLY_REQUESTS, NULL, NULL);
+    else
+        ret = pa_stream_connect_record(This->stream, NULL, &attr,
+        PA_STREAM_START_CORKED|PA_STREAM_START_UNMUTED|PA_STREAM_AUTO_TIMING_UPDATE|PA_STREAM_INTERPOLATE_TIMING|PA_STREAM_EARLY_REQUESTS);
+    if (ret < 0) {
+        WARN("Returns %i\n", ret);
+        return AUDCLNT_E_ENDPOINT_CREATE_FAILED;
     }
+    while (pa_stream_get_state(This->stream) == PA_STREAM_CREATING)
+        pthread_cond_wait(&pulse_cond, &pulse_lock);
+    if (pa_stream_get_state(This->stream) != PA_STREAM_READY)
+        return AUDCLNT_E_ENDPOINT_CREATE_FAILED;
+
+    if (This->dataflow == eRender) {
+        pa_stream_set_write_callback(This->stream, pulse_wr_callback, This);
+        pa_stream_set_underflow_callback(This->stream, pulse_underflow_callback, This);
+        pa_stream_set_started_callback(This->stream, pulse_started_callback, This);
+    } else
+        pa_stream_set_read_callback(This->stream, pulse_rd_callback, This);
+    return S_OK;
+}
+
+HRESULT WINAPI AUDDRV_GetEndpointIDs(EDataFlow flow, const WCHAR ***ids, GUID **keys,
+        UINT *num, UINT *def_index)
+{
+    WCHAR *id;
+
+    TRACE("%d %p %p %p\n", flow, ids, num, def_index);
+
+    *num = 1;
+    *def_index = 0;
+
+    *ids = HeapAlloc(GetProcessHeap(), 0, sizeof(**ids));
+    *keys = NULL;
+    if (!*ids)
+        return E_OUTOFMEMORY;
+
+    (*ids)[0] = id = HeapAlloc(GetProcessHeap(), 0, sizeof(defaultW));
+    *keys = HeapAlloc(GetProcessHeap(), 0, sizeof(**keys));
+    if (!*keys || !id) {
+        HeapFree(GetProcessHeap(), 0, id);
+        HeapFree(GetProcessHeap(), 0, *keys);
+        HeapFree(GetProcessHeap(), 0, *ids);
+        *ids = NULL;
+        *keys = NULL;
+        return E_OUTOFMEMORY;
+    }
+    memcpy(id, defaultW, sizeof(defaultW));
+
+    if (flow == eRender)
+        (*keys)[0] = pulse_render_guid;
+    else
+        (*keys)[0] = pulse_capture_guid;
+
+    return S_OK;
+}
+
+int WINAPI AUDDRV_GetPriority(void)
+{
+    HRESULT hr;
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_test_connect();
+    pthread_mutex_unlock(&pulse_lock);
+    return SUCCEEDED(hr) ? Priority_Preferred : Priority_Unavailable;
+}
+
+HRESULT WINAPI AUDDRV_GetAudioEndpoint(GUID *guid, IMMDevice *dev, IAudioClient **out)
+{
+    ACImpl *This;
+    int i;
+    EDataFlow dataflow;
+    HRESULT hr;
+
+    TRACE("%s %p %p\n", debugstr_guid(guid), dev, out);
+    if (IsEqualGUID(guid, &pulse_render_guid))
+        dataflow = eRender;
+    else if (IsEqualGUID(guid, &pulse_capture_guid))
+        dataflow = eCapture;
+    else
+        return E_UNEXPECTED;
+
+    *out = NULL;
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*This));
+    if (!This)
+        return E_OUTOFMEMORY;
+
+    This->IAudioClient_iface.lpVtbl = &AudioClient_Vtbl;
+    This->IAudioRenderClient_iface.lpVtbl = &AudioRenderClient_Vtbl;
+    This->IAudioCaptureClient_iface.lpVtbl = &AudioCaptureClient_Vtbl;
+    This->IAudioClock_iface.lpVtbl = &AudioClock_Vtbl;
+    This->IAudioClock2_iface.lpVtbl = &AudioClock2_Vtbl;
+    This->IAudioStreamVolume_iface.lpVtbl = &AudioStreamVolume_Vtbl;
+    This->dataflow = dataflow;
+    This->parent = dev;
+    for (i = 0; i < PA_CHANNELS_MAX; ++i)
+        This->vol[i] = 1.f;
+
+    hr = CoCreateFreeThreadedMarshaler((IUnknown*)&This->IAudioClient_iface, &This->marshal);
+    if (hr) {
+        HeapFree(GetProcessHeap(), 0, This);
+        return hr;
+    }
+    IMMDevice_AddRef(This->parent);
+
+    *out = &This->IAudioClient_iface;
+    IAudioClient_AddRef(&This->IAudioClient_iface);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_QueryInterface(IAudioClient *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+
+    *ppv = NULL;
+    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IAudioClient))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    if (IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->marshal, riid, ppv);
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClient_AddRef(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioClient_Release(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    if (!ref) {
+        if (This->stream) {
+            pthread_mutex_lock(&pulse_lock);
+            if (PA_STREAM_IS_GOOD(pa_stream_get_state(This->stream))) {
+                pa_stream_disconnect(This->stream);
+                while (PA_STREAM_IS_GOOD(pa_stream_get_state(This->stream)))
+                    pthread_cond_wait(&pulse_cond, &pulse_lock);
+            }
+            pa_stream_unref(This->stream);
+            This->stream = NULL;
+            list_remove(&This->entry);
+            pthread_mutex_unlock(&pulse_lock);
+        }
+        IUnknown_Release(This->marshal);
+        IMMDevice_Release(This->parent);
+        HeapFree(GetProcessHeap(), 0, This->tmp_buffer);
+        HeapFree(GetProcessHeap(), 0, This->peek_buffer);
+        HeapFree(GetProcessHeap(), 0, This->local_buffer);
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static void dump_fmt(const WAVEFORMATEX *fmt)
+{
+    TRACE("wFormatTag: 0x%x (", fmt->wFormatTag);
+    switch(fmt->wFormatTag) {
+    case WAVE_FORMAT_PCM:
+        TRACE("WAVE_FORMAT_PCM");
+        break;
+    case WAVE_FORMAT_IEEE_FLOAT:
+        TRACE("WAVE_FORMAT_IEEE_FLOAT");
+        break;
+    case WAVE_FORMAT_EXTENSIBLE:
+        TRACE("WAVE_FORMAT_EXTENSIBLE");
+        break;
+    default:
+        TRACE("Unknown");
+        break;
+    }
+    TRACE(")\n");
+
+    TRACE("nChannels: %u\n", fmt->nChannels);
+    TRACE("nSamplesPerSec: %u\n", fmt->nSamplesPerSec);
+    TRACE("nAvgBytesPerSec: %u\n", fmt->nAvgBytesPerSec);
+    TRACE("nBlockAlign: %u\n", fmt->nBlockAlign);
+    TRACE("wBitsPerSample: %u\n", fmt->wBitsPerSample);
+    TRACE("cbSize: %u\n", fmt->cbSize);
+
+    if (fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
+        WAVEFORMATEXTENSIBLE *fmtex = (void*)fmt;
+        TRACE("dwChannelMask: %08x\n", fmtex->dwChannelMask);
+        TRACE("Samples: %04x\n", fmtex->Samples.wReserved);
+        TRACE("SubFormat: %s\n", wine_dbgstr_guid(&fmtex->SubFormat));
+    }
+}
+
+static WAVEFORMATEX *clone_format(const WAVEFORMATEX *fmt)
+{
+    WAVEFORMATEX *ret;
+    size_t size;
+
+    if (fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
+        size = sizeof(WAVEFORMATEXTENSIBLE);
+    else
+        size = sizeof(WAVEFORMATEX);
+
+    ret = CoTaskMemAlloc(size);
+    if (!ret)
+        return NULL;
+
+    memcpy(ret, fmt, size);
+
+    ret->cbSize = size - sizeof(WAVEFORMATEX);
+
+    return ret;
+}
+
+static DWORD get_channel_mask(unsigned int channels)
+{
+    switch(channels) {
+    case 0:
+        return 0;
+    case 1:
+        return KSAUDIO_SPEAKER_MONO;
+    case 2:
+        return KSAUDIO_SPEAKER_STEREO;
+    case 3:
+        return KSAUDIO_SPEAKER_STEREO | SPEAKER_LOW_FREQUENCY;
+    case 4:
+        return KSAUDIO_SPEAKER_QUAD;    /* not _SURROUND */
+    case 5:
+        return KSAUDIO_SPEAKER_QUAD | SPEAKER_LOW_FREQUENCY;
+    case 6:
+        return KSAUDIO_SPEAKER_5POINT1; /* not 5POINT1_SURROUND */
+    case 7:
+        return KSAUDIO_SPEAKER_5POINT1 | SPEAKER_BACK_CENTER;
+    case 8:
+        return KSAUDIO_SPEAKER_7POINT1_SURROUND; /* Vista deprecates 7POINT1 */
+    }
+    FIXME("Unknown speaker configuration: %u\n", channels);
+    return 0;
+}
+
+static void session_init_vols(AudioSession *session, UINT channels)
+{
+    if (session->channel_count < channels) {
+        UINT i;
+
+        if (session->channel_vols)
+            session->channel_vols = HeapReAlloc(GetProcessHeap(), 0,
+                    session->channel_vols, sizeof(float) * channels);
+        else
+            session->channel_vols = HeapAlloc(GetProcessHeap(), 0,
+                    sizeof(float) * channels);
+        if (!session->channel_vols)
+            return;
+
+        for(i = session->channel_count; i < channels; ++i)
+            session->channel_vols[i] = 1.f;
+
+        session->channel_count = channels;
+    }
+}
+
+static AudioSession *create_session(const GUID *guid, IMMDevice *device,
+        UINT num_channels)
+{
+    AudioSession *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(AudioSession));
+    if (!ret)
+        return NULL;
+
+    memcpy(&ret->guid, guid, sizeof(GUID));
+
+    ret->device = device;
+
+    list_init(&ret->clients);
+
+    list_add_head(&g_sessions, &ret->entry);
+
+    session_init_vols(ret, num_channels);
+
+    ret->master_vol = 1.f;
+
+    return ret;
+}
+
+/* if channels == 0, then this will return or create a session with
+ * matching dataflow and GUID. otherwise, channels must also match */
+static HRESULT get_audio_session(const GUID *sessionguid,
+        IMMDevice *device, UINT channels, AudioSession **out)
+{
+    AudioSession *session;
+
+    if (!sessionguid || IsEqualGUID(sessionguid, &GUID_NULL)) {
+        *out = create_session(&GUID_NULL, device, channels);
+        if (!*out)
+            return E_OUTOFMEMORY;
+
+        return S_OK;
+    }
+
+    *out = NULL;
+    LIST_FOR_EACH_ENTRY(session, &g_sessions, AudioSession, entry) {
+        if (session->device == device &&
+            IsEqualGUID(sessionguid, &session->guid)) {
+            session_init_vols(session, channels);
+            *out = session;
+            break;
+        }
+    }
+
+    if (!*out) {
+        *out = create_session(sessionguid, device, channels);
+        if (!*out)
+            return E_OUTOFMEMORY;
+    }
+
+    return S_OK;
+}
+
+static HRESULT pulse_spec_from_waveformat(ACImpl *This, const WAVEFORMATEX *fmt)
+{
+    pa_channel_map_init(&This->map);
+    This->ss.rate = fmt->nSamplesPerSec;
+    This->ss.format = PA_SAMPLE_INVALID;
+
+    switch(fmt->wFormatTag) {
+    case WAVE_FORMAT_IEEE_FLOAT:
+        if (!fmt->nChannels || fmt->nChannels > 2 || fmt->wBitsPerSample != 32)
+            break;
+        This->ss.format = PA_SAMPLE_FLOAT32LE;
+        pa_channel_map_init_auto(&This->map, fmt->nChannels, PA_CHANNEL_MAP_ALSA);
+        break;
+    case WAVE_FORMAT_PCM:
+        if (!fmt->nChannels || fmt->nChannels > 2)
+            break;
+        if (fmt->wBitsPerSample == 8)
+            This->ss.format = PA_SAMPLE_U8;
+        else if (fmt->wBitsPerSample == 16)
+            This->ss.format = PA_SAMPLE_S16LE;
+        else
+            return AUDCLNT_E_UNSUPPORTED_FORMAT;
+        pa_channel_map_init_auto(&This->map, fmt->nChannels, PA_CHANNEL_MAP_ALSA);
+        break;
+    case WAVE_FORMAT_EXTENSIBLE: {
+        WAVEFORMATEXTENSIBLE *wfe = (WAVEFORMATEXTENSIBLE*)fmt;
+        DWORD mask = wfe->dwChannelMask;
+        DWORD i = 0, j;
+        if (fmt->cbSize != (sizeof(*wfe) - sizeof(*fmt)) && fmt->cbSize != sizeof(*wfe))
+            break;
+        if (IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT) &&
+            (!wfe->Samples.wValidBitsPerSample || wfe->Samples.wValidBitsPerSample == 32) &&
+            fmt->wBitsPerSample == 32)
+            This->ss.format = PA_SAMPLE_FLOAT32LE;
+        else if (IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM)) {
+            DWORD valid = wfe->Samples.wValidBitsPerSample;
+            if (!valid)
+                valid = fmt->wBitsPerSample;
+            if (!valid || valid > fmt->wBitsPerSample)
+                break;
+            switch (fmt->wBitsPerSample) {
+                case 8:
+                    if (valid == 8)
+                        This->ss.format = PA_SAMPLE_U8;
+                    break;
+                case 16:
+                    if (valid == 16)
+                        This->ss.format = PA_SAMPLE_S16LE;
+                    break;
+                case 24:
+                    if (valid == 24)
+                        This->ss.format = PA_SAMPLE_S24LE;
+                    break;
+                case 32:
+                    if (valid == 24)
+                        This->ss.format = PA_SAMPLE_S24_32LE;
+                    else if (valid == 32)
+                        This->ss.format = PA_SAMPLE_S32LE;
+                    break;
+                default:
+                    return AUDCLNT_E_UNSUPPORTED_FORMAT;
+            }
+        }
+        This->map.channels = fmt->nChannels;
+        if (!mask || (mask & (SPEAKER_ALL|SPEAKER_RESERVED)))
+            mask = get_channel_mask(fmt->nChannels);
+        for (j = 0; j < ARRAY_SIZE(pulse_pos_from_wfx) && i < fmt->nChannels; ++j) {
+            if (mask & (1 << j))
+                This->map.map[i++] = pulse_pos_from_wfx[j];
+        }
+
+        /* Special case for mono since pulse appears to map it differently */
+        if (mask == SPEAKER_FRONT_CENTER)
+            This->map.map[0] = PA_CHANNEL_POSITION_MONO;
+
+        if (i < fmt->nChannels || (mask & SPEAKER_RESERVED)) {
+            This->map.channels = 0;
+            ERR("Invalid channel mask: %i/%i and %x(%x)\n", i, fmt->nChannels, mask, wfe->dwChannelMask);
+            break;
+        }
+        break;
+        }
+    case WAVE_FORMAT_ALAW:
+    case WAVE_FORMAT_MULAW:
+        if (fmt->wBitsPerSample != 8) {
+            FIXME("Unsupported bpp %u for LAW\n", fmt->wBitsPerSample);
+            return AUDCLNT_E_UNSUPPORTED_FORMAT;
+        }
+        if (fmt->nChannels != 1 && fmt->nChannels != 2) {
+            FIXME("Unsupported channels %u for LAW\n", fmt->nChannels);
+            return AUDCLNT_E_UNSUPPORTED_FORMAT;
+        }
+        This->ss.format = fmt->wFormatTag == WAVE_FORMAT_MULAW ? PA_SAMPLE_ULAW : PA_SAMPLE_ALAW;
+        pa_channel_map_init_auto(&This->map, fmt->nChannels, PA_CHANNEL_MAP_ALSA);
+        break;
+    default:
+        WARN("Unhandled tag %x\n", fmt->wFormatTag);
+        return AUDCLNT_E_UNSUPPORTED_FORMAT;
+    }
+    This->ss.channels = This->map.channels;
+    if (!pa_channel_map_valid(&This->map) || This->ss.format == PA_SAMPLE_INVALID) {
+        ERR("Invalid format! Channel spec valid: %i, format: %i\n", pa_channel_map_valid(&This->map), This->ss.format);
+        return AUDCLNT_E_UNSUPPORTED_FORMAT;
+    }
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Initialize(IAudioClient *iface,
+        AUDCLNT_SHAREMODE mode, DWORD flags, REFERENCE_TIME duration,
+        REFERENCE_TIME period, const WAVEFORMATEX *fmt,
+        const GUID *sessionguid)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+    UINT period_bytes;
+
+    TRACE("(%p)->(%x, %x, %s, %s, %p, %s)\n", This, mode, flags,
+          wine_dbgstr_longlong(duration), wine_dbgstr_longlong(period), fmt, debugstr_guid(sessionguid));
+
+    if (!fmt)
+        return E_POINTER;
+
+    if (mode != AUDCLNT_SHAREMODE_SHARED && mode != AUDCLNT_SHAREMODE_EXCLUSIVE)
+        return E_INVALIDARG;
+    if (mode == AUDCLNT_SHAREMODE_EXCLUSIVE)
+        return AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED;
+
+    if (flags & ~(AUDCLNT_STREAMFLAGS_CROSSPROCESS |
+                AUDCLNT_STREAMFLAGS_LOOPBACK |
+                AUDCLNT_STREAMFLAGS_EVENTCALLBACK |
+                AUDCLNT_STREAMFLAGS_NOPERSIST |
+                AUDCLNT_STREAMFLAGS_RATEADJUST |
+                AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED |
+                AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY |
+                AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM)) {
+        FIXME("Unknown flags: %08x\n", flags);
+        return E_INVALIDARG;
+    }
+
+    pthread_mutex_lock(&pulse_lock);
+
+    hr = pulse_connect();
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if (This->stream) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_ALREADY_INITIALIZED;
+    }
+
+    hr = pulse_spec_from_waveformat(This, fmt);
+    TRACE("Obtaining format returns %08x\n", hr);
+    dump_fmt(fmt);
+
+    if (FAILED(hr))
+        goto exit;
+
+    if (mode == AUDCLNT_SHAREMODE_SHARED) {
+        REFERENCE_TIME def = pulse_def_period[This->dataflow == eCapture];
+        REFERENCE_TIME min = pulse_min_period[This->dataflow == eCapture];
+
+        /* Switch to low latency mode if below 2 default periods,
+         * which is 20 ms by default, this will increase the amount
+         * of interrupts but allows very low latency. In dsound I
+         * managed to get a total latency of ~8ms, which is well below
+         * default
+         */
+        if (duration < 2 * def)
+            period = min;
+        else
+            period = def;
+        if (duration < 2 * period)
+            duration = 2 * period;
+
+        /* Uh oh, really low latency requested.. */
+        if (duration <= 2 * period)
+            period /= 2;
+    }
+
+    const char* denv = getenv("STAGING_AUDIO_DURATION");
+    if (denv) {
+        int val = atoi(denv);
+        duration = val;
+        printf("Staging audio duration set to %d.\n", val);
+    }
+
+    period_bytes = pa_frame_size(&This->ss) * MulDiv(period, This->ss.rate, 10000000);
+
+    if (duration < 20000000)
+        This->bufsize_frames = ceil((duration / 10000000.) * fmt->nSamplesPerSec);
+    else
+        This->bufsize_frames = 2 * fmt->nSamplesPerSec;
+    This->bufsize_bytes = This->bufsize_frames * pa_frame_size(&This->ss);
+
+    This->share = mode;
+    This->flags = flags;
+    hr = pulse_stream_connect(This, period_bytes);
+    if (SUCCEEDED(hr)) {
+        UINT32 unalign;
+        const pa_buffer_attr *attr = pa_stream_get_buffer_attr(This->stream);
+        This->attr = *attr;
+        /* Update frames according to new size */
+        dump_attr(attr);
+        if (This->dataflow == eRender) {
+            if (attr->tlength < This->bufsize_bytes) {
+                TRACE("PulseAudio buffer too small (%u < %u), using tmp buffer\n", attr->tlength, This->bufsize_bytes);
+
+                This->local_buffer = HeapAlloc(GetProcessHeap(), 0, This->bufsize_bytes);
+                if(!This->local_buffer)
+                    hr = E_OUTOFMEMORY;
+            }
+        } else {
+            UINT32 i, capture_packets;
+
+            This->capture_period = period_bytes = attr->fragsize;
+            if ((unalign = This->bufsize_bytes % period_bytes))
+                This->bufsize_bytes += period_bytes - unalign;
+            This->bufsize_frames = This->bufsize_bytes / pa_frame_size(&This->ss);
+
+            capture_packets = This->bufsize_bytes / This->capture_period;
+
+            This->local_buffer = HeapAlloc(GetProcessHeap(), 0, This->bufsize_bytes + capture_packets * sizeof(ACPacket));
+            if (!This->local_buffer)
+                hr = E_OUTOFMEMORY;
+            else {
+                ACPacket *cur_packet = (ACPacket*)((char*)This->local_buffer + This->bufsize_bytes);
+                BYTE *data = This->local_buffer;
+                silence_buffer(This->ss.format, This->local_buffer, This->bufsize_bytes);
+                list_init(&This->packet_free_head);
+                list_init(&This->packet_filled_head);
+                for (i = 0; i < capture_packets; ++i, ++cur_packet) {
+                    list_add_tail(&This->packet_free_head, &cur_packet->entry);
+                    cur_packet->data = data;
+                    data += This->capture_period;
+                }
+                assert(!This->capture_period || This->bufsize_bytes == This->capture_period * capture_packets);
+                assert(!capture_packets || data - This->bufsize_bytes == This->local_buffer);
+            }
+        }
+    }
+    if (SUCCEEDED(hr))
+        hr = get_audio_session(sessionguid, This->parent, fmt->nChannels, &This->session);
+    if (SUCCEEDED(hr))
+        list_add_tail(&This->session->clients, &This->entry);
+
+exit:
+    if (FAILED(hr)) {
+        HeapFree(GetProcessHeap(), 0, This->local_buffer);
+        This->local_buffer = NULL;
+        if (This->stream) {
+            pa_stream_disconnect(This->stream);
+            pa_stream_unref(This->stream);
+            This->stream = NULL;
+        }
+    }
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetBufferSize(IAudioClient *iface,
+        UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if (!out)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (SUCCEEDED(hr))
+        *out = This->bufsize_frames;
+    pthread_mutex_unlock(&pulse_lock);
+
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetStreamLatency(IAudioClient *iface,
+        REFERENCE_TIME *latency)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    const pa_buffer_attr *attr;
+    REFERENCE_TIME lat;
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, latency);
+
+    if (!latency)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+    attr = pa_stream_get_buffer_attr(This->stream);
+    if (This->dataflow == eRender){
+        lat = attr->minreq / pa_frame_size(&This->ss);
+        lat += pulse_def_period[0];
+    }else
+        lat = attr->fragsize / pa_frame_size(&This->ss);
+    *latency = 10000000;
+    *latency *= lat;
+    *latency /= This->ss.rate;
+    pthread_mutex_unlock(&pulse_lock);
+    TRACE("Latency: %u ms\n", (DWORD)(*latency / 10000));
+    return S_OK;
+}
+
+static void ACImpl_GetRenderPad(ACImpl *This, UINT32 *out)
+{
+    *out = This->pad / pa_frame_size(&This->ss);
+}
+
+static void ACImpl_GetCapturePad(ACImpl *This, UINT32 *out)
+{
+    ACPacket *packet = This->locked_ptr;
+    if (!packet && !list_empty(&This->packet_filled_head)) {
+        packet = (ACPacket*)list_head(&This->packet_filled_head);
+        This->locked_ptr = packet;
+        list_remove(&packet->entry);
+    }
+    if (out)
+        *out = This->pad / pa_frame_size(&This->ss);
+}
+
+static HRESULT WINAPI AudioClient_GetCurrentPadding(IAudioClient *iface,
+        UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if (!out)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if (This->dataflow == eRender)
+        ACImpl_GetRenderPad(This, out);
+    else
+        ACImpl_GetCapturePad(This, out);
+    pthread_mutex_unlock(&pulse_lock);
+
+    TRACE("%p Pad: %u ms (%u)\n", This, MulDiv(*out, 1000, This->ss.rate), *out);
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_IsFormatSupported(IAudioClient *iface,
+        AUDCLNT_SHAREMODE mode, const WAVEFORMATEX *fmt,
+        WAVEFORMATEX **out)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+    WAVEFORMATEX *closest = NULL;
+    BOOL exclusive;
+
+    TRACE("(%p)->(%x, %p, %p)\n", This, mode, fmt, out);
+
+    if (!fmt)
+        return E_POINTER;
+
+    if (out)
+        *out = NULL;
+
+    if (mode == AUDCLNT_SHAREMODE_EXCLUSIVE) {
+        exclusive = 1;
+        out = NULL;
+    } else if (mode == AUDCLNT_SHAREMODE_SHARED) {
+        exclusive = 0;
+        if (!out)
+            return E_POINTER;
+    } else
+        return E_INVALIDARG;
+
+    if (fmt->nChannels == 0)
+        return AUDCLNT_E_UNSUPPORTED_FORMAT;
+
+    closest = clone_format(fmt);
+    if (!closest)
+        return E_OUTOFMEMORY;
+
+    dump_fmt(fmt);
+
+    switch (fmt->wFormatTag) {
+    case WAVE_FORMAT_EXTENSIBLE: {
+        WAVEFORMATEXTENSIBLE *ext = (WAVEFORMATEXTENSIBLE*)closest;
+
+        if ((fmt->cbSize != sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX) &&
+             fmt->cbSize != sizeof(WAVEFORMATEXTENSIBLE)) ||
+            fmt->nBlockAlign != fmt->wBitsPerSample / 8 * fmt->nChannels ||
+            ext->Samples.wValidBitsPerSample > fmt->wBitsPerSample ||
+            fmt->nAvgBytesPerSec != fmt->nBlockAlign * fmt->nSamplesPerSec) {
+            hr = E_INVALIDARG;
+            break;
+        }
+
+        if (exclusive) {
+            UINT32 mask = 0, i, channels = 0;
+
+            if (!(ext->dwChannelMask & (SPEAKER_ALL | SPEAKER_RESERVED))) {
+                for (i = 1; !(i & SPEAKER_RESERVED); i <<= 1) {
+                    if (i & ext->dwChannelMask) {
+                        mask |= i;
+                        channels++;
+                    }
+                }
+
+                if (channels != fmt->nChannels || (ext->dwChannelMask & ~mask)) {
+                    hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+                    break;
+                }
+            } else {
+                hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+                break;
+            }
+        }
+
+        if (IsEqualGUID(&ext->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)) {
+            if (fmt->wBitsPerSample != 32) {
+                hr = E_INVALIDARG;
+                break;
+            }
+
+            if (ext->Samples.wValidBitsPerSample != fmt->wBitsPerSample) {
+                hr = S_FALSE;
+                ext->Samples.wValidBitsPerSample = fmt->wBitsPerSample;
+            }
+        } else if (IsEqualGUID(&ext->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM)) {
+            if (!fmt->wBitsPerSample || fmt->wBitsPerSample > 32 || fmt->wBitsPerSample % 8) {
+                hr = E_INVALIDARG;
+                break;
+            }
+
+            if (ext->Samples.wValidBitsPerSample != fmt->wBitsPerSample &&
+                !(fmt->wBitsPerSample == 32 &&
+                  ext->Samples.wValidBitsPerSample == 24)) {
+                hr = S_FALSE;
+                ext->Samples.wValidBitsPerSample = fmt->wBitsPerSample;
+                break;
+            }
+        } else {
+            hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+            break;
+        }
+
+        break;
+    }
+
+    case WAVE_FORMAT_ALAW:
+    case WAVE_FORMAT_MULAW:
+        if (fmt->wBitsPerSample != 8) {
+            hr = E_INVALIDARG;
+            break;
+        }
+        /* Fall-through */
+    case WAVE_FORMAT_IEEE_FLOAT:
+        if (fmt->wFormatTag == WAVE_FORMAT_IEEE_FLOAT && fmt->wBitsPerSample != 32) {
+            hr = E_INVALIDARG;
+            break;
+        }
+        /* Fall-through */
+    case WAVE_FORMAT_PCM:
+        if (fmt->wFormatTag == WAVE_FORMAT_PCM &&
+            (!fmt->wBitsPerSample || fmt->wBitsPerSample > 32 || fmt->wBitsPerSample % 8)) {
+            hr = E_INVALIDARG;
+            break;
+        }
+
+        if (fmt->nChannels > 2) {
+            hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+            break;
+        }
+        /*
+         * fmt->cbSize, fmt->nBlockAlign and fmt->nAvgBytesPerSec seem to be
+         * ignored, invalid values are happily accepted.
+         */
+        break;
+    default:
+        hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+        break;
+    }
+
+    if (exclusive && hr != S_OK) {
+        hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+        CoTaskMemFree(closest);
+    } else if (hr != S_FALSE)
+        CoTaskMemFree(closest);
+    else
+        *out = closest;
+
+    /* Winepulse does not currently support exclusive mode, if you know of an
+     * application that uses it, I will correct this..
+     */
+    if (hr == S_OK && exclusive)
+        return This->dataflow == eCapture ? AUDCLNT_E_UNSUPPORTED_FORMAT : AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED;
+
+    TRACE("returning: %08x %p\n", hr, out ? *out : NULL);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetMixFormat(IAudioClient *iface,
+        WAVEFORMATEX **pwfx)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    WAVEFORMATEXTENSIBLE *fmt = &pulse_fmt[This->dataflow == eCapture];
+
+    TRACE("(%p)->(%p)\n", This, pwfx);
+
+    if (!pwfx)
+        return E_POINTER;
+
+    *pwfx = clone_format(&fmt->Format);
+    if (!*pwfx)
+        return E_OUTOFMEMORY;
+    dump_fmt(*pwfx);
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_GetDevicePeriod(IAudioClient *iface,
+        REFERENCE_TIME *defperiod, REFERENCE_TIME *minperiod)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+
+    TRACE("(%p)->(%p, %p)\n", This, defperiod, minperiod);
+
+    if (!defperiod && !minperiod)
+        return E_POINTER;
+
+    if (defperiod)
+        *defperiod = pulse_def_period[This->dataflow == eCapture];
+    if (minperiod)
+        *minperiod = pulse_min_period[This->dataflow == eCapture];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Start(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+    int success;
+    pa_operation *o;
+
+    TRACE("(%p)\n", This);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if ((This->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) && !This->event) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_EVENTHANDLE_NOT_SET;
+    }
+
+    if (This->started) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_NOT_STOPPED;
+    }
+
+    if (pa_stream_is_corked(This->stream)) {
+        o = pa_stream_cork(This->stream, 0, pulse_op_cb, &success);
+        if (o) {
+            while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+                pthread_cond_wait(&pulse_cond, &pulse_lock);
+            pa_operation_unref(o);
+        } else
+            success = 0;
+        if (!success)
+            hr = E_FAIL;
+    }
+
+    if (SUCCEEDED(hr)) {
+        This->started = TRUE;
+        if (This->dataflow == eRender && This->event)
+            pa_stream_set_latency_update_callback(This->stream, pulse_latency_callback, This);
+    }
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_Stop(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+    pa_operation *o;
+    int success;
+
+    TRACE("(%p)\n", This);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if (!This->started) {
+        pthread_mutex_unlock(&pulse_lock);
+        return S_FALSE;
+    }
+
+    if (This->dataflow == eRender) {
+        o = pa_stream_cork(This->stream, 1, pulse_op_cb, &success);
+        if (o) {
+            while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+                pthread_cond_wait(&pulse_cond, &pulse_lock);
+            pa_operation_unref(o);
+        } else
+            success = 0;
+        if (!success)
+            hr = E_FAIL;
+    }
+    if (SUCCEEDED(hr)) {
+        This->started = FALSE;
+    }
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_Reset(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("(%p)\n", This);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if (This->started) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_NOT_STOPPED;
+    }
+
+    if (This->locked) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_BUFFER_OPERATION_PENDING;
+    }
+
+    if (This->dataflow == eRender) {
+        /* If there is still data in the render buffer it needs to be removed from the server */
+        int success = 0;
+        if (This->pad) {
+            pa_operation *o = pa_stream_flush(This->stream, pulse_op_cb, &success);
+            if (o) {
+                while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+                    pthread_cond_wait(&pulse_cond, &pulse_lock);
+                pa_operation_unref(o);
+            }
+        }
+        if (success || !This->pad){
+            This->clock_lastpos = This->clock_written = This->pad = 0;
+            This->wri_offs_bytes = This->lcl_offs_bytes = This->held_bytes = 0;
+        }
+    } else {
+        ACPacket *p;
+        This->clock_written += This->pad;
+        This->pad = 0;
+
+        if ((p = This->locked_ptr)) {
+            This->locked_ptr = NULL;
+            list_add_tail(&This->packet_free_head, &p->entry);
+        }
+        list_move_tail(&This->packet_free_head, &This->packet_filled_head);
+    }
+    pthread_mutex_unlock(&pulse_lock);
+
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_SetEventHandle(IAudioClient *iface,
+        HANDLE event)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, event);
+
+    if (!event)
+        return E_INVALIDARG;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if (!(This->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK))
+        hr = AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED;
+    else if (This->event)
+        hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
+    else
+        This->event = event;
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetService(IAudioClient *iface, REFIID riid,
+        void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    pthread_mutex_unlock(&pulse_lock);
+    if (FAILED(hr))
+        return hr;
+
+    if (IsEqualIID(riid, &IID_IAudioRenderClient)) {
+        if (This->dataflow != eRender)
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        *ppv = &This->IAudioRenderClient_iface;
+    } else if (IsEqualIID(riid, &IID_IAudioCaptureClient)) {
+        if (This->dataflow != eCapture)
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        *ppv = &This->IAudioCaptureClient_iface;
+    } else if (IsEqualIID(riid, &IID_IAudioClock)) {
+        *ppv = &This->IAudioClock_iface;
+    } else if (IsEqualIID(riid, &IID_IAudioStreamVolume)) {
+        *ppv = &This->IAudioStreamVolume_iface;
+    } else if (IsEqualIID(riid, &IID_IAudioSessionControl) ||
+               IsEqualIID(riid, &IID_IChannelAudioVolume) ||
+               IsEqualIID(riid, &IID_ISimpleAudioVolume)) {
+        if (!This->session_wrapper) {
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if (!This->session_wrapper)
+                return E_OUTOFMEMORY;
+        }
+        if (IsEqualIID(riid, &IID_IAudioSessionControl))
+            *ppv = &This->session_wrapper->IAudioSessionControl2_iface;
+        else if (IsEqualIID(riid, &IID_IChannelAudioVolume))
+            *ppv = &This->session_wrapper->IChannelAudioVolume_iface;
+        else if (IsEqualIID(riid, &IID_ISimpleAudioVolume))
+            *ppv = &This->session_wrapper->ISimpleAudioVolume_iface;
+    }
+
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    FIXME("stub %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static const IAudioClientVtbl AudioClient_Vtbl =
+{
+    AudioClient_QueryInterface,
+    AudioClient_AddRef,
+    AudioClient_Release,
+    AudioClient_Initialize,
+    AudioClient_GetBufferSize,
+    AudioClient_GetStreamLatency,
+    AudioClient_GetCurrentPadding,
+    AudioClient_IsFormatSupported,
+    AudioClient_GetMixFormat,
+    AudioClient_GetDevicePeriod,
+    AudioClient_Start,
+    AudioClient_Stop,
+    AudioClient_Reset,
+    AudioClient_SetEventHandle,
+    AudioClient_GetService
+};
+
+static HRESULT WINAPI AudioRenderClient_QueryInterface(
+        IAudioRenderClient *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IAudioRenderClient))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    if (IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->marshal, riid, ppv);
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioRenderClient_AddRef(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioRenderClient_Release(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_Release(&This->IAudioClient_iface);
+}
+
+static void alloc_tmp_buffer(ACImpl *This, UINT32 bytes)
+{
+    if(This->tmp_buffer_bytes >= bytes)
+        return;
+
+    HeapFree(GetProcessHeap(), 0, This->tmp_buffer);
+    This->tmp_buffer = HeapAlloc(GetProcessHeap(), 0, bytes);
+    This->tmp_buffer_bytes = bytes;
+}
+
+static HRESULT WINAPI AudioRenderClient_GetBuffer(IAudioRenderClient *iface,
+        UINT32 frames, BYTE **data)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    size_t avail, req, bytes = frames * pa_frame_size(&This->ss);
+    UINT32 pad;
+    HRESULT hr = S_OK;
+    int ret = -1;
+
+    TRACE("(%p)->(%u, %p)\n", This, frames, data);
+
+    if (!data)
+        return E_POINTER;
+    *data = NULL;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr) || This->locked) {
+        pthread_mutex_unlock(&pulse_lock);
+        return FAILED(hr) ? hr : AUDCLNT_E_OUT_OF_ORDER;
+    }
+    if (!frames) {
+        pthread_mutex_unlock(&pulse_lock);
+        return S_OK;
+    }
+
+    ACImpl_GetRenderPad(This, &pad);
+    avail = This->bufsize_frames - pad;
+    if (avail < frames || bytes > This->bufsize_bytes) {
+        pthread_mutex_unlock(&pulse_lock);
+        WARN("Wanted to write %u, but only %zu available\n", frames, avail);
+        return AUDCLNT_E_BUFFER_TOO_LARGE;
+    }
+
+    if(This->local_buffer){
+        if(This->wri_offs_bytes + bytes > This->bufsize_bytes){
+            alloc_tmp_buffer(This, bytes);
+            *data = This->tmp_buffer;
+            This->locked = -frames;
+        }else{
+            *data = This->local_buffer + This->wri_offs_bytes;
+            This->locked = frames;
+        }
+    }else{
+        req = bytes;
+        ret = pa_stream_begin_write(This->stream, &This->locked_ptr, &req);
+        if (ret < 0 || req < bytes) {
+            FIXME("%p Not using pulse locked data: %i %zu/%u %u/%u\n", This, ret, req/pa_frame_size(&This->ss), frames, pad, This->bufsize_frames);
+            if (ret >= 0)
+                pa_stream_cancel_write(This->stream);
+            alloc_tmp_buffer(This, bytes);
+            *data = This->tmp_buffer;
+            This->locked_ptr = NULL;
+        } else
+            *data = This->locked_ptr;
+
+        This->locked = frames;
+    }
+
+    silence_buffer(This->ss.format, *data, bytes);
+
+    pthread_mutex_unlock(&pulse_lock);
+
+    return hr;
+}
+
+static void pulse_wrap_buffer(ACImpl *This, BYTE *buffer, UINT32 written_bytes)
+{
+    UINT32 chunk_bytes = This->bufsize_bytes - This->wri_offs_bytes;
+
+    if(written_bytes <= chunk_bytes){
+        memcpy(This->local_buffer + This->wri_offs_bytes, buffer, written_bytes);
+    }else{
+        memcpy(This->local_buffer + This->wri_offs_bytes, buffer, chunk_bytes);
+        memcpy(This->local_buffer, buffer + chunk_bytes,
+                written_bytes - chunk_bytes);
+    }
+}
+
+static HRESULT WINAPI AudioRenderClient_ReleaseBuffer(
+        IAudioRenderClient *iface, UINT32 written_frames, DWORD flags)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    UINT32 written_bytes = written_frames * pa_frame_size(&This->ss);
+
+    TRACE("(%p)->(%u, %x)\n", This, written_frames, flags);
+
+    pthread_mutex_lock(&pulse_lock);
+    if (!This->locked || !written_frames) {
+        if (This->locked_ptr)
+            pa_stream_cancel_write(This->stream);
+        This->locked = 0;
+        This->locked_ptr = NULL;
+        pthread_mutex_unlock(&pulse_lock);
+        return written_frames ? AUDCLNT_E_OUT_OF_ORDER : S_OK;
+    }
+
+    if (This->locked < written_frames) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_INVALID_SIZE;
+    }
+
+    if(This->local_buffer){
+        BYTE *buffer;
+
+        if(This->locked >= 0)
+            buffer = This->local_buffer + This->wri_offs_bytes;
+        else
+            buffer = This->tmp_buffer;
+
+        if(flags & AUDCLNT_BUFFERFLAGS_SILENT)
+            silence_buffer(This->ss.format, buffer, written_bytes);
+
+        if(This->locked < 0)
+            pulse_wrap_buffer(This, buffer, written_bytes);
+
+        This->wri_offs_bytes += written_bytes;
+        This->wri_offs_bytes %= This->bufsize_bytes;
+
+        This->pad += written_bytes;
+        This->held_bytes += written_bytes;
+
+        if(This->held_bytes == This->pad){
+            int e;
+            UINT32 to_write = min(This->attr.tlength, written_bytes);
+
+            /* nothing in PA, so send data immediately */
+
+            TRACE("pre-writing %u bytes\n", to_write);
+
+            e = write_buffer(This, buffer, to_write, 0);
+            if(e)
+                ERR("pa_stream_write failed: 0x%x\n", e);
+
+            This->lcl_offs_bytes += to_write;
+            This->lcl_offs_bytes %= This->bufsize_bytes;
+            This->held_bytes -= to_write;
+        }
+
+    }else{
+        enum write_buffer_flags wr_flags = 0;
+
+        if (flags & AUDCLNT_BUFFERFLAGS_SILENT) wr_flags |= WINEPULSE_WRITE_SILENT;
+        if (!This->locked_ptr) wr_flags |= WINEPULSE_WRITE_NOFREE;
+
+        write_buffer(This, This->locked_ptr ? This->locked_ptr : This->tmp_buffer, written_bytes, wr_flags);
+        This->pad += written_bytes;
+    }
+
+    if (!pa_stream_is_corked(This->stream)) {
+        int success;
+        pa_operation *o;
+        o = pa_stream_trigger(This->stream, pulse_op_cb, &success);
+        if (o) {
+            while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+                pthread_cond_wait(&pulse_cond, &pulse_lock);
+            pa_operation_unref(o);
+        }
+    }
+
+    This->locked = 0;
+    This->locked_ptr = NULL;
+    TRACE("Released %u, pad %zu\n", written_frames, This->pad / pa_frame_size(&This->ss));
+    assert(This->pad <= This->bufsize_bytes);
+
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl = {
+    AudioRenderClient_QueryInterface,
+    AudioRenderClient_AddRef,
+    AudioRenderClient_Release,
+    AudioRenderClient_GetBuffer,
+    AudioRenderClient_ReleaseBuffer
+};
+
+static HRESULT WINAPI AudioCaptureClient_QueryInterface(
+        IAudioCaptureClient *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IAudioCaptureClient))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    if (IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->marshal, riid, ppv);
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioCaptureClient_AddRef(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioCaptureClient_Release(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetBuffer(IAudioCaptureClient *iface,
+        BYTE **data, UINT32 *frames, DWORD *flags, UINT64 *devpos,
+        UINT64 *qpcpos)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    HRESULT hr;
+    ACPacket *packet;
+
+    TRACE("(%p)->(%p, %p, %p, %p, %p)\n", This, data, frames, flags,
+            devpos, qpcpos);
+
+    if (!data)
+       return E_POINTER;
+
+    *data = NULL;
+
+    if (!frames || !flags)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr) || This->locked) {
+        pthread_mutex_unlock(&pulse_lock);
+        return FAILED(hr) ? hr : AUDCLNT_E_OUT_OF_ORDER;
+    }
+
+    ACImpl_GetCapturePad(This, NULL);
+    if ((packet = This->locked_ptr)) {
+        *frames = This->capture_period / pa_frame_size(&This->ss);
+        *flags = 0;
+        if (packet->discont)
+            *flags |= AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY;
+        if (devpos) {
+            if (packet->discont)
+                *devpos = (This->clock_written + This->capture_period) / pa_frame_size(&This->ss);
+            else
+                *devpos = This->clock_written / pa_frame_size(&This->ss);
+        }
+        if (qpcpos)
+            *qpcpos = packet->qpcpos;
+        *data = packet->data;
+    }
+    else
+        *frames = 0;
+    This->locked = *frames;
+    pthread_mutex_unlock(&pulse_lock);
+    return *frames ? S_OK : AUDCLNT_S_BUFFER_EMPTY;
+}
+
+static HRESULT WINAPI AudioCaptureClient_ReleaseBuffer(
+        IAudioCaptureClient *iface, UINT32 done)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+
+    TRACE("(%p)->(%u)\n", This, done);
+
+    pthread_mutex_lock(&pulse_lock);
+    if (!This->locked && done) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_OUT_OF_ORDER;
+    }
+    if (done && This->locked != done) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_INVALID_SIZE;
+    }
+    if (done) {
+        ACPacket *packet = This->locked_ptr;
+        This->locked_ptr = NULL;
+        This->pad -= This->capture_period;
+        if (packet->discont)
+            This->clock_written += 2 * This->capture_period;
+        else
+            This->clock_written += This->capture_period;
+        list_add_tail(&This->packet_free_head, &packet->entry);
+    }
+    This->locked = 0;
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetNextPacketSize(
+        IAudioCaptureClient *iface, UINT32 *frames)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+
+    TRACE("(%p)->(%p)\n", This, frames);
+    if (!frames)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    ACImpl_GetCapturePad(This, NULL);
+    if (This->locked_ptr)
+        *frames = This->capture_period / pa_frame_size(&This->ss);
+    else
+        *frames = 0;
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl =
+{
+    AudioCaptureClient_QueryInterface,
+    AudioCaptureClient_AddRef,
+    AudioCaptureClient_Release,
+    AudioCaptureClient_GetBuffer,
+    AudioCaptureClient_ReleaseBuffer,
+    AudioCaptureClient_GetNextPacketSize
+};
+
+static HRESULT WINAPI AudioClock_QueryInterface(IAudioClock *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IAudioClock))
+        *ppv = iface;
+    else if (IsEqualIID(riid, &IID_IAudioClock2))
+        *ppv = &This->IAudioClock2_iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    if (IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->marshal, riid, ppv);
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClock_AddRef(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioClock_Release(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioClock_GetFrequency(IAudioClock *iface, UINT64 *freq)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, freq);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (SUCCEEDED(hr)) {
+        *freq = This->ss.rate;
+        if (This->share == AUDCLNT_SHAREMODE_SHARED)
+            *freq *= pa_frame_size(&This->ss);
+    }
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClock_GetPosition(IAudioClock *iface, UINT64 *pos,
+        UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p, %p)\n", This, pos, qpctime);
+
+    if (!pos)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    *pos = This->clock_written;
+
+    if (This->share == AUDCLNT_SHAREMODE_EXCLUSIVE)
+        *pos /= pa_frame_size(&This->ss);
+
+    /* Make time never go backwards */
+    if (*pos < This->clock_lastpos)
+        *pos = This->clock_lastpos;
+    else
+        This->clock_lastpos = *pos;
+    pthread_mutex_unlock(&pulse_lock);
+
+    TRACE("%p Position: %u\n", This, (unsigned)*pos);
+
+    if (qpctime) {
+        LARGE_INTEGER stamp, freq;
+        QueryPerformanceCounter(&stamp);
+        QueryPerformanceFrequency(&freq);
+        *qpctime = (stamp.QuadPart * (INT64)10000000) / freq.QuadPart;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClock_GetCharacteristics(IAudioClock *iface,
+        DWORD *chars)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%p)\n", This, chars);
+
+    if (!chars)
+        return E_POINTER;
+
+    *chars = AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ;
+
+    return S_OK;
+}
+
+static const IAudioClockVtbl AudioClock_Vtbl =
+{
+    AudioClock_QueryInterface,
+    AudioClock_AddRef,
+    AudioClock_Release,
+    AudioClock_GetFrequency,
+    AudioClock_GetPosition,
+    AudioClock_GetCharacteristics
+};
+
+static HRESULT WINAPI AudioClock2_QueryInterface(IAudioClock2 *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClock_QueryInterface(&This->IAudioClock_iface, riid, ppv);
+}
+
+static ULONG WINAPI AudioClock2_AddRef(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioClock2_Release(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioClock2_GetDevicePosition(IAudioClock2 *iface,
+        UINT64 *pos, UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    HRESULT hr = AudioClock_GetPosition(&This->IAudioClock_iface, pos, qpctime);
+    if (SUCCEEDED(hr) && This->share == AUDCLNT_SHAREMODE_SHARED)
+        *pos /= pa_frame_size(&This->ss);
+    return hr;
+}
+
+static const IAudioClock2Vtbl AudioClock2_Vtbl =
+{
+    AudioClock2_QueryInterface,
+    AudioClock2_AddRef,
+    AudioClock2_Release,
+    AudioClock2_GetDevicePosition
+};
+
+static HRESULT WINAPI AudioStreamVolume_QueryInterface(
+        IAudioStreamVolume *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IAudioStreamVolume))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    if (IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->marshal, riid, ppv);
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioStreamVolume_AddRef(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioStreamVolume_Release(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelCount(
+        IAudioStreamVolume *iface, UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if (!out)
+        return E_POINTER;
+
+    *out = This->ss.channels;
+
+    return S_OK;
+}
+
+struct pulse_info_cb_data {
+    UINT32 n;
+    float *levels;
+};
+
+static HRESULT WINAPI AudioStreamVolume_SetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, const float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    HRESULT hr;
+    int i;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if (!levels)
+        return E_POINTER;
+
+    if (count != This->ss.channels)
+        return E_INVALIDARG;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr))
+        goto out;
+
+    for (i = 0; i < count; ++i)
+        This->vol[i] = levels[i];
+
+out:
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    HRESULT hr;
+    int i;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if (!levels)
+        return E_POINTER;
+
+    if (count != This->ss.channels)
+        return E_INVALIDARG;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr))
+        goto out;
+
+    for (i = 0; i < count; ++i)
+        levels[i] = This->vol[i];
+
+out:
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioStreamVolume_SetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    HRESULT hr;
+    float volumes[PA_CHANNELS_MAX];
+
+    TRACE("(%p)->(%d, %f)\n", This, index, level);
+
+    if (level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if (index >= This->ss.channels)
+        return E_INVALIDARG;
+
+    hr = AudioStreamVolume_GetAllVolumes(iface, This->ss.channels, volumes);
+    volumes[index] = level;
+    if (SUCCEEDED(hr))
+        hr = AudioStreamVolume_SetAllVolumes(iface, This->ss.channels, volumes);
+    return hr;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float *level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    float volumes[PA_CHANNELS_MAX];
+    HRESULT hr;
+
+    TRACE("(%p)->(%d, %p)\n", This, index, level);
+
+    if (!level)
+        return E_POINTER;
+
+    if (index >= This->ss.channels)
+        return E_INVALIDARG;
+
+    hr = AudioStreamVolume_GetAllVolumes(iface, This->ss.channels, volumes);
+    if (SUCCEEDED(hr))
+        *level = volumes[index];
+    return hr;
+}
+
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl =
+{
+    AudioStreamVolume_QueryInterface,
+    AudioStreamVolume_AddRef,
+    AudioStreamVolume_Release,
+    AudioStreamVolume_GetChannelCount,
+    AudioStreamVolume_SetChannelVolume,
+    AudioStreamVolume_GetChannelVolume,
+    AudioStreamVolume_SetAllVolumes,
+    AudioStreamVolume_GetAllVolumes
+};
+
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client)
+{
+    AudioSessionWrapper *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(AudioSessionWrapper));
+    if (!ret)
+        return NULL;
+
+    ret->IAudioSessionControl2_iface.lpVtbl = &AudioSessionControl2_Vtbl;
+    ret->ISimpleAudioVolume_iface.lpVtbl = &SimpleAudioVolume_Vtbl;
+    ret->IChannelAudioVolume_iface.lpVtbl = &ChannelAudioVolume_Vtbl;
+
+    ret->ref = !client;
+
+    ret->client = client;
+    if (client) {
+        ret->session = client->session;
+        AudioClient_AddRef(&client->IAudioClient_iface);
+    }
+
+    return ret;
+}
+
+static HRESULT WINAPI AudioSessionControl_QueryInterface(
+        IAudioSessionControl2 *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IAudioSessionControl) ||
+        IsEqualIID(riid, &IID_IAudioSessionControl2))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioSessionControl_AddRef(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionControl_Release(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    if (!ref) {
+        if (This->client) {
+            This->client->session_wrapper = NULL;
+            AudioClient_Release(&This->client->IAudioClient_iface);
+        }
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetState(IAudioSessionControl2 *iface,
+        AudioSessionState *state)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ACImpl *client;
+
+    TRACE("(%p)->(%p)\n", This, state);
+
+    if (!state)
+        return NULL_PTR_ERR;
+
+    pthread_mutex_lock(&pulse_lock);
+    if (list_empty(&This->session->clients)) {
+        *state = AudioSessionStateExpired;
+        goto out;
+    }
+    LIST_FOR_EACH_ENTRY(client, &This->session->clients, ACImpl, entry) {
+        if (client->started) {
+            *state = AudioSessionStateActive;
+            goto out;
+        }
+    }
+    *state = AudioSessionStateInactive;
+
+out:
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetDisplayName(
+        IAudioSessionControl2 *iface, WCHAR **name)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, name);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDisplayName(
+        IAudioSessionControl2 *iface, const WCHAR *name, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, name, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetIconPath(
+        IAudioSessionControl2 *iface, WCHAR **path)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, path);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetIconPath(
+        IAudioSessionControl2 *iface, const WCHAR *path, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, path, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetGroupingParam(
+        IAudioSessionControl2 *iface, GUID *group)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, group);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetGroupingParam(
+        IAudioSessionControl2 *iface, const GUID *group, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%s, %s) - stub\n", This, debugstr_guid(group),
+            debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_RegisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_UnregisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionInstanceIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetProcessId(
+        IAudioSessionControl2 *iface, DWORD *pid)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%p)\n", This, pid);
+
+    if (!pid)
+        return E_POINTER;
+
+    *pid = GetCurrentProcessId();
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_IsSystemSoundsSession(
+        IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)\n", This);
+
+    return S_FALSE;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDuckingPreference(
+        IAudioSessionControl2 *iface, BOOL optout)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%d)\n", This, optout);
+
+    return S_OK;
+}
+
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl =
+{
+    AudioSessionControl_QueryInterface,
+    AudioSessionControl_AddRef,
+    AudioSessionControl_Release,
+    AudioSessionControl_GetState,
+    AudioSessionControl_GetDisplayName,
+    AudioSessionControl_SetDisplayName,
+    AudioSessionControl_GetIconPath,
+    AudioSessionControl_SetIconPath,
+    AudioSessionControl_GetGroupingParam,
+    AudioSessionControl_SetGroupingParam,
+    AudioSessionControl_RegisterAudioSessionNotification,
+    AudioSessionControl_UnregisterAudioSessionNotification,
+    AudioSessionControl_GetSessionIdentifier,
+    AudioSessionControl_GetSessionInstanceIdentifier,
+    AudioSessionControl_GetProcessId,
+    AudioSessionControl_IsSystemSoundsSession,
+    AudioSessionControl_SetDuckingPreference
+};
+
+typedef struct _SessionMgr {
+    IAudioSessionManager2 IAudioSessionManager2_iface;
+
+    LONG ref;
+
+    IMMDevice *device;
+} SessionMgr;
+
+static HRESULT WINAPI AudioSessionManager_QueryInterface(IAudioSessionManager2 *iface,
+        REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IAudioSessionManager) ||
+        IsEqualIID(riid, &IID_IAudioSessionManager2))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static inline SessionMgr *impl_from_IAudioSessionManager2(IAudioSessionManager2 *iface)
+{
+    return CONTAINING_RECORD(iface, SessionMgr, IAudioSessionManager2_iface);
+}
+
+static ULONG WINAPI AudioSessionManager_AddRef(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionManager_Release(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    if (!ref)
+        HeapFree(GetProcessHeap(), 0, This);
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetAudioSessionControl(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        IAudioSessionControl **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %x, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if (FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if (!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = (IAudioSessionControl*)&wrapper->IAudioSessionControl2_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSimpleAudioVolume(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        ISimpleAudioVolume **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %x, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if (FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if (!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = &wrapper->ISimpleAudioVolume_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSessionEnumerator(
+        IAudioSessionManager2 *iface, IAudioSessionEnumerator **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, out);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterDuckNotification(
+        IAudioSessionManager2 *iface, const WCHAR *session_id,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterDuckNotification(
+        IAudioSessionManager2 *iface,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static const IAudioSessionManager2Vtbl AudioSessionManager2_Vtbl =
+{
+    AudioSessionManager_QueryInterface,
+    AudioSessionManager_AddRef,
+    AudioSessionManager_Release,
+    AudioSessionManager_GetAudioSessionControl,
+    AudioSessionManager_GetSimpleAudioVolume,
+    AudioSessionManager_GetSessionEnumerator,
+    AudioSessionManager_RegisterSessionNotification,
+    AudioSessionManager_UnregisterSessionNotification,
+    AudioSessionManager_RegisterDuckNotification,
+    AudioSessionManager_UnregisterDuckNotification
+};
+
+static HRESULT WINAPI SimpleAudioVolume_QueryInterface(
+        ISimpleAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_ISimpleAudioVolume))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI SimpleAudioVolume_AddRef(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI SimpleAudioVolume_Release(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMasterVolume(
+        ISimpleAudioVolume *iface, float level, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%f, %s)\n", session, level, wine_dbgstr_guid(context));
+
+    if (level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if (context)
+        FIXME("Notifications not supported yet\n");
+
+    TRACE("PulseAudio does not support session volume control\n");
+
+    pthread_mutex_lock(&pulse_lock);
+    session->master_vol = level;
+    pthread_mutex_unlock(&pulse_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMasterVolume(
+        ISimpleAudioVolume *iface, float *level)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, level);
+
+    if (!level)
+        return NULL_PTR_ERR;
+
+    *level = session->master_vol;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMute(ISimpleAudioVolume *iface,
+        BOOL mute, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%u, %s)\n", session, mute, debugstr_guid(context));
+
+    if (context)
+        FIXME("Notifications not supported yet\n");
+
+    session->mute = mute;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMute(ISimpleAudioVolume *iface,
+        BOOL *mute)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, mute);
+
+    if (!mute)
+        return NULL_PTR_ERR;
+
+    *mute = session->mute;
+
+    return S_OK;
+}
+
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl  =
+{
+    SimpleAudioVolume_QueryInterface,
+    SimpleAudioVolume_AddRef,
+    SimpleAudioVolume_Release,
+    SimpleAudioVolume_SetMasterVolume,
+    SimpleAudioVolume_GetMasterVolume,
+    SimpleAudioVolume_SetMute,
+    SimpleAudioVolume_GetMute
+};
+
+static HRESULT WINAPI ChannelAudioVolume_QueryInterface(
+        IChannelAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IChannelAudioVolume))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI ChannelAudioVolume_AddRef(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI ChannelAudioVolume_Release(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelCount(
+        IChannelAudioVolume *iface, UINT32 *out)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, out);
+
+    if (!out)
+        return NULL_PTR_ERR;
+
+    *out = session->channel_count;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float level,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%d, %f, %s)\n", session, index, level,
+            wine_dbgstr_guid(context));
+
+    if (level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if (index >= session->channel_count)
+        return E_INVALIDARG;
+
+    if (context)
+        FIXME("Notifications not supported yet\n");
+
+    TRACE("PulseAudio does not support session volume control\n");
+
+    pthread_mutex_lock(&pulse_lock);
+    session->channel_vols[index] = level;
+    pthread_mutex_unlock(&pulse_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float *level)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%d, %p)\n", session, index, level);
+
+    if (!level)
+        return NULL_PTR_ERR;
+
+    if (index >= session->channel_count)
+        return E_INVALIDARG;
+
+    *level = session->channel_vols[index];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, const float *levels,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    int i;
+
+    TRACE("(%p)->(%d, %p, %s)\n", session, count, levels,
+            wine_dbgstr_guid(context));
+
+    if (!levels)
+        return NULL_PTR_ERR;
+
+    if (count != session->channel_count)
+        return E_INVALIDARG;
+
+    if (context)
+        FIXME("Notifications not supported yet\n");
+
+    TRACE("PulseAudio does not support session volume control\n");
+
+    pthread_mutex_lock(&pulse_lock);
+    for(i = 0; i < count; ++i)
+        session->channel_vols[i] = levels[i];
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, float *levels)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    int i;
+
+    TRACE("(%p)->(%d, %p)\n", session, count, levels);
+
+    if (!levels)
+        return NULL_PTR_ERR;
+
+    if (count != session->channel_count)
+        return E_INVALIDARG;
+
+    for(i = 0; i < count; ++i)
+        levels[i] = session->channel_vols[i];
+
+    return S_OK;
+}
+
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl =
+{
+    ChannelAudioVolume_QueryInterface,
+    ChannelAudioVolume_AddRef,
+    ChannelAudioVolume_Release,
+    ChannelAudioVolume_GetChannelCount,
+    ChannelAudioVolume_SetChannelVolume,
+    ChannelAudioVolume_GetChannelVolume,
+    ChannelAudioVolume_SetAllVolumes,
+    ChannelAudioVolume_GetAllVolumes
+};
+
+HRESULT WINAPI AUDDRV_GetAudioSessionManager(IMMDevice *device,
+        IAudioSessionManager2 **out)
+{
+    SessionMgr *This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(SessionMgr));
+    *out = NULL;
+    if (!This)
+        return E_OUTOFMEMORY;
+    This->IAudioSessionManager2_iface.lpVtbl = &AudioSessionManager2_Vtbl;
+    This->device = device;
+    This->ref = 1;
+    *out = &This->IAudioSessionManager2_iface;
+    return S_OK;
+}
+
+HRESULT WINAPI AUDDRV_GetPropValue(GUID *guid, const PROPERTYKEY *prop, PROPVARIANT *out)
+{
+    TRACE("%s, (%s,%u), %p\n", wine_dbgstr_guid(guid), wine_dbgstr_guid(&prop->fmtid), prop->pid, out);
+
+    if (IsEqualGUID(guid, &pulse_render_guid) && IsEqualPropertyKey(*prop, PKEY_AudioEndpoint_PhysicalSpeakers)) {
+        out->vt = VT_UI4;
+        out->ulVal = g_phys_speakers_mask;
+
+        return out->ulVal ? S_OK : E_FAIL;
+    }
+
+    return E_NOTIMPL;
+}
+
+
+
+/**********************************************************************
+ * A-law and u-law sample manipulation functions
+ * Multiply with the given volume (vol must be between 0...1 inclusive)
+ *
+ * These were taken from PulseAudio's sources but adjusted to directly
+ * fit our usage (since we use floats directly) so they should be exact.
+ */
+static UINT8 mult_alaw_sample(UINT8 sample, float vol)
+{
+    static const float decode_to_13bits_float[1 << 8] =
+    {
+         -688.0f,  -656.0f,  -752.0f,  -720.0f,  -560.0f,  -528.0f,  -624.0f,  -592.0f,
+         -944.0f,  -912.0f, -1008.0f,  -976.0f,  -816.0f,  -784.0f,  -880.0f,  -848.0f,
+         -344.0f,  -328.0f,  -376.0f,  -360.0f,  -280.0f,  -264.0f,  -312.0f,  -296.0f,
+         -472.0f,  -456.0f,  -504.0f,  -488.0f,  -408.0f,  -392.0f,  -440.0f,  -424.0f,
+        -2752.0f, -2624.0f, -3008.0f, -2880.0f, -2240.0f, -2112.0f, -2496.0f, -2368.0f,
+        -3776.0f, -3648.0f, -4032.0f, -3904.0f, -3264.0f, -3136.0f, -3520.0f, -3392.0f,
+        -1376.0f, -1312.0f, -1504.0f, -1440.0f, -1120.0f, -1056.0f, -1248.0f, -1184.0f,
+        -1888.0f, -1824.0f, -2016.0f, -1952.0f, -1632.0f, -1568.0f, -1760.0f, -1696.0f,
+          -43.0f,   -41.0f,   -47.0f,   -45.0f,   -35.0f,   -33.0f,   -39.0f,   -37.0f,
+          -59.0f,   -57.0f,   -63.0f,   -61.0f,   -51.0f,   -49.0f,   -55.0f,   -53.0f,
+          -11.0f,    -9.0f,   -15.0f,   -13.0f,    -3.0f,    -1.0f,    -7.0f,    -5.0f,
+          -27.0f,   -25.0f,   -31.0f,   -29.0f,   -19.0f,   -17.0f,   -23.0f,   -21.0f,
+         -172.0f,  -164.0f,  -188.0f,  -180.0f,  -140.0f,  -132.0f,  -156.0f,  -148.0f,
+         -236.0f,  -228.0f,  -252.0f,  -244.0f,  -204.0f,  -196.0f,  -220.0f,  -212.0f,
+          -86.0f,   -82.0f,   -94.0f,   -90.0f,   -70.0f,   -66.0f,   -78.0f,   -74.0f,
+         -118.0f,  -114.0f,  -126.0f,  -122.0f,  -102.0f,   -98.0f,  -110.0f,  -106.0f,
+          688.0f,   656.0f,   752.0f,   720.0f,   560.0f,   528.0f,   624.0f,   592.0f,
+          944.0f,   912.0f,  1008.0f,   976.0f,   816.0f,   784.0f,   880.0f,   848.0f,
+          344.0f,   328.0f,   376.0f,   360.0f,   280.0f,   264.0f,   312.0f,   296.0f,
+          472.0f,   456.0f,   504.0f,   488.0f,   408.0f,   392.0f,   440.0f,   424.0f,
+         2752.0f,  2624.0f,  3008.0f,  2880.0f,  2240.0f,  2112.0f,  2496.0f,  2368.0f,
+         3776.0f,  3648.0f,  4032.0f,  3904.0f,  3264.0f,  3136.0f,  3520.0f,  3392.0f,
+         1376.0f,  1312.0f,  1504.0f,  1440.0f,  1120.0f,  1056.0f,  1248.0f,  1184.0f,
+         1888.0f,  1824.0f,  2016.0f,  1952.0f,  1632.0f,  1568.0f,  1760.0f,  1696.0f,
+           43.0f,    41.0f,    47.0f,    45.0f,    35.0f,    33.0f,    39.0f,    37.0f,
+           59.0f,    57.0f,    63.0f,    61.0f,    51.0f,    49.0f,    55.0f,    53.0f,
+           11.0f,     9.0f,    15.0f,    13.0f,     3.0f,     1.0f,     7.0f,     5.0f,
+           27.0f,    25.0f,    31.0f,    29.0f,    19.0f,    17.0f,    23.0f,    21.0f,
+          172.0f,   164.0f,   188.0f,   180.0f,   140.0f,   132.0f,   156.0f,   148.0f,
+          236.0f,   228.0f,   252.0f,   244.0f,   204.0f,   196.0f,   220.0f,   212.0f,
+           86.0f,    82.0f,    94.0f,    90.0f,    70.0f,    66.0f,    78.0f,    74.0f,
+          118.0f,   114.0f,   126.0f,   122.0f,   102.0f,    98.0f,   110.0f,   106.0f
+    };
+
+    static const UINT8 encode[1 << 13] =
+    {
+        0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a,
+        0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a,
+        0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a,
+        0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a,
+        0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a,
+        0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a,
+        0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a,
+        0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a,
+        0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a,
+        0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2b, 0x2b,
+        0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
+        0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
+        0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
+        0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
+        0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
+        0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
+        0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
+        0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
+        0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
+        0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x28, 0x28, 0x28, 0x28,
+        0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+        0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+        0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+        0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+        0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+        0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+        0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+        0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+        0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+        0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+        0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+        0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+        0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+        0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+        0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+        0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+        0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+        0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+        0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+        0x29, 0x29, 0x29, 0x29, 0x29, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+        0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+        0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+        0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+        0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+        0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+        0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+        0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+        0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+        0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+        0x2e, 0x2e, 0x2e, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+        0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+        0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+        0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+        0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+        0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+        0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+        0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+        0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+        0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+        0x2f, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
+        0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
+        0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
+        0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
+        0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
+        0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
+        0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
+        0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
+        0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
+        0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2d,
+        0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
+        0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
+        0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
+        0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
+        0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
+        0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
+        0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
+        0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
+        0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
+        0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x22, 0x22, 0x22,
+        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x23, 0x23, 0x23, 0x23, 0x23,
+        0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+        0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+        0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+        0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+        0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+        0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+        0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+        0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+        0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+        0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+        0x20, 0x20, 0x20, 0x20, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
+        0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
+        0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
+        0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
+        0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
+        0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
+        0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
+        0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
+        0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
+        0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
+        0x21, 0x21, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
+        0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
+        0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
+        0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
+        0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
+        0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
+        0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
+        0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
+        0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
+        0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
+        0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27,
+        0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27,
+        0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27,
+        0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27,
+        0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27,
+        0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27,
+        0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27,
+        0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27,
+        0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27,
+        0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x24, 0x24,
+        0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24,
+        0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24,
+        0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24,
+        0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24,
+        0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24,
+        0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24,
+        0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24,
+        0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24,
+        0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24,
+        0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x25, 0x25, 0x25, 0x25,
+        0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
+        0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
+        0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
+        0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
+        0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
+        0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
+        0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
+        0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
+        0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
+        0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a,
+        0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a,
+        0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a,
+        0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a,
+        0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a,
+        0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b,
+        0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b,
+        0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b,
+        0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b,
+        0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b,
+        0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38,
+        0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38,
+        0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38,
+        0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38,
+        0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38,
+        0x38, 0x38, 0x38, 0x38, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39,
+        0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39,
+        0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39,
+        0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39,
+        0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39,
+        0x39, 0x39, 0x39, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e,
+        0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e,
+        0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e,
+        0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e,
+        0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e,
+        0x3e, 0x3e, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
+        0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
+        0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
+        0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
+        0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
+        0x3f, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c,
+        0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c,
+        0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c,
+        0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c,
+        0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c,
+        0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d,
+        0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d,
+        0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d,
+        0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d,
+        0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x32,
+        0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
+        0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
+        0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
+        0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
+        0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x33, 0x33,
+        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
+        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
+        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
+        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
+        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x30, 0x30, 0x30,
+        0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
+        0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
+        0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
+        0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
+        0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31,
+        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
+        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
+        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
+        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
+        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x36, 0x36, 0x36, 0x36, 0x36,
+        0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+        0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+        0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+        0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+        0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37,
+        0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37,
+        0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37,
+        0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37,
+        0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37,
+        0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34,
+        0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34,
+        0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34,
+        0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34,
+        0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34,
+        0x34, 0x34, 0x34, 0x34, 0x34, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
+        0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
+        0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
+        0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
+        0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
+        0x35, 0x35, 0x35, 0x35, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x1a, 0x1a, 0x1a, 0x1a,
+        0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1b,
+        0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b,
+        0x1b, 0x1b, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+        0x18, 0x18, 0x18, 0x18, 0x18, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
+        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+        0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1f, 0x1f,
+        0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
+        0x1f, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c,
+        0x1c, 0x1c, 0x1c, 0x1c, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
+        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
+        0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13,
+        0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,
+        0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+        0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
+        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
+        0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17,
+        0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x14,
+        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+        0x14, 0x14, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
+        0x15, 0x15, 0x15, 0x15, 0x15, 0x6a, 0x6a, 0x6a, 0x6a, 0x6a, 0x6a, 0x6a, 0x6a,
+        0x6b, 0x6b, 0x6b, 0x6b, 0x6b, 0x6b, 0x6b, 0x6b, 0x68, 0x68, 0x68, 0x68, 0x68,
+        0x68, 0x68, 0x68, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x6e, 0x6e,
+        0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6f, 0x6f, 0x6f, 0x6f, 0x6f, 0x6f, 0x6f,
+        0x6f, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6d, 0x6d, 0x6d, 0x6d,
+        0x6d, 0x6d, 0x6d, 0x6d, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x63,
+        0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,
+        0x60, 0x60, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x66, 0x66, 0x66,
+        0x66, 0x66, 0x66, 0x66, 0x66, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
+        0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x65, 0x65, 0x65, 0x65, 0x65,
+        0x65, 0x65, 0x65, 0x7a, 0x7a, 0x7a, 0x7a, 0x7b, 0x7b, 0x7b, 0x7b, 0x78, 0x78,
+        0x78, 0x78, 0x79, 0x79, 0x79, 0x79, 0x7e, 0x7e, 0x7e, 0x7e, 0x7f, 0x7f, 0x7f,
+        0x7f, 0x7c, 0x7c, 0x7c, 0x7c, 0x7d, 0x7d, 0x7d, 0x7d, 0x72, 0x72, 0x72, 0x72,
+        0x73, 0x73, 0x73, 0x73, 0x70, 0x70, 0x70, 0x70, 0x71, 0x71, 0x71, 0x71, 0x76,
+        0x76, 0x76, 0x76, 0x77, 0x77, 0x77, 0x77, 0x74, 0x74, 0x74, 0x74, 0x75, 0x75,
+        0x75, 0x75, 0x4a, 0x4a, 0x4b, 0x4b, 0x48, 0x48, 0x49, 0x49, 0x4e, 0x4e, 0x4f,
+        0x4f, 0x4c, 0x4c, 0x4d, 0x4d, 0x42, 0x42, 0x43, 0x43, 0x40, 0x40, 0x41, 0x41,
+        0x46, 0x46, 0x47, 0x47, 0x44, 0x44, 0x45, 0x45, 0x5a, 0x5a, 0x5b, 0x5b, 0x58,
+        0x58, 0x59, 0x59, 0x5e, 0x5e, 0x5f, 0x5f, 0x5c, 0x5c, 0x5d, 0x5d, 0x52, 0x52,
+        0x53, 0x53, 0x50, 0x50, 0x51, 0x51, 0x56, 0x56, 0x57, 0x57, 0x54, 0x54, 0x55,
+        0x55, 0xd5, 0xd5, 0xd4, 0xd4, 0xd7, 0xd7, 0xd6, 0xd6, 0xd1, 0xd1, 0xd0, 0xd0,
+        0xd3, 0xd3, 0xd2, 0xd2, 0xdd, 0xdd, 0xdc, 0xdc, 0xdf, 0xdf, 0xde, 0xde, 0xd9,
+        0xd9, 0xd8, 0xd8, 0xdb, 0xdb, 0xda, 0xda, 0xc5, 0xc5, 0xc4, 0xc4, 0xc7, 0xc7,
+        0xc6, 0xc6, 0xc1, 0xc1, 0xc0, 0xc0, 0xc3, 0xc3, 0xc2, 0xc2, 0xcd, 0xcd, 0xcc,
+        0xcc, 0xcf, 0xcf, 0xce, 0xce, 0xc9, 0xc9, 0xc8, 0xc8, 0xcb, 0xcb, 0xca, 0xca,
+        0xf5, 0xf5, 0xf5, 0xf5, 0xf4, 0xf4, 0xf4, 0xf4, 0xf7, 0xf7, 0xf7, 0xf7, 0xf6,
+        0xf6, 0xf6, 0xf6, 0xf1, 0xf1, 0xf1, 0xf1, 0xf0, 0xf0, 0xf0, 0xf0, 0xf3, 0xf3,
+        0xf3, 0xf3, 0xf2, 0xf2, 0xf2, 0xf2, 0xfd, 0xfd, 0xfd, 0xfd, 0xfc, 0xfc, 0xfc,
+        0xfc, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfe, 0xf9, 0xf9, 0xf9, 0xf9,
+        0xf8, 0xf8, 0xf8, 0xf8, 0xfb, 0xfb, 0xfb, 0xfb, 0xfa, 0xfa, 0xfa, 0xfa, 0xe5,
+        0xe5, 0xe5, 0xe5, 0xe5, 0xe5, 0xe5, 0xe5, 0xe4, 0xe4, 0xe4, 0xe4, 0xe4, 0xe4,
+        0xe4, 0xe4, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe6, 0xe6, 0xe6,
+        0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1,
+        0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe3, 0xe3, 0xe3, 0xe3, 0xe3,
+        0xe3, 0xe3, 0xe3, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xed, 0xed,
+        0xed, 0xed, 0xed, 0xed, 0xed, 0xed, 0xec, 0xec, 0xec, 0xec, 0xec, 0xec, 0xec,
+        0xec, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xee, 0xee, 0xee, 0xee,
+        0xee, 0xee, 0xee, 0xee, 0xe9, 0xe9, 0xe9, 0xe9, 0xe9, 0xe9, 0xe9, 0xe9, 0xe8,
+        0xe8, 0xe8, 0xe8, 0xe8, 0xe8, 0xe8, 0xe8, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb,
+        0xeb, 0xeb, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0x95, 0x95, 0x95,
+        0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95,
+        0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94,
+        0x94, 0x94, 0x94, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97,
+        0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96,
+        0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x91, 0x91, 0x91, 0x91,
+        0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x90,
+        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
+        0x90, 0x90, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93,
+        0x93, 0x93, 0x93, 0x93, 0x93, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
+        0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d,
+        0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9c, 0x9c,
+        0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c,
+        0x9c, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f,
+        0x9f, 0x9f, 0x9f, 0x9f, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e,
+        0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
+        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x98, 0x98, 0x98,
+        0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98,
+        0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b,
+        0x9b, 0x9b, 0x9b, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a,
+        0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0xb5, 0xb5,
+        0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5,
+        0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5,
+        0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5,
+        0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5,
+        0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb4, 0xb4, 0xb4,
+        0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4,
+        0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4,
+        0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4,
+        0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4,
+        0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb7, 0xb7, 0xb7, 0xb7,
+        0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7,
+        0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7,
+        0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7,
+        0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7,
+        0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6,
+        0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6,
+        0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6,
+        0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6,
+        0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6,
+        0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1,
+        0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1,
+        0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1,
+        0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1,
+        0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1,
+        0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0,
+        0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0,
+        0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0,
+        0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0,
+        0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0,
+        0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3,
+        0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3,
+        0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3,
+        0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3,
+        0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3,
+        0xb3, 0xb3, 0xb3, 0xb3, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2,
+        0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2,
+        0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2,
+        0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2,
+        0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2,
+        0xb2, 0xb2, 0xb2, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd,
+        0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd,
+        0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd,
+        0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd,
+        0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd,
+        0xbd, 0xbd, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc,
+        0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc,
+        0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc,
+        0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc,
+        0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc,
+        0xbc, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,
+        0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,
+        0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,
+        0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,
+        0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,
+        0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe,
+        0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe,
+        0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe,
+        0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe,
+        0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xb9,
+        0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9,
+        0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9,
+        0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9,
+        0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9,
+        0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb8, 0xb8,
+        0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8,
+        0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8,
+        0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8,
+        0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8,
+        0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xbb, 0xbb, 0xbb,
+        0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
+        0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
+        0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
+        0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
+        0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xba, 0xba, 0xba, 0xba,
+        0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba,
+        0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba,
+        0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba,
+        0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba,
+        0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+        0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+        0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+        0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+        0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+        0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+        0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+        0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+        0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+        0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+        0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4,
+        0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4,
+        0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4,
+        0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4,
+        0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4,
+        0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4,
+        0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4,
+        0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4,
+        0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4,
+        0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4,
+        0xa4, 0xa4, 0xa4, 0xa4, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7,
+        0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7,
+        0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7,
+        0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7,
+        0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7,
+        0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7,
+        0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7,
+        0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7,
+        0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7,
+        0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7,
+        0xa7, 0xa7, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6,
+        0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6,
+        0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6,
+        0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6,
+        0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6,
+        0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6,
+        0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6,
+        0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6,
+        0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6,
+        0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6,
+        0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1,
+        0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1,
+        0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1,
+        0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1,
+        0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1,
+        0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1,
+        0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1,
+        0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1,
+        0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1,
+        0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa0, 0xa0,
+        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
+        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
+        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
+        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
+        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
+        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
+        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
+        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
+        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
+        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa3, 0xa3, 0xa3, 0xa3,
+        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
+        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
+        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
+        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
+        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
+        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
+        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
+        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
+        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
+        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
+        0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
+        0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
+        0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
+        0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
+        0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
+        0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
+        0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
+        0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
+        0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
+        0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
+        0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
+        0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
+        0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
+        0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
+        0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
+        0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
+        0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
+        0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
+        0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
+        0xad, 0xad, 0xad, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,
+        0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,
+        0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,
+        0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,
+        0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,
+        0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,
+        0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,
+        0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,
+        0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,
+        0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,
+        0xac, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
+        0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
+        0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
+        0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
+        0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
+        0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
+        0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
+        0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
+        0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
+        0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xae,
+        0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae,
+        0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae,
+        0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae,
+        0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae,
+        0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae,
+        0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae,
+        0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae,
+        0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae,
+        0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae,
+        0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xa9, 0xa9, 0xa9,
+        0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9,
+        0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9,
+        0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9,
+        0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9,
+        0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9,
+        0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9,
+        0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9,
+        0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9,
+        0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9,
+        0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8,
+        0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8,
+        0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8,
+        0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8,
+        0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8,
+        0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8,
+        0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8,
+        0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8,
+        0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8,
+        0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8,
+        0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,
+        0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,
+        0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,
+        0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,
+        0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,
+        0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,
+        0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,
+        0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,
+        0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,
+        0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,
+        0xab, 0xab, 0xab, 0xab, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+        0xaa, 0xaa
+    };
+
+    return encode[(int)(vol * decode_to_13bits_float[sample]) + ARRAY_SIZE(encode) / 2];
+}
+
+static UINT8 mult_ulaw_sample(UINT8 sample, float vol)
+{
+    static const float decode_to_14bits_float[1 << 8] =
+    {
+        -8031.0f, -7775.0f, -7519.0f, -7263.0f, -7007.0f, -6751.0f, -6495.0f, -6239.0f,
+        -5983.0f, -5727.0f, -5471.0f, -5215.0f, -4959.0f, -4703.0f, -4447.0f, -4191.0f,
+        -3999.0f, -3871.0f, -3743.0f, -3615.0f, -3487.0f, -3359.0f, -3231.0f, -3103.0f,
+        -2975.0f, -2847.0f, -2719.0f, -2591.0f, -2463.0f, -2335.0f, -2207.0f, -2079.0f,
+        -1983.0f, -1919.0f, -1855.0f, -1791.0f, -1727.0f, -1663.0f, -1599.0f, -1535.0f,
+        -1471.0f, -1407.0f, -1343.0f, -1279.0f, -1215.0f, -1151.0f, -1087.0f, -1023.0f,
+         -975.0f,  -943.0f,  -911.0f,  -879.0f,  -847.0f,  -815.0f,  -783.0f,  -751.0f,
+         -719.0f,  -687.0f,  -655.0f,  -623.0f,  -591.0f,  -559.0f,  -527.0f,  -495.0f,
+         -471.0f,  -455.0f,  -439.0f,  -423.0f,  -407.0f,  -391.0f,  -375.0f,  -359.0f,
+         -343.0f,  -327.0f,  -311.0f,  -295.0f,  -279.0f,  -263.0f,  -247.0f,  -231.0f,
+         -219.0f,  -211.0f,  -203.0f,  -195.0f,  -187.0f,  -179.0f,  -171.0f,  -163.0f,
+         -155.0f,  -147.0f,  -139.0f,  -131.0f,  -123.0f,  -115.0f,  -107.0f,   -99.0f,
+          -93.0f,   -89.0f,   -85.0f,   -81.0f,   -77.0f,   -73.0f,   -69.0f,   -65.0f,
+          -61.0f,   -57.0f,   -53.0f,   -49.0f,   -45.0f,   -41.0f,   -37.0f,   -33.0f,
+          -30.0f,   -28.0f,   -26.0f,   -24.0f,   -22.0f,   -20.0f,   -18.0f,   -16.0f,
+          -14.0f,   -12.0f,   -10.0f,    -8.0f,    -6.0f,    -4.0f,    -2.0f,     0.0f,
+         8031.0f,  7775.0f,  7519.0f,  7263.0f,  7007.0f,  6751.0f,  6495.0f,  6239.0f,
+         5983.0f,  5727.0f,  5471.0f,  5215.0f,  4959.0f,  4703.0f,  4447.0f,  4191.0f,
+         3999.0f,  3871.0f,  3743.0f,  3615.0f,  3487.0f,  3359.0f,  3231.0f,  3103.0f,
+         2975.0f,  2847.0f,  2719.0f,  2591.0f,  2463.0f,  2335.0f,  2207.0f,  2079.0f,
+         1983.0f,  1919.0f,  1855.0f,  1791.0f,  1727.0f,  1663.0f,  1599.0f,  1535.0f,
+         1471.0f,  1407.0f,  1343.0f,  1279.0f,  1215.0f,  1151.0f,  1087.0f,  1023.0f,
+          975.0f,   943.0f,   911.0f,   879.0f,   847.0f,   815.0f,   783.0f,   751.0f,
+          719.0f,   687.0f,   655.0f,   623.0f,   591.0f,   559.0f,   527.0f,   495.0f,
+          471.0f,   455.0f,   439.0f,   423.0f,   407.0f,   391.0f,   375.0f,   359.0f,
+          343.0f,   327.0f,   311.0f,   295.0f,   279.0f,   263.0f,   247.0f,   231.0f,
+          219.0f,   211.0f,   203.0f,   195.0f,   187.0f,   179.0f,   171.0f,   163.0f,
+          155.0f,   147.0f,   139.0f,   131.0f,   123.0f,   115.0f,   107.0f,    99.0f,
+           93.0f,    89.0f,    85.0f,    81.0f,    77.0f,    73.0f,    69.0f,    65.0f,
+           61.0f,    57.0f,    53.0f,    49.0f,    45.0f,    41.0f,    37.0f,    33.0f,
+           30.0f,    28.0f,    26.0f,    24.0f,    22.0f,    20.0f,    18.0f,    16.0f,
+           14.0f,    12.0f,    10.0f,     8.0f,     6.0f,     4.0f,     2.0f,     0.0f
+    };
+
+    static const UINT8 encode[1 << 14] =
+    {
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
+        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
+        0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
+        0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+        0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
+        0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+        0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
+        0x0d, 0x0d, 0x0d, 0x0d, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
+        0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x10, 0x10, 0x10, 0x10,
+        0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+        0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+        0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+        0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+        0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+        0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+        0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+        0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+        0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
+        0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
+        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
+        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
+        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
+        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
+        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
+        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
+        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
+        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
+        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
+        0x11, 0x11, 0x11, 0x11, 0x11, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
+        0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
+        0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
+        0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
+        0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
+        0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
+        0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
+        0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
+        0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
+        0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
+        0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,
+        0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,
+        0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,
+        0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,
+        0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,
+        0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,
+        0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,
+        0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,
+        0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,
+        0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,
+        0x13, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x15,
+        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
+        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
+        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
+        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
+        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
+        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
+        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
+        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
+        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
+        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x16, 0x16, 0x16,
+        0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
+        0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
+        0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
+        0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
+        0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
+        0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
+        0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
+        0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
+        0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
+        0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17, 0x17,
+        0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
+        0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
+        0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
+        0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
+        0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
+        0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
+        0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
+        0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
+        0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
+        0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+        0x18, 0x18, 0x18, 0x18, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
+        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
+        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
+        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
+        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
+        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
+        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
+        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
+        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
+        0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
+        0x19, 0x19, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a,
+        0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a,
+        0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a,
+        0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a,
+        0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a,
+        0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a,
+        0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a,
+        0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a,
+        0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a,
+        0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a,
+        0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b,
+        0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b,
+        0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b,
+        0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b,
+        0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b,
+        0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b,
+        0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b,
+        0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b,
+        0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b,
+        0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1c, 0x1c,
+        0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c,
+        0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c,
+        0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c,
+        0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c,
+        0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c,
+        0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c,
+        0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c,
+        0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c,
+        0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c,
+        0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1d, 0x1d, 0x1d, 0x1d,
+        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
+        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
+        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
+        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
+        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
+        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
+        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
+        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
+        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
+        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+        0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+        0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+        0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+        0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+        0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+        0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+        0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+        0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+        0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+        0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
+        0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
+        0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
+        0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
+        0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
+        0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
+        0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
+        0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
+        0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
+        0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
+        0x1f, 0x1f, 0x1f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+        0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+        0x20, 0x20, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
+        0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
+        0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
+        0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
+        0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
+        0x21, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+        0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+        0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+        0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+        0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+        0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x24,
+        0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24,
+        0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24,
+        0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24,
+        0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24,
+        0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x25, 0x25,
+        0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
+        0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
+        0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
+        0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
+        0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x26, 0x26, 0x26,
+        0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
+        0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
+        0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
+        0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
+        0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x27, 0x27, 0x27, 0x27,
+        0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27,
+        0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27,
+        0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27,
+        0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27,
+        0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x28, 0x28, 0x28, 0x28, 0x28,
+        0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+        0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+        0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+        0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+        0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+        0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+        0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+        0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+        0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+        0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a,
+        0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a,
+        0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a,
+        0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a,
+        0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a,
+        0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
+        0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
+        0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
+        0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
+        0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
+        0x2b, 0x2b, 0x2b, 0x2b, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
+        0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
+        0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
+        0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
+        0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
+        0x2c, 0x2c, 0x2c, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
+        0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
+        0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
+        0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
+        0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
+        0x2d, 0x2d, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+        0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+        0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+        0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+        0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
+        0x2e, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+        0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+        0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+        0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+        0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
+        0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
+        0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
+        0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
+        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
+        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x32,
+        0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
+        0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
+        0x32, 0x32, 0x32, 0x32, 0x32, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
+        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
+        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x34, 0x34,
+        0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34,
+        0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34,
+        0x34, 0x34, 0x34, 0x34, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
+        0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
+        0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x36, 0x36, 0x36,
+        0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+        0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+        0x36, 0x36, 0x36, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37,
+        0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37,
+        0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x38, 0x38, 0x38, 0x38,
+        0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38,
+        0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38,
+        0x38, 0x38, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39,
+        0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39,
+        0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a,
+        0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a,
+        0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a,
+        0x3a, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b,
+        0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b,
+        0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c,
+        0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c,
+        0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c,
+        0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d,
+        0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d,
+        0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e,
+        0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e,
+        0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3f,
+        0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
+        0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
+        0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
+        0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x41, 0x41, 0x41, 0x41, 0x41,
+        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x42, 0x42,
+        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
+        0x42, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43,
+        0x43, 0x43, 0x43, 0x43, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
+        0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45,
+        0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x46, 0x46, 0x46,
+        0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46,
+        0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47,
+        0x47, 0x47, 0x47, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
+        0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
+        0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x4a, 0x4a, 0x4a, 0x4a,
+        0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4b,
+        0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b,
+        0x4b, 0x4b, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c,
+        0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d,
+        0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e,
+        0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x4f, 0x4f,
+        0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f,
+        0x4f, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x51, 0x51, 0x51, 0x51,
+        0x51, 0x51, 0x51, 0x51, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x53,
+        0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54,
+        0x54, 0x54, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x56, 0x56, 0x56,
+        0x56, 0x56, 0x56, 0x56, 0x56, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
+        0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x59, 0x59, 0x59, 0x59, 0x59,
+        0x59, 0x59, 0x59, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5b, 0x5b,
+        0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
+        0x5c, 0x5d, 0x5d, 0x5d, 0x5d, 0x5d, 0x5d, 0x5d, 0x5d, 0x5e, 0x5e, 0x5e, 0x5e,
+        0x5e, 0x5e, 0x5e, 0x5e, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x60,
+        0x60, 0x60, 0x60, 0x61, 0x61, 0x61, 0x61, 0x62, 0x62, 0x62, 0x62, 0x63, 0x63,
+        0x63, 0x63, 0x64, 0x64, 0x64, 0x64, 0x65, 0x65, 0x65, 0x65, 0x66, 0x66, 0x66,
+        0x66, 0x67, 0x67, 0x67, 0x67, 0x68, 0x68, 0x68, 0x68, 0x69, 0x69, 0x69, 0x69,
+        0x6a, 0x6a, 0x6a, 0x6a, 0x6b, 0x6b, 0x6b, 0x6b, 0x6c, 0x6c, 0x6c, 0x6c, 0x6d,
+        0x6d, 0x6d, 0x6d, 0x6e, 0x6e, 0x6e, 0x6e, 0x6f, 0x6f, 0x6f, 0x6f, 0x70, 0x70,
+        0x71, 0x71, 0x72, 0x72, 0x73, 0x73, 0x74, 0x74, 0x75, 0x75, 0x76, 0x76, 0x77,
+        0x77, 0x78, 0x78, 0x79, 0x79, 0x7a, 0x7a, 0x7b, 0x7b, 0x7c, 0x7c, 0x7d, 0x7d,
+        0x7e, 0x7e, 0xff, 0xfe, 0xfe, 0xfd, 0xfd, 0xfc, 0xfc, 0xfb, 0xfb, 0xfa, 0xfa,
+        0xf9, 0xf9, 0xf8, 0xf8, 0xf7, 0xf7, 0xf6, 0xf6, 0xf5, 0xf5, 0xf4, 0xf4, 0xf3,
+        0xf3, 0xf2, 0xf2, 0xf1, 0xf1, 0xf0, 0xf0, 0xef, 0xef, 0xef, 0xef, 0xee, 0xee,
+        0xee, 0xee, 0xed, 0xed, 0xed, 0xed, 0xec, 0xec, 0xec, 0xec, 0xeb, 0xeb, 0xeb,
+        0xeb, 0xea, 0xea, 0xea, 0xea, 0xe9, 0xe9, 0xe9, 0xe9, 0xe8, 0xe8, 0xe8, 0xe8,
+        0xe7, 0xe7, 0xe7, 0xe7, 0xe6, 0xe6, 0xe6, 0xe6, 0xe5, 0xe5, 0xe5, 0xe5, 0xe4,
+        0xe4, 0xe4, 0xe4, 0xe3, 0xe3, 0xe3, 0xe3, 0xe2, 0xe2, 0xe2, 0xe2, 0xe1, 0xe1,
+        0xe1, 0xe1, 0xe0, 0xe0, 0xe0, 0xe0, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf,
+        0xdf, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xde, 0xdd, 0xdd, 0xdd, 0xdd,
+        0xdd, 0xdd, 0xdd, 0xdd, 0xdc, 0xdc, 0xdc, 0xdc, 0xdc, 0xdc, 0xdc, 0xdc, 0xdb,
+        0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xda, 0xda, 0xda, 0xda, 0xda, 0xda,
+        0xda, 0xda, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd8, 0xd8, 0xd8,
+        0xd8, 0xd8, 0xd8, 0xd8, 0xd8, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7,
+        0xd6, 0xd6, 0xd6, 0xd6, 0xd6, 0xd6, 0xd6, 0xd6, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5,
+        0xd5, 0xd5, 0xd5, 0xd4, 0xd4, 0xd4, 0xd4, 0xd4, 0xd4, 0xd4, 0xd4, 0xd3, 0xd3,
+        0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd3, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2,
+        0xd2, 0xd1, 0xd1, 0xd1, 0xd1, 0xd1, 0xd1, 0xd1, 0xd1, 0xd0, 0xd0, 0xd0, 0xd0,
+        0xd0, 0xd0, 0xd0, 0xd0, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf,
+        0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xce, 0xce, 0xce, 0xce, 0xce, 0xce,
+        0xce, 0xce, 0xce, 0xce, 0xce, 0xce, 0xce, 0xce, 0xce, 0xce, 0xcd, 0xcd, 0xcd,
+        0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
+        0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
+        0xcc, 0xcc, 0xcc, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb,
+        0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xca, 0xca, 0xca, 0xca, 0xca, 0xca, 0xca,
+        0xca, 0xca, 0xca, 0xca, 0xca, 0xca, 0xca, 0xca, 0xca, 0xc9, 0xc9, 0xc9, 0xc9,
+        0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc8,
+        0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8,
+        0xc8, 0xc8, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7,
+        0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6,
+        0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc5, 0xc5, 0xc5, 0xc5, 0xc5,
+        0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 0xc4, 0xc4,
+        0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 0xc4,
+        0xc4, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3,
+        0xc3, 0xc3, 0xc3, 0xc3, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2,
+        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
+        0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc0, 0xc0, 0xc0,
+        0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0,
+        0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,
+        0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,
+        0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe,
+        0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe,
+        0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbd,
+        0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd,
+        0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd,
+        0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc,
+        0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc,
+        0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbb, 0xbb,
+        0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
+        0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
+        0xbb, 0xbb, 0xbb, 0xbb, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba,
+        0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba,
+        0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xb9, 0xb9, 0xb9,
+        0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9,
+        0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9,
+        0xb9, 0xb9, 0xb9, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8,
+        0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8,
+        0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb7, 0xb7, 0xb7, 0xb7,
+        0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7,
+        0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7,
+        0xb7, 0xb7, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6,
+        0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6,
+        0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5,
+        0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5,
+        0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5,
+        0xb5, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4,
+        0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4,
+        0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3,
+        0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3,
+        0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3,
+        0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2,
+        0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2,
+        0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1,
+        0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1,
+        0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb0,
+        0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0,
+        0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0,
+        0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
+        0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
+        0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
+        0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
+        0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf,
+        0xaf, 0xaf, 0xaf, 0xaf, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae,
+        0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae,
+        0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae,
+        0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae,
+        0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae,
+        0xae, 0xae, 0xae, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
+        0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
+        0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
+        0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
+        0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
+        0xad, 0xad, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,
+        0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,
+        0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,
+        0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,
+        0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac,
+        0xac, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,
+        0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,
+        0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,
+        0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,
+        0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,
+        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9,
+        0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9,
+        0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9,
+        0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9,
+        0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9,
+        0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa8, 0xa8,
+        0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8,
+        0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8,
+        0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8,
+        0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8,
+        0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa7, 0xa7, 0xa7,
+        0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7,
+        0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7,
+        0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7,
+        0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7,
+        0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa6, 0xa6, 0xa6, 0xa6,
+        0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6,
+        0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6,
+        0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6,
+        0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6,
+        0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+        0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+        0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+        0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+        0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
+        0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4,
+        0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4,
+        0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4,
+        0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4,
+        0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4,
+        0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
+        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
+        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
+        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
+        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
+        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
+        0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
+        0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
+        0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
+        0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
+        0xa2, 0xa2, 0xa2, 0xa2, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1,
+        0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1,
+        0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1,
+        0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1,
+        0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1,
+        0xa1, 0xa1, 0xa1, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
+        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
+        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
+        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
+        0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
+        0xa0, 0xa0, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f,
+        0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f,
+        0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f,
+        0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f,
+        0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f,
+        0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f,
+        0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f,
+        0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f,
+        0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f,
+        0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f,
+        0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e,
+        0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e,
+        0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e,
+        0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e,
+        0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e,
+        0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e,
+        0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e,
+        0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e,
+        0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e,
+        0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9d, 0x9d,
+        0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d,
+        0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d,
+        0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d,
+        0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d,
+        0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d,
+        0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d,
+        0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d,
+        0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d,
+        0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d,
+        0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9c, 0x9c, 0x9c, 0x9c,
+        0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c,
+        0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c,
+        0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c,
+        0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c,
+        0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c,
+        0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c,
+        0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c,
+        0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c,
+        0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c,
+        0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b,
+        0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b,
+        0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b,
+        0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b,
+        0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b,
+        0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b,
+        0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b,
+        0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b,
+        0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b,
+        0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b,
+        0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a,
+        0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a,
+        0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a,
+        0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a,
+        0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a,
+        0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a,
+        0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a,
+        0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a,
+        0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a,
+        0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a,
+        0x9a, 0x9a, 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
+        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
+        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
+        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
+        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
+        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
+        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
+        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
+        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
+        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
+        0x99, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98,
+        0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98,
+        0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98,
+        0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98,
+        0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98,
+        0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98,
+        0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98,
+        0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98,
+        0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98,
+        0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x97,
+        0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97,
+        0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97,
+        0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97,
+        0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97,
+        0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97,
+        0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97,
+        0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97,
+        0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97,
+        0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97,
+        0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x96, 0x96, 0x96,
+        0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96,
+        0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96,
+        0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96,
+        0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96,
+        0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96,
+        0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96,
+        0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96,
+        0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96,
+        0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96,
+        0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x95, 0x95, 0x95, 0x95, 0x95,
+        0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95,
+        0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95,
+        0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95,
+        0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95,
+        0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95,
+        0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95,
+        0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95,
+        0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95,
+        0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95,
+        0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94,
+        0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94,
+        0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94,
+        0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94,
+        0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94,
+        0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94,
+        0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94,
+        0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94,
+        0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94,
+        0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94,
+        0x94, 0x94, 0x94, 0x94, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93,
+        0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93,
+        0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93,
+        0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93,
+        0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93,
+        0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93,
+        0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93,
+        0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93,
+        0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93,
+        0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93,
+        0x93, 0x93, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
+        0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
+        0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
+        0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
+        0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
+        0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
+        0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
+        0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
+        0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
+        0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
+        0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91,
+        0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91,
+        0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91,
+        0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91,
+        0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91,
+        0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91,
+        0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91,
+        0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91,
+        0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91,
+        0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x90, 0x90,
+        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
+        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
+        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
+        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
+        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
+        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
+        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
+        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
+        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
+        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f,
+        0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e,
+        0x8e, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d,
+        0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
+        0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b,
+        0x8b, 0x8b, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a,
+        0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
+        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+        0x88, 0x88, 0x88, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
+        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
+        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
+        0x85, 0x85, 0x85, 0x85, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
+        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
+        0x82, 0x82, 0x82, 0x82, 0x82, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+        0x81, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+        0x80, 0x80, 0x80, 0x80
+    };
 
-    RegCloseKey(key);
-    WARN("No matching device in registry for GUID %s\n", debugstr_guid(guid));
-    return FALSE;
+    return encode[(int)(vol * decode_to_14bits_float[sample]) + ARRAY_SIZE(encode) / 2];
 }
diff --git a/dlls/winepulse.drv/mult.h b/dlls/winepulse.drv/mmdevdrv.c.orig
similarity index 11111111111..11111111111
rename from dlls/winepulse.drv/mult.h
rename to dlls/winepulse.drv/mmdevdrv.c.orig
index 11111111111..11111111111 100644
--- a/dlls/winepulse.drv/mult.h
+++ b/dlls/winepulse.drv/mmdevdrv.c.orig
@@ -18,7 +18,3654 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include <windef.h>
+#define NONAMELESSUNION
+#define COBJMACROS
+#undef  WINE_UNIX_LIB
+
+#include "config.h"
+#include <poll.h>
+#include <pthread.h>
+
+#include <stdarg.h>
+#include <unistd.h>
+#include <math.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include <pulse/pulseaudio.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winnls.h"
+#include "winreg.h"
+#include "wine/debug.h"
+#include "wine/unicode.h"
+#include "wine/list.h"
+
+#include "ole2.h"
+#include "dshow.h"
+#include "dsound.h"
+#include "propsys.h"
+#include "propkey.h"
+
+#include "initguid.h"
+#include "propkeydef.h"
+#include "ks.h"
+#include "ksmedia.h"
+#include "mmdeviceapi.h"
+#include "audioclient.h"
+#include "endpointvolume.h"
+#include "audiopolicy.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(pulse);
+
+#define NULL_PTR_ERR MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER)
+
+/* From <dlls/mmdevapi/mmdevapi.h> */
+enum DriverPriority {
+    Priority_Unavailable = 0,
+    Priority_Low,
+    Priority_Neutral,
+    Priority_Preferred
+};
+
+static const REFERENCE_TIME MinimumPeriod = 30000;
+static const REFERENCE_TIME DefaultPeriod = 100000;
+
+static pa_context *pulse_ctx;
+static pa_mainloop *pulse_ml;
+
+static HANDLE pulse_thread;
+static pthread_mutex_t pulse_lock;
+static pthread_cond_t pulse_cond = PTHREAD_COND_INITIALIZER;
+static struct list g_sessions = LIST_INIT(g_sessions);
+
+static UINT g_phys_speakers_mask = 0;
+
+/* Mixer format + period times */
+static WAVEFORMATEXTENSIBLE pulse_fmt[2];
+static REFERENCE_TIME pulse_min_period[2], pulse_def_period[2];
+
+static GUID pulse_render_guid =
+{ 0xfd47d9cc, 0x4218, 0x4135, { 0x9c, 0xe2, 0x0c, 0x19, 0x5c, 0x87, 0x40, 0x5b } };
+static GUID pulse_capture_guid =
+{ 0x25da76d0, 0x033c, 0x4235, { 0x90, 0x02, 0x19, 0xf4, 0x88, 0x94, 0xac, 0x6f } };
+
+static UINT8 mult_alaw_sample(UINT8, float);
+static UINT8 mult_ulaw_sample(UINT8, float);
+
+BOOL WINAPI DllMain(HINSTANCE dll, DWORD reason, void *reserved)
+{
+    if (reason == DLL_PROCESS_ATTACH) {
+        pthread_mutexattr_t attr;
+
+        DisableThreadLibraryCalls(dll);
+
+        pthread_mutexattr_init(&attr);
+        pthread_mutexattr_setprotocol(&attr, PTHREAD_PRIO_INHERIT);
+
+        if (pthread_mutex_init(&pulse_lock, &attr) != 0)
+            pthread_mutex_init(&pulse_lock, NULL);
+    } else if (reason == DLL_PROCESS_DETACH) {
+        if (pulse_thread)
+           SetThreadPriority(pulse_thread, 0);
+        if (pulse_ctx) {
+            pa_context_disconnect(pulse_ctx);
+            pa_context_unref(pulse_ctx);
+        }
+        if (pulse_ml)
+            pa_mainloop_quit(pulse_ml, 0);
+        if (pulse_thread) {
+            WaitForSingleObject(pulse_thread, INFINITE);
+            CloseHandle(pulse_thread);
+        }
+    }
+    return TRUE;
+}
+
+typedef struct ACImpl ACImpl;
+
+typedef struct _AudioSession {
+    GUID guid;
+    struct list clients;
+
+    IMMDevice *device;
+
+    float master_vol;
+    UINT32 channel_count;
+    float *channel_vols;
+    BOOL mute;
+
+    struct list entry;
+} AudioSession;
+
+typedef struct _AudioSessionWrapper {
+    IAudioSessionControl2 IAudioSessionControl2_iface;
+    IChannelAudioVolume IChannelAudioVolume_iface;
+    ISimpleAudioVolume ISimpleAudioVolume_iface;
+
+    LONG ref;
+
+    ACImpl *client;
+    AudioSession *session;
+} AudioSessionWrapper;
+
+typedef struct _ACPacket {
+    struct list entry;
+    UINT64 qpcpos;
+    BYTE *data;
+    UINT32 discont;
+} ACPacket;
+
+struct ACImpl {
+    IAudioClient IAudioClient_iface;
+    IAudioRenderClient IAudioRenderClient_iface;
+    IAudioCaptureClient IAudioCaptureClient_iface;
+    IAudioClock IAudioClock_iface;
+    IAudioClock2 IAudioClock2_iface;
+    IAudioStreamVolume IAudioStreamVolume_iface;
+    IUnknown *marshal;
+    IMMDevice *parent;
+    struct list entry;
+    float vol[PA_CHANNELS_MAX];
+
+    LONG ref;
+    EDataFlow dataflow;
+    DWORD flags;
+    AUDCLNT_SHAREMODE share;
+    HANDLE event;
+
+    INT32 locked;
+    UINT32 bufsize_frames, bufsize_bytes, capture_period, pad, started, peek_ofs, wri_offs_bytes, lcl_offs_bytes;
+    UINT32 tmp_buffer_bytes, held_bytes, peek_len, peek_buffer_len;
+    BYTE *local_buffer, *tmp_buffer, *peek_buffer;
+    void *locked_ptr;
+
+    pa_stream *stream;
+    pa_sample_spec ss;
+    pa_channel_map map;
+    pa_buffer_attr attr;
+
+    INT64 clock_lastpos, clock_written;
+
+    AudioSession *session;
+    AudioSessionWrapper *session_wrapper;
+    struct list packet_free_head;
+    struct list packet_filled_head;
+};
+
+static const WCHAR defaultW[] = {'P','u','l','s','e','a','u','d','i','o',0};
+
+static const IAudioClientVtbl AudioClient_Vtbl;
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl;
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl;
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl;
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl;
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl;
+static const IAudioClockVtbl AudioClock_Vtbl;
+static const IAudioClock2Vtbl AudioClock2_Vtbl;
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl;
+
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client);
+
+static inline ACImpl *impl_from_IAudioClient(IAudioClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClient_iface);
+}
+
+static inline ACImpl *impl_from_IAudioRenderClient(IAudioRenderClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioRenderClient_iface);
+}
+
+static inline ACImpl *impl_from_IAudioCaptureClient(IAudioCaptureClient *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioCaptureClient_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IAudioSessionControl2(IAudioSessionControl2 *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IAudioSessionControl2_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_ISimpleAudioVolume(ISimpleAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, ISimpleAudioVolume_iface);
+}
+
+static inline AudioSessionWrapper *impl_from_IChannelAudioVolume(IChannelAudioVolume *iface)
+{
+    return CONTAINING_RECORD(iface, AudioSessionWrapper, IChannelAudioVolume_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock(IAudioClock *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock_iface);
+}
+
+static inline ACImpl *impl_from_IAudioClock2(IAudioClock2 *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioClock2_iface);
+}
+
+static inline ACImpl *impl_from_IAudioStreamVolume(IAudioStreamVolume *iface)
+{
+    return CONTAINING_RECORD(iface, ACImpl, IAudioStreamVolume_iface);
+}
+
+/* Following pulseaudio design here, mainloop has the lock taken whenever
+ * it is handling something for pulse, and the lock is required whenever
+ * doing any pa_* call that can affect the state in any way
+ *
+ * pa_cond_wait is used when waiting on results, because the mainloop needs
+ * the same lock taken to affect the state
+ *
+ * This is basically the same as the pa_threaded_mainloop implementation,
+ * but that cannot be used because it uses pthread_create directly
+ *
+ * pa_threaded_mainloop_(un)lock -> pthread_mutex_(un)lock
+ * pa_threaded_mainloop_signal -> pthread_cond_broadcast
+ * pa_threaded_mainloop_wait -> pthread_cond_wait
+ */
+
+static int pulse_poll_func(struct pollfd *ufds, unsigned long nfds, int timeout, void *userdata) {
+    int r;
+    pthread_mutex_unlock(&pulse_lock);
+    r = poll(ufds, nfds, timeout);
+    pthread_mutex_lock(&pulse_lock);
+    return r;
+}
+
+static DWORD CALLBACK pulse_mainloop_thread(void *tmp) {
+    int ret;
+    pulse_ml = pa_mainloop_new();
+    pa_mainloop_set_poll_func(pulse_ml, pulse_poll_func, NULL);
+    pthread_mutex_lock(&pulse_lock);
+    pthread_cond_broadcast(&pulse_cond);
+    pa_mainloop_run(pulse_ml, &ret);
+    pthread_mutex_unlock(&pulse_lock);
+    pa_mainloop_free(pulse_ml);
+    return ret;
+}
+
+static void pulse_contextcallback(pa_context *c, void *userdata)
+{
+    switch (pa_context_get_state(c)) {
+        default:
+            FIXME("Unhandled state: %i\n", pa_context_get_state(c));
+            return;
+
+        case PA_CONTEXT_CONNECTING:
+        case PA_CONTEXT_UNCONNECTED:
+        case PA_CONTEXT_AUTHORIZING:
+        case PA_CONTEXT_SETTING_NAME:
+        case PA_CONTEXT_TERMINATED:
+            TRACE("State change to %i\n", pa_context_get_state(c));
+            return;
+
+        case PA_CONTEXT_READY:
+            TRACE("Ready\n");
+            break;
+
+        case PA_CONTEXT_FAILED:
+            WARN("Context failed: %s\n", pa_strerror(pa_context_errno(c)));
+            break;
+    }
+    pthread_cond_broadcast(&pulse_cond);
+}
+
+static void pulse_stream_state(pa_stream *s, void *user)
+{
+    pa_stream_state_t state = pa_stream_get_state(s);
+    TRACE("Stream state changed to %i\n", state);
+    pthread_cond_broadcast(&pulse_cond);
+}
+
+static const enum pa_channel_position pulse_pos_from_wfx[] = {
+    PA_CHANNEL_POSITION_FRONT_LEFT,
+    PA_CHANNEL_POSITION_FRONT_RIGHT,
+    PA_CHANNEL_POSITION_FRONT_CENTER,
+    PA_CHANNEL_POSITION_LFE,
+    PA_CHANNEL_POSITION_REAR_LEFT,
+    PA_CHANNEL_POSITION_REAR_RIGHT,
+    PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,
+    PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,
+    PA_CHANNEL_POSITION_REAR_CENTER,
+    PA_CHANNEL_POSITION_SIDE_LEFT,
+    PA_CHANNEL_POSITION_SIDE_RIGHT,
+    PA_CHANNEL_POSITION_TOP_CENTER,
+    PA_CHANNEL_POSITION_TOP_FRONT_LEFT,
+    PA_CHANNEL_POSITION_TOP_FRONT_CENTER,
+    PA_CHANNEL_POSITION_TOP_FRONT_RIGHT,
+    PA_CHANNEL_POSITION_TOP_REAR_LEFT,
+    PA_CHANNEL_POSITION_TOP_REAR_CENTER,
+    PA_CHANNEL_POSITION_TOP_REAR_RIGHT
+};
+
+static DWORD pulse_channel_map_to_channel_mask(const pa_channel_map *map)
+{
+    int i;
+    DWORD mask = 0;
+
+    for (i = 0; i < map->channels; ++i) {
+        switch (map->map[i]) {
+            default: FIXME("Unhandled channel %s\n", pa_channel_position_to_string(map->map[i])); break;
+            case PA_CHANNEL_POSITION_FRONT_LEFT: mask |= SPEAKER_FRONT_LEFT; break;
+            case PA_CHANNEL_POSITION_MONO:
+            case PA_CHANNEL_POSITION_FRONT_CENTER: mask |= SPEAKER_FRONT_CENTER; break;
+            case PA_CHANNEL_POSITION_FRONT_RIGHT: mask |= SPEAKER_FRONT_RIGHT; break;
+            case PA_CHANNEL_POSITION_REAR_LEFT: mask |= SPEAKER_BACK_LEFT; break;
+            case PA_CHANNEL_POSITION_REAR_CENTER: mask |= SPEAKER_BACK_CENTER; break;
+            case PA_CHANNEL_POSITION_REAR_RIGHT: mask |= SPEAKER_BACK_RIGHT; break;
+            case PA_CHANNEL_POSITION_LFE: mask |= SPEAKER_LOW_FREQUENCY; break;
+            case PA_CHANNEL_POSITION_SIDE_LEFT: mask |= SPEAKER_SIDE_LEFT; break;
+            case PA_CHANNEL_POSITION_SIDE_RIGHT: mask |= SPEAKER_SIDE_RIGHT; break;
+            case PA_CHANNEL_POSITION_TOP_CENTER: mask |= SPEAKER_TOP_CENTER; break;
+            case PA_CHANNEL_POSITION_TOP_FRONT_LEFT: mask |= SPEAKER_TOP_FRONT_LEFT; break;
+            case PA_CHANNEL_POSITION_TOP_FRONT_CENTER: mask |= SPEAKER_TOP_FRONT_CENTER; break;
+            case PA_CHANNEL_POSITION_TOP_FRONT_RIGHT: mask |= SPEAKER_TOP_FRONT_RIGHT; break;
+            case PA_CHANNEL_POSITION_TOP_REAR_LEFT: mask |= SPEAKER_TOP_BACK_LEFT; break;
+            case PA_CHANNEL_POSITION_TOP_REAR_CENTER: mask |= SPEAKER_TOP_BACK_CENTER; break;
+            case PA_CHANNEL_POSITION_TOP_REAR_RIGHT: mask |= SPEAKER_TOP_BACK_RIGHT; break;
+            case PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER: mask |= SPEAKER_FRONT_LEFT_OF_CENTER; break;
+            case PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER: mask |= SPEAKER_FRONT_RIGHT_OF_CENTER; break;
+        }
+    }
+
+    return mask;
+}
+
+/* For most hardware on Windows, users must choose a configuration with an even
+ * number of channels (stereo, quad, 5.1, 7.1). Users can then disable
+ * channels, but those channels are still reported to applications from
+ * GetMixFormat! Some applications behave badly if given an odd number of
+ * channels (e.g. 2.1).  Here, we find the nearest configuration that Windows
+ * would report for a given channel layout. */
+static void convert_channel_map(const pa_channel_map *pa_map, WAVEFORMATEXTENSIBLE *fmt)
+{
+    DWORD pa_mask = pulse_channel_map_to_channel_mask(pa_map);
+
+    TRACE("got mask for PA: 0x%x\n", pa_mask);
+
+    if (pa_map->channels == 1)
+    {
+        fmt->Format.nChannels = 1;
+        fmt->dwChannelMask = pa_mask;
+        return;
+    }
+
+    /* compare against known configurations and find smallest configuration
+     * which is a superset of the given speakers */
+
+    if (pa_map->channels <= 2 &&
+            (pa_mask & ~KSAUDIO_SPEAKER_STEREO) == 0)
+    {
+        fmt->Format.nChannels = 2;
+        fmt->dwChannelMask = KSAUDIO_SPEAKER_STEREO;
+        return;
+    }
+
+    if (pa_map->channels <= 4 &&
+            (pa_mask & ~KSAUDIO_SPEAKER_QUAD) == 0)
+    {
+        fmt->Format.nChannels = 4;
+        fmt->dwChannelMask = KSAUDIO_SPEAKER_QUAD;
+        return;
+    }
+
+    if (pa_map->channels <= 4 &&
+            (pa_mask & ~KSAUDIO_SPEAKER_SURROUND) == 0)
+    {
+        fmt->Format.nChannels = 4;
+        fmt->dwChannelMask = KSAUDIO_SPEAKER_SURROUND;
+        return;
+    }
+
+    if (pa_map->channels <= 6 &&
+            (pa_mask & ~KSAUDIO_SPEAKER_5POINT1) == 0)
+    {
+        fmt->Format.nChannels = 6;
+        fmt->dwChannelMask = KSAUDIO_SPEAKER_5POINT1;
+        return;
+    }
+
+    if (pa_map->channels <= 6 &&
+            (pa_mask & ~KSAUDIO_SPEAKER_5POINT1_SURROUND) == 0)
+    {
+        fmt->Format.nChannels = 6;
+        fmt->dwChannelMask = KSAUDIO_SPEAKER_5POINT1_SURROUND;
+        return;
+    }
+
+    if (pa_map->channels <= 8 &&
+            (pa_mask & ~KSAUDIO_SPEAKER_7POINT1) == 0)
+    {
+        fmt->Format.nChannels = 8;
+        fmt->dwChannelMask = KSAUDIO_SPEAKER_7POINT1;
+        return;
+    }
+
+    if (pa_map->channels <= 8 &&
+            (pa_mask & ~KSAUDIO_SPEAKER_7POINT1_SURROUND) == 0)
+    {
+        fmt->Format.nChannels = 8;
+        fmt->dwChannelMask = KSAUDIO_SPEAKER_7POINT1_SURROUND;
+        return;
+    }
+
+    /* oddball format, report truthfully */
+    fmt->Format.nChannels = pa_map->channels;
+    fmt->dwChannelMask = pa_mask;
+}
+
+static void pulse_probe_settings(int render, WAVEFORMATEXTENSIBLE *fmt) {
+    WAVEFORMATEX *wfx = &fmt->Format;
+    pa_stream *stream;
+    pa_channel_map map;
+    pa_sample_spec ss;
+    pa_buffer_attr attr;
+    int ret;
+    unsigned int length = 0;
+
+    pa_channel_map_init_auto(&map, 2, PA_CHANNEL_MAP_ALSA);
+    ss.rate = 48000;
+    ss.format = PA_SAMPLE_FLOAT32LE;
+    ss.channels = map.channels;
+
+    attr.maxlength = -1;
+    attr.tlength = -1;
+    attr.minreq = attr.fragsize = pa_frame_size(&ss);
+    attr.prebuf = 0;
+
+    stream = pa_stream_new(pulse_ctx, "format test stream", &ss, &map);
+    if (stream)
+        pa_stream_set_state_callback(stream, pulse_stream_state, NULL);
+    if (!stream)
+        ret = -1;
+    else if (render)
+        ret = pa_stream_connect_playback(stream, NULL, &attr,
+        PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS, NULL, NULL);
+    else
+        ret = pa_stream_connect_record(stream, NULL, &attr, PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS);
+    if (ret >= 0) {
+        while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0 &&
+                pa_stream_get_state(stream) == PA_STREAM_CREATING)
+        {}
+        if (pa_stream_get_state(stream) == PA_STREAM_READY) {
+            ss = *pa_stream_get_sample_spec(stream);
+            map = *pa_stream_get_channel_map(stream);
+            if (render)
+                length = pa_stream_get_buffer_attr(stream)->minreq;
+            else
+                length = pa_stream_get_buffer_attr(stream)->fragsize;
+            pa_stream_disconnect(stream);
+            while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0 &&
+                    pa_stream_get_state(stream) == PA_STREAM_READY)
+            {}
+        }
+    }
+
+    if (stream)
+        pa_stream_unref(stream);
+
+    if (length)
+        pulse_def_period[!render] = pulse_min_period[!render] = pa_bytes_to_usec(10 * length, &ss);
+
+    if (pulse_min_period[!render] < MinimumPeriod)
+        pulse_min_period[!render] = MinimumPeriod;
+
+    if (pulse_def_period[!render] < DefaultPeriod)
+        pulse_def_period[!render] = DefaultPeriod;
+
+    wfx->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
+    wfx->cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
+
+    convert_channel_map(&map, fmt);
+
+    wfx->wBitsPerSample = 8 * pa_sample_size_of_format(ss.format);
+    wfx->nSamplesPerSec = ss.rate;
+    wfx->nBlockAlign = wfx->nChannels * wfx->wBitsPerSample / 8;
+    wfx->nAvgBytesPerSec = wfx->nSamplesPerSec * wfx->nBlockAlign;
+    if (ss.format != PA_SAMPLE_S24_32LE)
+        fmt->Samples.wValidBitsPerSample = wfx->wBitsPerSample;
+    else
+        fmt->Samples.wValidBitsPerSample = 24;
+    if (ss.format == PA_SAMPLE_FLOAT32LE)
+        fmt->SubFormat = KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
+    else
+        fmt->SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
+}
+
+static HRESULT pulse_connect(void)
+{
+    int len;
+    WCHAR path[MAX_PATH], *name;
+    char *str;
+
+    if (!pulse_thread)
+    {
+        if (!(pulse_thread = CreateThread(NULL, 0, pulse_mainloop_thread, NULL, 0, NULL)))
+        {
+            ERR("Failed to create mainloop thread.\n");
+            return E_FAIL;
+        }
+        SetThreadPriority(pulse_thread, THREAD_PRIORITY_TIME_CRITICAL);
+        pthread_cond_wait(&pulse_cond, &pulse_lock);
+    }
+
+    if (pulse_ctx && PA_CONTEXT_IS_GOOD(pa_context_get_state(pulse_ctx)))
+        return S_OK;
+    if (pulse_ctx)
+        pa_context_unref(pulse_ctx);
+
+    GetModuleFileNameW(NULL, path, ARRAY_SIZE(path));
+    name = strrchrW(path, '\\');
+    if (!name)
+        name = path;
+    else
+        name++;
+    len = WideCharToMultiByte(CP_UNIXCP, 0, name, -1, NULL, 0, NULL, NULL);
+    str = pa_xmalloc(len);
+    WideCharToMultiByte(CP_UNIXCP, 0, name, -1, str, len, NULL, NULL);
+    TRACE("Name: %s\n", str);
+    pulse_ctx = pa_context_new(pa_mainloop_get_api(pulse_ml), str);
+    pa_xfree(str);
+    if (!pulse_ctx) {
+        ERR("Failed to create context\n");
+        return E_FAIL;
+    }
+
+    pa_context_set_state_callback(pulse_ctx, pulse_contextcallback, NULL);
+
+    TRACE("libpulse protocol version: %u. API Version %u\n", pa_context_get_protocol_version(pulse_ctx), PA_API_VERSION);
+    if (pa_context_connect(pulse_ctx, NULL, 0, NULL) < 0)
+        goto fail;
+
+    /* Wait for connection */
+    while (pthread_cond_wait(&pulse_cond, &pulse_lock)) {
+        pa_context_state_t state = pa_context_get_state(pulse_ctx);
+
+        if (state == PA_CONTEXT_FAILED || state == PA_CONTEXT_TERMINATED)
+            goto fail;
+
+        if (state == PA_CONTEXT_READY)
+            break;
+    }
+
+    TRACE("Connected to server %s with protocol version: %i.\n",
+        pa_context_get_server(pulse_ctx),
+        pa_context_get_server_protocol_version(pulse_ctx));
+    return S_OK;
+
+fail:
+    pa_context_unref(pulse_ctx);
+    pulse_ctx = NULL;
+    return E_FAIL;
+}
+
+/* For default PulseAudio render device, OR together all of the
+ * PKEY_AudioEndpoint_PhysicalSpeakers values of the sinks. */
+static void pulse_phys_speakers_cb(pa_context *c, const pa_sink_info *i, int eol, void *userdata)
+{
+    if (i)
+        g_phys_speakers_mask |= pulse_channel_map_to_channel_mask(&i->channel_map);
+}
+
+/* some poorly-behaved applications call audio functions during DllMain, so we
+ * have to do as much as possible without creating a new thread. this function
+ * sets up a synchronous connection to verify the server is running and query
+ * static data. */
+static HRESULT pulse_test_connect(void)
+{
+    int len, ret;
+    WCHAR path[MAX_PATH], *name;
+    char *str;
+    pa_operation *o;
+
+    pulse_ml = pa_mainloop_new();
+
+    pa_mainloop_set_poll_func(pulse_ml, pulse_poll_func, NULL);
+
+    GetModuleFileNameW(NULL, path, ARRAY_SIZE(path));
+    name = strrchrW(path, '\\');
+    if (!name)
+        name = path;
+    else
+        name++;
+    len = WideCharToMultiByte(CP_UNIXCP, 0, name, -1, NULL, 0, NULL, NULL);
+    str = pa_xmalloc(len);
+    WideCharToMultiByte(CP_UNIXCP, 0, name, -1, str, len, NULL, NULL);
+    TRACE("Name: %s\n", str);
+    pulse_ctx = pa_context_new(pa_mainloop_get_api(pulse_ml), str);
+    pa_xfree(str);
+    if (!pulse_ctx) {
+        ERR("Failed to create context\n");
+        pa_mainloop_free(pulse_ml);
+        pulse_ml = NULL;
+        return E_FAIL;
+    }
+
+    pa_context_set_state_callback(pulse_ctx, pulse_contextcallback, NULL);
+
+    TRACE("libpulse protocol version: %u. API Version %u\n", pa_context_get_protocol_version(pulse_ctx), PA_API_VERSION);
+    if (pa_context_connect(pulse_ctx, NULL, 0, NULL) < 0)
+        goto fail;
+
+    /* Wait for connection */
+    while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0) {
+        pa_context_state_t state = pa_context_get_state(pulse_ctx);
+
+        if (state == PA_CONTEXT_FAILED || state == PA_CONTEXT_TERMINATED)
+            goto fail;
+
+        if (state == PA_CONTEXT_READY)
+            break;
+    }
+
+    if (pa_context_get_state(pulse_ctx) != PA_CONTEXT_READY)
+        goto fail;
+
+    TRACE("Test-connected to server %s with protocol version: %i.\n",
+        pa_context_get_server(pulse_ctx),
+        pa_context_get_server_protocol_version(pulse_ctx));
+
+    pulse_probe_settings(1, &pulse_fmt[0]);
+    pulse_probe_settings(0, &pulse_fmt[1]);
+
+    g_phys_speakers_mask = 0;
+    o = pa_context_get_sink_info_list(pulse_ctx, &pulse_phys_speakers_cb, NULL);
+    if (o) {
+        while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0 &&
+                pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+        {}
+        pa_operation_unref(o);
+    }
+
+    pa_context_unref(pulse_ctx);
+    pulse_ctx = NULL;
+    pa_mainloop_free(pulse_ml);
+    pulse_ml = NULL;
+
+    return S_OK;
+
+fail:
+    pa_context_unref(pulse_ctx);
+    pulse_ctx = NULL;
+    pa_mainloop_free(pulse_ml);
+    pulse_ml = NULL;
+
+    return E_FAIL;
+}
+
+static HRESULT pulse_stream_valid(ACImpl *This) {
+    if (!This->stream)
+        return AUDCLNT_E_NOT_INITIALIZED;
+    if (pa_stream_get_state(This->stream) != PA_STREAM_READY)
+        return AUDCLNT_E_DEVICE_INVALIDATED;
+    return S_OK;
+}
+
+static void silence_buffer(pa_sample_format_t format, BYTE *buffer, UINT32 bytes)
+{
+    memset(buffer, format == PA_SAMPLE_U8 ? 0x80 : 0, bytes);
+}
+
+static void pulse_free_noop(void *buf)
+{
+}
+
+enum write_buffer_flags
+{
+    WINEPULSE_WRITE_NOFREE = 0x01,
+    WINEPULSE_WRITE_SILENT = 0x02
+};
+
+static int write_buffer(const ACImpl *This, BYTE *buffer, UINT32 bytes,
+                        enum write_buffer_flags flags)
+{
+    float vol[PA_CHANNELS_MAX];
+    BOOL adjust = FALSE;
+    UINT32 i, channels;
+    BYTE *end;
+
+    if (!bytes) return 0;
+    if (This->session->mute || (flags & WINEPULSE_WRITE_SILENT))
+    {
+        silence_buffer(This->ss.format, buffer, bytes);
+        goto write;
+    }
+
+    /* Adjust the buffer based on the volume for each channel */
+    channels = This->ss.channels;
+    for (i = 0; i < channels; i++)
+    {
+        vol[i] = This->vol[i] * This->session->master_vol * This->session->channel_vols[i];
+        adjust |= vol[i] != 1.0f;
+    }
+    if (!adjust) goto write;
+
+    end = buffer + bytes;
+    switch (This->ss.format)
+    {
+#ifndef WORDS_BIGENDIAN
+#define PROCESS_BUFFER(type) do         \
+{                                       \
+    type *p = (type*)buffer;            \
+    do                                  \
+    {                                   \
+        for (i = 0; i < channels; i++)  \
+            p[i] = p[i] * vol[i];       \
+        p += i;                         \
+    } while ((BYTE*)p != end);          \
+} while (0)
+    case PA_SAMPLE_S16LE:
+        PROCESS_BUFFER(INT16);
+        break;
+    case PA_SAMPLE_S32LE:
+        PROCESS_BUFFER(INT32);
+        break;
+    case PA_SAMPLE_FLOAT32LE:
+        PROCESS_BUFFER(float);
+        break;
+#undef PROCESS_BUFFER
+    case PA_SAMPLE_S24_32LE:
+    {
+        UINT32 *p = (UINT32*)buffer;
+        do
+        {
+            for (i = 0; i < channels; i++)
+            {
+                p[i] = (INT32)((INT32)(p[i] << 8) * vol[i]);
+                p[i] >>= 8;
+            }
+            p += i;
+        } while ((BYTE*)p != end);
+        break;
+    }
+    case PA_SAMPLE_S24LE:
+    {
+        /* do it 12 bytes at a time until it is no longer possible */
+        UINT32 *q = (UINT32*)buffer;
+        BYTE *p;
+
+        i = 0;
+        while (end - (BYTE*)q >= 12)
+        {
+            UINT32 v[4], k;
+            v[0] = q[0] << 8;
+            v[1] = q[1] << 16 | (q[0] >> 16 & ~0xff);
+            v[2] = q[2] << 24 | (q[1] >> 8  & ~0xff);
+            v[3] = q[2] & ~0xff;
+            for (k = 0; k < 4; k++)
+            {
+                v[k] = (INT32)((INT32)v[k] * vol[i]);
+                if (++i == channels) i = 0;
+            }
+            *q++ = v[0] >> 8  | (v[1] & ~0xff) << 16;
+            *q++ = v[1] >> 16 | (v[2] & ~0xff) << 8;
+            *q++ = v[2] >> 24 | (v[3] & ~0xff);
+        }
+        p = (BYTE*)q;
+        while (p != end)
+        {
+            UINT32 v = (INT32)((INT32)(p[0] << 8 | p[1] << 16 | p[2] << 24) * vol[i]);
+            *p++ = v >> 8  & 0xff;
+            *p++ = v >> 16 & 0xff;
+            *p++ = v >> 24;
+            if (++i == channels) i = 0;
+        }
+        break;
+    }
+#endif
+    case PA_SAMPLE_U8:
+    {
+        UINT8 *p = (UINT8*)buffer;
+        do
+        {
+            for (i = 0; i < channels; i++)
+                p[i] = (int)((p[i] - 128) * vol[i]) + 128;
+            p += i;
+        } while ((BYTE*)p != end);
+        break;
+    }
+    case PA_SAMPLE_ALAW:
+    {
+        UINT8 *p = (UINT8*)buffer;
+        do
+        {
+            for (i = 0; i < channels; i++)
+                p[i] = mult_alaw_sample(p[i], vol[i]);
+            p += i;
+        } while ((BYTE*)p != end);
+        break;
+    }
+    case PA_SAMPLE_ULAW:
+    {
+        UINT8 *p = (UINT8*)buffer;
+        do
+        {
+            for (i = 0; i < channels; i++)
+                p[i] = mult_ulaw_sample(p[i], vol[i]);
+            p += i;
+        } while ((BYTE*)p != end);
+        break;
+    }
+    default:
+        TRACE("Unhandled format %i, not adjusting volume.\n", This->ss.format);
+        break;
+    }
+
+write:
+    return pa_stream_write(This->stream, buffer, bytes,
+                           (flags & WINEPULSE_WRITE_NOFREE) ? pulse_free_noop : NULL,
+                           0, PA_SEEK_RELATIVE);
+}
+
+static void dump_attr(const pa_buffer_attr *attr) {
+    TRACE("maxlength: %u\n", attr->maxlength);
+    TRACE("minreq: %u\n", attr->minreq);
+    TRACE("fragsize: %u\n", attr->fragsize);
+    TRACE("tlength: %u\n", attr->tlength);
+    TRACE("prebuf: %u\n", attr->prebuf);
+}
+
+static void pulse_op_cb(pa_stream *s, int success, void *user) {
+    TRACE("Success: %i\n", success);
+    *(int*)user = success;
+    pthread_cond_broadcast(&pulse_cond);
+}
+
+static void pulse_attr_update(pa_stream *s, void *user) {
+    const pa_buffer_attr *attr = pa_stream_get_buffer_attr(s);
+    TRACE("New attributes or device moved:\n");
+    dump_attr(attr);
+}
+
+/* Here's the buffer setup:
+ *
+ *  vvvvvvvv sent to HW already
+ *          vvvvvvvv in Pulse buffer but rewindable
+ * [dddddddddddddddd] Pulse buffer
+ *         [dddddddddddddddd--------] mmdevapi buffer
+ *          ^^^^^^^^^^^^^^^^ pad
+ *                  ^ lcl_offs_bytes
+ *                  ^^^^^^^^^ held_bytes
+ *                          ^ wri_offs_bytes
+ *
+ * GetCurrentPadding is pad
+ *
+ * During pulse_wr_callback, we decrement pad, fill Pulse buffer, and move
+ *   lcl_offs forward
+ *
+ * During Stop, we flush the Pulse buffer
+ */
+static void pulse_wr_callback(pa_stream *s, size_t bytes, void *userdata)
+{
+    ACImpl *This = userdata;
+    UINT32 oldpad = This->pad;
+
+    if(This->local_buffer){
+        UINT32 to_write;
+        BYTE *buf = This->local_buffer + This->lcl_offs_bytes;
+
+        if(This->pad > bytes){
+            This->clock_written += bytes;
+            This->pad -= bytes;
+        }else{
+            This->clock_written += This->pad;
+            This->pad = 0;
+        }
+
+        bytes = min(bytes, This->held_bytes);
+
+        if(This->lcl_offs_bytes + bytes > This->bufsize_bytes){
+            to_write = This->bufsize_bytes - This->lcl_offs_bytes;
+            TRACE("writing small chunk of %u bytes\n", to_write);
+            write_buffer(This, buf, to_write, 0);
+            This->held_bytes -= to_write;
+            to_write = bytes - to_write;
+            This->lcl_offs_bytes = 0;
+            buf = This->local_buffer;
+        }else
+            to_write = bytes;
+
+        TRACE("writing main chunk of %u bytes\n", to_write);
+        write_buffer(This, buf, to_write, 0);
+        This->lcl_offs_bytes += to_write;
+        This->lcl_offs_bytes %= This->bufsize_bytes;
+        This->held_bytes -= to_write;
+    }else{
+        if (bytes < This->bufsize_bytes)
+            This->pad = This->bufsize_bytes - bytes;
+        else
+            This->pad = 0;
+
+        if (oldpad == This->pad)
+            return;
+
+        assert(oldpad > This->pad);
+
+        This->clock_written += oldpad - This->pad;
+        TRACE("New pad: %zu (-%zu)\n", This->pad / pa_frame_size(&This->ss), (oldpad - This->pad) / pa_frame_size(&This->ss));
+    }
+
+    if (This->event)
+        SetEvent(This->event);
+}
+
+static void pulse_underflow_callback(pa_stream *s, void *userdata)
+{
+    WARN("Underflow\n");
+}
+
+/* Latency is periodically updated even when nothing is played,
+ * because of PA_STREAM_AUTO_TIMING_UPDATE so use it as timer
+ *
+ * Perfect for passing all tests :)
+ */
+static void pulse_latency_callback(pa_stream *s, void *userdata)
+{
+    ACImpl *This = userdata;
+    if (!This->pad && This->event)
+        SetEvent(This->event);
+}
+
+static void pulse_started_callback(pa_stream *s, void *userdata)
+{
+    TRACE("(Re)started playing\n");
+}
+
+static void pulse_rd_loop(ACImpl *This, size_t bytes)
+{
+    while (bytes >= This->capture_period) {
+        ACPacket *p, *next;
+        LARGE_INTEGER stamp, freq;
+        BYTE *dst, *src;
+        size_t src_len, copy, rem = This->capture_period;
+        if (!(p = (ACPacket*)list_head(&This->packet_free_head))) {
+            p = (ACPacket*)list_head(&This->packet_filled_head);
+            if (!p->discont) {
+                next = (ACPacket*)p->entry.next;
+                next->discont = 1;
+            } else
+                p = (ACPacket*)list_tail(&This->packet_filled_head);
+            assert(This->pad == This->bufsize_bytes);
+        } else {
+            assert(This->pad < This->bufsize_bytes);
+            This->pad += This->capture_period;
+            assert(This->pad <= This->bufsize_bytes);
+        }
+        QueryPerformanceCounter(&stamp);
+        QueryPerformanceFrequency(&freq);
+        p->qpcpos = (stamp.QuadPart * (INT64)10000000) / freq.QuadPart;
+        p->discont = 0;
+        list_remove(&p->entry);
+        list_add_tail(&This->packet_filled_head, &p->entry);
+
+        dst = p->data;
+        while (rem) {
+            if (This->peek_len) {
+                copy = min(rem, This->peek_len - This->peek_ofs);
+
+                memcpy(dst, This->peek_buffer + This->peek_ofs, copy);
+
+                rem -= copy;
+                dst += copy;
+                This->peek_ofs += copy;
+                if(This->peek_len == This->peek_ofs)
+                    This->peek_len = 0;
+            } else {
+                pa_stream_peek(This->stream, (const void**)&src, &src_len);
+
+                copy = min(rem, src_len);
+
+                memcpy(dst, src, rem);
+
+                dst += copy;
+                rem -= copy;
+
+                if (copy < src_len) {
+                    if (src_len > This->peek_buffer_len) {
+                        HeapFree(GetProcessHeap(), 0, This->peek_buffer);
+                        This->peek_buffer = HeapAlloc(GetProcessHeap(), 0, src_len);
+                        This->peek_buffer_len = src_len;
+                    }
+
+                    memcpy(This->peek_buffer, src + copy, src_len - copy);
+                    This->peek_len = src_len - copy;
+                    This->peek_ofs = 0;
+                }
+
+                pa_stream_drop(This->stream);
+            }
+        }
+
+        bytes -= This->capture_period;
+    }
+}
+
+static void pulse_rd_drop(ACImpl *This, size_t bytes)
+{
+    while (bytes >= This->capture_period) {
+        size_t src_len, copy, rem = This->capture_period;
+        while (rem) {
+            const void *src;
+            pa_stream_peek(This->stream, &src, &src_len);
+            assert(src_len);
+            assert(This->peek_ofs < src_len);
+            src_len -= This->peek_ofs;
+            assert(src_len <= bytes);
+
+            copy = rem;
+            if (copy > src_len)
+                copy = src_len;
+
+            src_len -= copy;
+            rem -= copy;
+
+            if (!src_len) {
+                This->peek_ofs = 0;
+                pa_stream_drop(This->stream);
+            } else
+                This->peek_ofs += copy;
+            bytes -= copy;
+        }
+    }
+}
+
+static void pulse_rd_callback(pa_stream *s, size_t bytes, void *userdata)
+{
+    ACImpl *This = userdata;
+
+    TRACE("Readable total: %zu, fragsize: %u\n", bytes, pa_stream_get_buffer_attr(s)->fragsize);
+    assert(bytes >= This->peek_ofs);
+    bytes -= This->peek_ofs;
+    if (bytes < This->capture_period)
+        return;
+
+    if (This->started)
+        pulse_rd_loop(This, bytes);
+    else
+        pulse_rd_drop(This, bytes);
+
+    if (This->event)
+        SetEvent(This->event);
+}
+
+static HRESULT pulse_stream_connect(ACImpl *This, UINT32 period_bytes) {
+    int ret;
+    char buffer[64];
+    static LONG number;
+    pa_buffer_attr attr;
+    if (This->stream) {
+        pa_stream_disconnect(This->stream);
+        while (pa_stream_get_state(This->stream) == PA_STREAM_READY)
+            pthread_cond_wait(&pulse_cond, &pulse_lock);
+        pa_stream_unref(This->stream);
+    }
+    ret = InterlockedIncrement(&number);
+    sprintf(buffer, "audio stream #%i", ret);
+    This->stream = pa_stream_new(pulse_ctx, buffer, &This->ss, &This->map);
+
+    if (!This->stream) {
+        WARN("pa_stream_new returned error %i\n", pa_context_errno(pulse_ctx));
+        return AUDCLNT_E_ENDPOINT_CREATE_FAILED;
+    }
+
+    pa_stream_set_state_callback(This->stream, pulse_stream_state, This);
+    pa_stream_set_buffer_attr_callback(This->stream, pulse_attr_update, This);
+    pa_stream_set_moved_callback(This->stream, pulse_attr_update, This);
+
+    /* PulseAudio will fill in correct values */
+    attr.minreq = attr.fragsize = period_bytes;
+    attr.maxlength = attr.tlength = This->bufsize_bytes;
+    attr.prebuf = pa_frame_size(&This->ss);
+    dump_attr(&attr);
+    if (This->dataflow == eRender)
+        ret = pa_stream_connect_playback(This->stream, NULL, &attr,
+        PA_STREAM_START_CORKED|PA_STREAM_START_UNMUTED|PA_STREAM_AUTO_TIMING_UPDATE|PA_STREAM_INTERPOLATE_TIMING|PA_STREAM_EARLY_REQUESTS, NULL, NULL);
+    else
+        ret = pa_stream_connect_record(This->stream, NULL, &attr,
+        PA_STREAM_START_CORKED|PA_STREAM_START_UNMUTED|PA_STREAM_AUTO_TIMING_UPDATE|PA_STREAM_INTERPOLATE_TIMING|PA_STREAM_EARLY_REQUESTS);
+    if (ret < 0) {
+        WARN("Returns %i\n", ret);
+        return AUDCLNT_E_ENDPOINT_CREATE_FAILED;
+    }
+    while (pa_stream_get_state(This->stream) == PA_STREAM_CREATING)
+        pthread_cond_wait(&pulse_cond, &pulse_lock);
+    if (pa_stream_get_state(This->stream) != PA_STREAM_READY)
+        return AUDCLNT_E_ENDPOINT_CREATE_FAILED;
+
+    if (This->dataflow == eRender) {
+        pa_stream_set_write_callback(This->stream, pulse_wr_callback, This);
+        pa_stream_set_underflow_callback(This->stream, pulse_underflow_callback, This);
+        pa_stream_set_started_callback(This->stream, pulse_started_callback, This);
+    } else
+        pa_stream_set_read_callback(This->stream, pulse_rd_callback, This);
+    return S_OK;
+}
+
+HRESULT WINAPI AUDDRV_GetEndpointIDs(EDataFlow flow, const WCHAR ***ids, GUID **keys,
+        UINT *num, UINT *def_index)
+{
+    WCHAR *id;
+
+    TRACE("%d %p %p %p\n", flow, ids, num, def_index);
+
+    *num = 1;
+    *def_index = 0;
+
+    *ids = HeapAlloc(GetProcessHeap(), 0, sizeof(**ids));
+    *keys = NULL;
+    if (!*ids)
+        return E_OUTOFMEMORY;
+
+    (*ids)[0] = id = HeapAlloc(GetProcessHeap(), 0, sizeof(defaultW));
+    *keys = HeapAlloc(GetProcessHeap(), 0, sizeof(**keys));
+    if (!*keys || !id) {
+        HeapFree(GetProcessHeap(), 0, id);
+        HeapFree(GetProcessHeap(), 0, *keys);
+        HeapFree(GetProcessHeap(), 0, *ids);
+        *ids = NULL;
+        *keys = NULL;
+        return E_OUTOFMEMORY;
+    }
+    memcpy(id, defaultW, sizeof(defaultW));
+
+    if (flow == eRender)
+        (*keys)[0] = pulse_render_guid;
+    else
+        (*keys)[0] = pulse_capture_guid;
+
+    return S_OK;
+}
+
+int WINAPI AUDDRV_GetPriority(void)
+{
+    HRESULT hr;
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_test_connect();
+    pthread_mutex_unlock(&pulse_lock);
+    return SUCCEEDED(hr) ? Priority_Preferred : Priority_Unavailable;
+}
+
+HRESULT WINAPI AUDDRV_GetAudioEndpoint(GUID *guid, IMMDevice *dev, IAudioClient **out)
+{
+    ACImpl *This;
+    int i;
+    EDataFlow dataflow;
+    HRESULT hr;
+
+    TRACE("%s %p %p\n", debugstr_guid(guid), dev, out);
+    if (IsEqualGUID(guid, &pulse_render_guid))
+        dataflow = eRender;
+    else if (IsEqualGUID(guid, &pulse_capture_guid))
+        dataflow = eCapture;
+    else
+        return E_UNEXPECTED;
+
+    *out = NULL;
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*This));
+    if (!This)
+        return E_OUTOFMEMORY;
+
+    This->IAudioClient_iface.lpVtbl = &AudioClient_Vtbl;
+    This->IAudioRenderClient_iface.lpVtbl = &AudioRenderClient_Vtbl;
+    This->IAudioCaptureClient_iface.lpVtbl = &AudioCaptureClient_Vtbl;
+    This->IAudioClock_iface.lpVtbl = &AudioClock_Vtbl;
+    This->IAudioClock2_iface.lpVtbl = &AudioClock2_Vtbl;
+    This->IAudioStreamVolume_iface.lpVtbl = &AudioStreamVolume_Vtbl;
+    This->dataflow = dataflow;
+    This->parent = dev;
+    for (i = 0; i < PA_CHANNELS_MAX; ++i)
+        This->vol[i] = 1.f;
+
+    hr = CoCreateFreeThreadedMarshaler((IUnknown*)&This->IAudioClient_iface, &This->marshal);
+    if (hr) {
+        HeapFree(GetProcessHeap(), 0, This);
+        return hr;
+    }
+    IMMDevice_AddRef(This->parent);
+
+    *out = &This->IAudioClient_iface;
+    IAudioClient_AddRef(&This->IAudioClient_iface);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_QueryInterface(IAudioClient *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+
+    *ppv = NULL;
+    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IAudioClient))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    if (IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->marshal, riid, ppv);
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClient_AddRef(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioClient_Release(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    if (!ref) {
+        if (This->stream) {
+            pthread_mutex_lock(&pulse_lock);
+            if (PA_STREAM_IS_GOOD(pa_stream_get_state(This->stream))) {
+                pa_stream_disconnect(This->stream);
+                while (PA_STREAM_IS_GOOD(pa_stream_get_state(This->stream)))
+                    pthread_cond_wait(&pulse_cond, &pulse_lock);
+            }
+            pa_stream_unref(This->stream);
+            This->stream = NULL;
+            list_remove(&This->entry);
+            pthread_mutex_unlock(&pulse_lock);
+        }
+        IUnknown_Release(This->marshal);
+        IMMDevice_Release(This->parent);
+        HeapFree(GetProcessHeap(), 0, This->tmp_buffer);
+        HeapFree(GetProcessHeap(), 0, This->peek_buffer);
+        HeapFree(GetProcessHeap(), 0, This->local_buffer);
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static void dump_fmt(const WAVEFORMATEX *fmt)
+{
+    TRACE("wFormatTag: 0x%x (", fmt->wFormatTag);
+    switch(fmt->wFormatTag) {
+    case WAVE_FORMAT_PCM:
+        TRACE("WAVE_FORMAT_PCM");
+        break;
+    case WAVE_FORMAT_IEEE_FLOAT:
+        TRACE("WAVE_FORMAT_IEEE_FLOAT");
+        break;
+    case WAVE_FORMAT_EXTENSIBLE:
+        TRACE("WAVE_FORMAT_EXTENSIBLE");
+        break;
+    default:
+        TRACE("Unknown");
+        break;
+    }
+    TRACE(")\n");
+
+    TRACE("nChannels: %u\n", fmt->nChannels);
+    TRACE("nSamplesPerSec: %u\n", fmt->nSamplesPerSec);
+    TRACE("nAvgBytesPerSec: %u\n", fmt->nAvgBytesPerSec);
+    TRACE("nBlockAlign: %u\n", fmt->nBlockAlign);
+    TRACE("wBitsPerSample: %u\n", fmt->wBitsPerSample);
+    TRACE("cbSize: %u\n", fmt->cbSize);
+
+    if (fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
+        WAVEFORMATEXTENSIBLE *fmtex = (void*)fmt;
+        TRACE("dwChannelMask: %08x\n", fmtex->dwChannelMask);
+        TRACE("Samples: %04x\n", fmtex->Samples.wReserved);
+        TRACE("SubFormat: %s\n", wine_dbgstr_guid(&fmtex->SubFormat));
+    }
+}
+
+static WAVEFORMATEX *clone_format(const WAVEFORMATEX *fmt)
+{
+    WAVEFORMATEX *ret;
+    size_t size;
+
+    if (fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
+        size = sizeof(WAVEFORMATEXTENSIBLE);
+    else
+        size = sizeof(WAVEFORMATEX);
+
+    ret = CoTaskMemAlloc(size);
+    if (!ret)
+        return NULL;
+
+    memcpy(ret, fmt, size);
+
+    ret->cbSize = size - sizeof(WAVEFORMATEX);
+
+    return ret;
+}
+
+static DWORD get_channel_mask(unsigned int channels)
+{
+    switch(channels) {
+    case 0:
+        return 0;
+    case 1:
+        return KSAUDIO_SPEAKER_MONO;
+    case 2:
+        return KSAUDIO_SPEAKER_STEREO;
+    case 3:
+        return KSAUDIO_SPEAKER_STEREO | SPEAKER_LOW_FREQUENCY;
+    case 4:
+        return KSAUDIO_SPEAKER_QUAD;    /* not _SURROUND */
+    case 5:
+        return KSAUDIO_SPEAKER_QUAD | SPEAKER_LOW_FREQUENCY;
+    case 6:
+        return KSAUDIO_SPEAKER_5POINT1; /* not 5POINT1_SURROUND */
+    case 7:
+        return KSAUDIO_SPEAKER_5POINT1 | SPEAKER_BACK_CENTER;
+    case 8:
+        return KSAUDIO_SPEAKER_7POINT1_SURROUND; /* Vista deprecates 7POINT1 */
+    }
+    FIXME("Unknown speaker configuration: %u\n", channels);
+    return 0;
+}
+
+static void session_init_vols(AudioSession *session, UINT channels)
+{
+    if (session->channel_count < channels) {
+        UINT i;
+
+        if (session->channel_vols)
+            session->channel_vols = HeapReAlloc(GetProcessHeap(), 0,
+                    session->channel_vols, sizeof(float) * channels);
+        else
+            session->channel_vols = HeapAlloc(GetProcessHeap(), 0,
+                    sizeof(float) * channels);
+        if (!session->channel_vols)
+            return;
+
+        for(i = session->channel_count; i < channels; ++i)
+            session->channel_vols[i] = 1.f;
+
+        session->channel_count = channels;
+    }
+}
+
+static AudioSession *create_session(const GUID *guid, IMMDevice *device,
+        UINT num_channels)
+{
+    AudioSession *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(AudioSession));
+    if (!ret)
+        return NULL;
+
+    memcpy(&ret->guid, guid, sizeof(GUID));
+
+    ret->device = device;
+
+    list_init(&ret->clients);
+
+    list_add_head(&g_sessions, &ret->entry);
+
+    session_init_vols(ret, num_channels);
+
+    ret->master_vol = 1.f;
+
+    return ret;
+}
+
+/* if channels == 0, then this will return or create a session with
+ * matching dataflow and GUID. otherwise, channels must also match */
+static HRESULT get_audio_session(const GUID *sessionguid,
+        IMMDevice *device, UINT channels, AudioSession **out)
+{
+    AudioSession *session;
+
+    if (!sessionguid || IsEqualGUID(sessionguid, &GUID_NULL)) {
+        *out = create_session(&GUID_NULL, device, channels);
+        if (!*out)
+            return E_OUTOFMEMORY;
+
+        return S_OK;
+    }
+
+    *out = NULL;
+    LIST_FOR_EACH_ENTRY(session, &g_sessions, AudioSession, entry) {
+        if (session->device == device &&
+            IsEqualGUID(sessionguid, &session->guid)) {
+            session_init_vols(session, channels);
+            *out = session;
+            break;
+        }
+    }
+
+    if (!*out) {
+        *out = create_session(sessionguid, device, channels);
+        if (!*out)
+            return E_OUTOFMEMORY;
+    }
+
+    return S_OK;
+}
+
+static HRESULT pulse_spec_from_waveformat(ACImpl *This, const WAVEFORMATEX *fmt)
+{
+    pa_channel_map_init(&This->map);
+    This->ss.rate = fmt->nSamplesPerSec;
+    This->ss.format = PA_SAMPLE_INVALID;
+
+    switch(fmt->wFormatTag) {
+    case WAVE_FORMAT_IEEE_FLOAT:
+        if (!fmt->nChannels || fmt->nChannels > 2 || fmt->wBitsPerSample != 32)
+            break;
+        This->ss.format = PA_SAMPLE_FLOAT32LE;
+        pa_channel_map_init_auto(&This->map, fmt->nChannels, PA_CHANNEL_MAP_ALSA);
+        break;
+    case WAVE_FORMAT_PCM:
+        if (!fmt->nChannels || fmt->nChannels > 2)
+            break;
+        if (fmt->wBitsPerSample == 8)
+            This->ss.format = PA_SAMPLE_U8;
+        else if (fmt->wBitsPerSample == 16)
+            This->ss.format = PA_SAMPLE_S16LE;
+        else
+            return AUDCLNT_E_UNSUPPORTED_FORMAT;
+        pa_channel_map_init_auto(&This->map, fmt->nChannels, PA_CHANNEL_MAP_ALSA);
+        break;
+    case WAVE_FORMAT_EXTENSIBLE: {
+        WAVEFORMATEXTENSIBLE *wfe = (WAVEFORMATEXTENSIBLE*)fmt;
+        DWORD mask = wfe->dwChannelMask;
+        DWORD i = 0, j;
+        if (fmt->cbSize != (sizeof(*wfe) - sizeof(*fmt)) && fmt->cbSize != sizeof(*wfe))
+            break;
+        if (IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT) &&
+            (!wfe->Samples.wValidBitsPerSample || wfe->Samples.wValidBitsPerSample == 32) &&
+            fmt->wBitsPerSample == 32)
+            This->ss.format = PA_SAMPLE_FLOAT32LE;
+        else if (IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM)) {
+            DWORD valid = wfe->Samples.wValidBitsPerSample;
+            if (!valid)
+                valid = fmt->wBitsPerSample;
+            if (!valid || valid > fmt->wBitsPerSample)
+                break;
+            switch (fmt->wBitsPerSample) {
+                case 8:
+                    if (valid == 8)
+                        This->ss.format = PA_SAMPLE_U8;
+                    break;
+                case 16:
+                    if (valid == 16)
+                        This->ss.format = PA_SAMPLE_S16LE;
+                    break;
+                case 24:
+                    if (valid == 24)
+                        This->ss.format = PA_SAMPLE_S24LE;
+                    break;
+                case 32:
+                    if (valid == 24)
+                        This->ss.format = PA_SAMPLE_S24_32LE;
+                    else if (valid == 32)
+                        This->ss.format = PA_SAMPLE_S32LE;
+                    break;
+                default:
+                    return AUDCLNT_E_UNSUPPORTED_FORMAT;
+            }
+        }
+        This->map.channels = fmt->nChannels;
+        if (!mask || (mask & (SPEAKER_ALL|SPEAKER_RESERVED)))
+            mask = get_channel_mask(fmt->nChannels);
+        for (j = 0; j < ARRAY_SIZE(pulse_pos_from_wfx) && i < fmt->nChannels; ++j) {
+            if (mask & (1 << j))
+                This->map.map[i++] = pulse_pos_from_wfx[j];
+        }
+
+        /* Special case for mono since pulse appears to map it differently */
+        if (mask == SPEAKER_FRONT_CENTER)
+            This->map.map[0] = PA_CHANNEL_POSITION_MONO;
+
+        if (i < fmt->nChannels || (mask & SPEAKER_RESERVED)) {
+            This->map.channels = 0;
+            ERR("Invalid channel mask: %i/%i and %x(%x)\n", i, fmt->nChannels, mask, wfe->dwChannelMask);
+            break;
+        }
+        break;
+        }
+    case WAVE_FORMAT_ALAW:
+    case WAVE_FORMAT_MULAW:
+        if (fmt->wBitsPerSample != 8) {
+            FIXME("Unsupported bpp %u for LAW\n", fmt->wBitsPerSample);
+            return AUDCLNT_E_UNSUPPORTED_FORMAT;
+        }
+        if (fmt->nChannels != 1 && fmt->nChannels != 2) {
+            FIXME("Unsupported channels %u for LAW\n", fmt->nChannels);
+            return AUDCLNT_E_UNSUPPORTED_FORMAT;
+        }
+        This->ss.format = fmt->wFormatTag == WAVE_FORMAT_MULAW ? PA_SAMPLE_ULAW : PA_SAMPLE_ALAW;
+        pa_channel_map_init_auto(&This->map, fmt->nChannels, PA_CHANNEL_MAP_ALSA);
+        break;
+    default:
+        WARN("Unhandled tag %x\n", fmt->wFormatTag);
+        return AUDCLNT_E_UNSUPPORTED_FORMAT;
+    }
+    This->ss.channels = This->map.channels;
+    if (!pa_channel_map_valid(&This->map) || This->ss.format == PA_SAMPLE_INVALID) {
+        ERR("Invalid format! Channel spec valid: %i, format: %i\n", pa_channel_map_valid(&This->map), This->ss.format);
+        return AUDCLNT_E_UNSUPPORTED_FORMAT;
+    }
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Initialize(IAudioClient *iface,
+        AUDCLNT_SHAREMODE mode, DWORD flags, REFERENCE_TIME duration,
+        REFERENCE_TIME period, const WAVEFORMATEX *fmt,
+        const GUID *sessionguid)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+    UINT period_bytes;
+
+    TRACE("(%p)->(%x, %x, %s, %s, %p, %s)\n", This, mode, flags,
+          wine_dbgstr_longlong(duration), wine_dbgstr_longlong(period), fmt, debugstr_guid(sessionguid));
+
+    if (!fmt)
+        return E_POINTER;
+
+    if (mode != AUDCLNT_SHAREMODE_SHARED && mode != AUDCLNT_SHAREMODE_EXCLUSIVE)
+        return E_INVALIDARG;
+    if (mode == AUDCLNT_SHAREMODE_EXCLUSIVE)
+        return AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED;
+
+    if (flags & ~(AUDCLNT_STREAMFLAGS_CROSSPROCESS |
+                AUDCLNT_STREAMFLAGS_LOOPBACK |
+                AUDCLNT_STREAMFLAGS_EVENTCALLBACK |
+                AUDCLNT_STREAMFLAGS_NOPERSIST |
+                AUDCLNT_STREAMFLAGS_RATEADJUST |
+                AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE |
+                AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED |
+                AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY |
+                AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM)) {
+        FIXME("Unknown flags: %08x\n", flags);
+        return E_INVALIDARG;
+    }
+
+    pthread_mutex_lock(&pulse_lock);
+
+    hr = pulse_connect();
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if (This->stream) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_ALREADY_INITIALIZED;
+    }
+
+    hr = pulse_spec_from_waveformat(This, fmt);
+    TRACE("Obtaining format returns %08x\n", hr);
+    dump_fmt(fmt);
+
+    if (FAILED(hr))
+        goto exit;
+
+    if (mode == AUDCLNT_SHAREMODE_SHARED) {
+        REFERENCE_TIME def = pulse_def_period[This->dataflow == eCapture];
+        REFERENCE_TIME min = pulse_min_period[This->dataflow == eCapture];
+
+        /* Switch to low latency mode if below 2 default periods,
+         * which is 20 ms by default, this will increase the amount
+         * of interrupts but allows very low latency. In dsound I
+         * managed to get a total latency of ~8ms, which is well below
+         * default
+         */
+        if (duration < 2 * def)
+            period = min;
+        else
+            period = def;
+        if (duration < 2 * period)
+            duration = 2 * period;
+
+        /* Uh oh, really low latency requested.. */
+        if (duration <= 2 * period)
+            period /= 2;
+    }
+    period_bytes = pa_frame_size(&This->ss) * MulDiv(period, This->ss.rate, 10000000);
+
+    if (duration < 20000000)
+        This->bufsize_frames = ceil((duration / 10000000.) * fmt->nSamplesPerSec);
+    else
+        This->bufsize_frames = 2 * fmt->nSamplesPerSec;
+    This->bufsize_bytes = This->bufsize_frames * pa_frame_size(&This->ss);
+
+    This->share = mode;
+    This->flags = flags;
+    hr = pulse_stream_connect(This, period_bytes);
+    if (SUCCEEDED(hr)) {
+        UINT32 unalign;
+        const pa_buffer_attr *attr = pa_stream_get_buffer_attr(This->stream);
+        This->attr = *attr;
+        /* Update frames according to new size */
+        dump_attr(attr);
+        if (This->dataflow == eRender) {
+            if (attr->tlength < This->bufsize_bytes) {
+                TRACE("PulseAudio buffer too small (%u < %u), using tmp buffer\n", attr->tlength, This->bufsize_bytes);
+
+                This->local_buffer = HeapAlloc(GetProcessHeap(), 0, This->bufsize_bytes);
+                if(!This->local_buffer)
+                    hr = E_OUTOFMEMORY;
+            }
+        } else {
+            UINT32 i, capture_packets;
+
+            This->capture_period = period_bytes = attr->fragsize;
+            if ((unalign = This->bufsize_bytes % period_bytes))
+                This->bufsize_bytes += period_bytes - unalign;
+            This->bufsize_frames = This->bufsize_bytes / pa_frame_size(&This->ss);
+
+            capture_packets = This->bufsize_bytes / This->capture_period;
+
+            This->local_buffer = HeapAlloc(GetProcessHeap(), 0, This->bufsize_bytes + capture_packets * sizeof(ACPacket));
+            if (!This->local_buffer)
+                hr = E_OUTOFMEMORY;
+            else {
+                ACPacket *cur_packet = (ACPacket*)((char*)This->local_buffer + This->bufsize_bytes);
+                BYTE *data = This->local_buffer;
+                silence_buffer(This->ss.format, This->local_buffer, This->bufsize_bytes);
+                list_init(&This->packet_free_head);
+                list_init(&This->packet_filled_head);
+                for (i = 0; i < capture_packets; ++i, ++cur_packet) {
+                    list_add_tail(&This->packet_free_head, &cur_packet->entry);
+                    cur_packet->data = data;
+                    data += This->capture_period;
+                }
+                assert(!This->capture_period || This->bufsize_bytes == This->capture_period * capture_packets);
+                assert(!capture_packets || data - This->bufsize_bytes == This->local_buffer);
+            }
+        }
+    }
+    if (SUCCEEDED(hr))
+        hr = get_audio_session(sessionguid, This->parent, fmt->nChannels, &This->session);
+    if (SUCCEEDED(hr))
+        list_add_tail(&This->session->clients, &This->entry);
+
+exit:
+    if (FAILED(hr)) {
+        HeapFree(GetProcessHeap(), 0, This->local_buffer);
+        This->local_buffer = NULL;
+        if (This->stream) {
+            pa_stream_disconnect(This->stream);
+            pa_stream_unref(This->stream);
+            This->stream = NULL;
+        }
+    }
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetBufferSize(IAudioClient *iface,
+        UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if (!out)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (SUCCEEDED(hr))
+        *out = This->bufsize_frames;
+    pthread_mutex_unlock(&pulse_lock);
+
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetStreamLatency(IAudioClient *iface,
+        REFERENCE_TIME *latency)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    const pa_buffer_attr *attr;
+    REFERENCE_TIME lat;
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, latency);
+
+    if (!latency)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+    attr = pa_stream_get_buffer_attr(This->stream);
+    if (This->dataflow == eRender){
+        lat = attr->minreq / pa_frame_size(&This->ss);
+        lat += pulse_def_period[0];
+    }else
+        lat = attr->fragsize / pa_frame_size(&This->ss);
+    *latency = 10000000;
+    *latency *= lat;
+    *latency /= This->ss.rate;
+    pthread_mutex_unlock(&pulse_lock);
+    TRACE("Latency: %u ms\n", (DWORD)(*latency / 10000));
+    return S_OK;
+}
+
+static void ACImpl_GetRenderPad(ACImpl *This, UINT32 *out)
+{
+    *out = This->pad / pa_frame_size(&This->ss);
+}
+
+static void ACImpl_GetCapturePad(ACImpl *This, UINT32 *out)
+{
+    ACPacket *packet = This->locked_ptr;
+    if (!packet && !list_empty(&This->packet_filled_head)) {
+        packet = (ACPacket*)list_head(&This->packet_filled_head);
+        This->locked_ptr = packet;
+        list_remove(&packet->entry);
+    }
+    if (out)
+        *out = This->pad / pa_frame_size(&This->ss);
+}
+
+static HRESULT WINAPI AudioClient_GetCurrentPadding(IAudioClient *iface,
+        UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if (!out)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if (This->dataflow == eRender)
+        ACImpl_GetRenderPad(This, out);
+    else
+        ACImpl_GetCapturePad(This, out);
+    pthread_mutex_unlock(&pulse_lock);
+
+    TRACE("%p Pad: %u ms (%u)\n", This, MulDiv(*out, 1000, This->ss.rate), *out);
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_IsFormatSupported(IAudioClient *iface,
+        AUDCLNT_SHAREMODE mode, const WAVEFORMATEX *fmt,
+        WAVEFORMATEX **out)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+    WAVEFORMATEX *closest = NULL;
+    BOOL exclusive;
+
+    TRACE("(%p)->(%x, %p, %p)\n", This, mode, fmt, out);
+
+    if (!fmt)
+        return E_POINTER;
+
+    if (out)
+        *out = NULL;
+
+    if (mode == AUDCLNT_SHAREMODE_EXCLUSIVE) {
+        exclusive = 1;
+        out = NULL;
+    } else if (mode == AUDCLNT_SHAREMODE_SHARED) {
+        exclusive = 0;
+        if (!out)
+            return E_POINTER;
+    } else
+        return E_INVALIDARG;
+
+    if (fmt->nChannels == 0)
+        return AUDCLNT_E_UNSUPPORTED_FORMAT;
+
+    closest = clone_format(fmt);
+    if (!closest)
+        return E_OUTOFMEMORY;
+
+    dump_fmt(fmt);
+
+    switch (fmt->wFormatTag) {
+    case WAVE_FORMAT_EXTENSIBLE: {
+        WAVEFORMATEXTENSIBLE *ext = (WAVEFORMATEXTENSIBLE*)closest;
+
+        if ((fmt->cbSize != sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX) &&
+             fmt->cbSize != sizeof(WAVEFORMATEXTENSIBLE)) ||
+            fmt->nBlockAlign != fmt->wBitsPerSample / 8 * fmt->nChannels ||
+            ext->Samples.wValidBitsPerSample > fmt->wBitsPerSample ||
+            fmt->nAvgBytesPerSec != fmt->nBlockAlign * fmt->nSamplesPerSec) {
+            hr = E_INVALIDARG;
+            break;
+        }
+
+        if (exclusive) {
+            UINT32 mask = 0, i, channels = 0;
+
+            if (!(ext->dwChannelMask & (SPEAKER_ALL | SPEAKER_RESERVED))) {
+                for (i = 1; !(i & SPEAKER_RESERVED); i <<= 1) {
+                    if (i & ext->dwChannelMask) {
+                        mask |= i;
+                        channels++;
+                    }
+                }
+
+                if (channels != fmt->nChannels || (ext->dwChannelMask & ~mask)) {
+                    hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+                    break;
+                }
+            } else {
+                hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+                break;
+            }
+        }
+
+        if (IsEqualGUID(&ext->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)) {
+            if (fmt->wBitsPerSample != 32) {
+                hr = E_INVALIDARG;
+                break;
+            }
+
+            if (ext->Samples.wValidBitsPerSample != fmt->wBitsPerSample) {
+                hr = S_FALSE;
+                ext->Samples.wValidBitsPerSample = fmt->wBitsPerSample;
+            }
+        } else if (IsEqualGUID(&ext->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM)) {
+            if (!fmt->wBitsPerSample || fmt->wBitsPerSample > 32 || fmt->wBitsPerSample % 8) {
+                hr = E_INVALIDARG;
+                break;
+            }
+
+            if (ext->Samples.wValidBitsPerSample != fmt->wBitsPerSample &&
+                !(fmt->wBitsPerSample == 32 &&
+                  ext->Samples.wValidBitsPerSample == 24)) {
+                hr = S_FALSE;
+                ext->Samples.wValidBitsPerSample = fmt->wBitsPerSample;
+                break;
+            }
+        } else {
+            hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+            break;
+        }
+
+        break;
+    }
+
+    case WAVE_FORMAT_ALAW:
+    case WAVE_FORMAT_MULAW:
+        if (fmt->wBitsPerSample != 8) {
+            hr = E_INVALIDARG;
+            break;
+        }
+        /* Fall-through */
+    case WAVE_FORMAT_IEEE_FLOAT:
+        if (fmt->wFormatTag == WAVE_FORMAT_IEEE_FLOAT && fmt->wBitsPerSample != 32) {
+            hr = E_INVALIDARG;
+            break;
+        }
+        /* Fall-through */
+    case WAVE_FORMAT_PCM:
+        if (fmt->wFormatTag == WAVE_FORMAT_PCM &&
+            (!fmt->wBitsPerSample || fmt->wBitsPerSample > 32 || fmt->wBitsPerSample % 8)) {
+            hr = E_INVALIDARG;
+            break;
+        }
+
+        if (fmt->nChannels > 2) {
+            hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+            break;
+        }
+        /*
+         * fmt->cbSize, fmt->nBlockAlign and fmt->nAvgBytesPerSec seem to be
+         * ignored, invalid values are happily accepted.
+         */
+        break;
+    default:
+        hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+        break;
+    }
+
+    if (exclusive && hr != S_OK) {
+        hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+        CoTaskMemFree(closest);
+    } else if (hr != S_FALSE)
+        CoTaskMemFree(closest);
+    else
+        *out = closest;
+
+    /* Winepulse does not currently support exclusive mode, if you know of an
+     * application that uses it, I will correct this..
+     */
+    if (hr == S_OK && exclusive)
+        return This->dataflow == eCapture ? AUDCLNT_E_UNSUPPORTED_FORMAT : AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED;
+
+    TRACE("returning: %08x %p\n", hr, out ? *out : NULL);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetMixFormat(IAudioClient *iface,
+        WAVEFORMATEX **pwfx)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    WAVEFORMATEXTENSIBLE *fmt = &pulse_fmt[This->dataflow == eCapture];
+
+    TRACE("(%p)->(%p)\n", This, pwfx);
+
+    if (!pwfx)
+        return E_POINTER;
+
+    *pwfx = clone_format(&fmt->Format);
+    if (!*pwfx)
+        return E_OUTOFMEMORY;
+    dump_fmt(*pwfx);
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_GetDevicePeriod(IAudioClient *iface,
+        REFERENCE_TIME *defperiod, REFERENCE_TIME *minperiod)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+
+    TRACE("(%p)->(%p, %p)\n", This, defperiod, minperiod);
+
+    if (!defperiod && !minperiod)
+        return E_POINTER;
+
+    if (defperiod)
+        *defperiod = pulse_def_period[This->dataflow == eCapture];
+    if (minperiod)
+        *minperiod = pulse_min_period[This->dataflow == eCapture];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClient_Start(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+    int success;
+    pa_operation *o;
+
+    TRACE("(%p)\n", This);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if ((This->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) && !This->event) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_EVENTHANDLE_NOT_SET;
+    }
+
+    if (This->started) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_NOT_STOPPED;
+    }
+
+    if (pa_stream_is_corked(This->stream)) {
+        o = pa_stream_cork(This->stream, 0, pulse_op_cb, &success);
+        if (o) {
+            while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+                pthread_cond_wait(&pulse_cond, &pulse_lock);
+            pa_operation_unref(o);
+        } else
+            success = 0;
+        if (!success)
+            hr = E_FAIL;
+    }
+
+    if (SUCCEEDED(hr)) {
+        This->started = TRUE;
+        if (This->dataflow == eRender && This->event)
+            pa_stream_set_latency_update_callback(This->stream, pulse_latency_callback, This);
+    }
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_Stop(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+    pa_operation *o;
+    int success;
+
+    TRACE("(%p)\n", This);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if (!This->started) {
+        pthread_mutex_unlock(&pulse_lock);
+        return S_FALSE;
+    }
+
+    if (This->dataflow == eRender) {
+        o = pa_stream_cork(This->stream, 1, pulse_op_cb, &success);
+        if (o) {
+            while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+                pthread_cond_wait(&pulse_cond, &pulse_lock);
+            pa_operation_unref(o);
+        } else
+            success = 0;
+        if (!success)
+            hr = E_FAIL;
+    }
+    if (SUCCEEDED(hr)) {
+        This->started = FALSE;
+    }
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_Reset(IAudioClient *iface)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("(%p)\n", This);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if (This->started) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_NOT_STOPPED;
+    }
+
+    if (This->locked) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_BUFFER_OPERATION_PENDING;
+    }
+
+    if (This->dataflow == eRender) {
+        /* If there is still data in the render buffer it needs to be removed from the server */
+        int success = 0;
+        if (This->pad) {
+            pa_operation *o = pa_stream_flush(This->stream, pulse_op_cb, &success);
+            if (o) {
+                while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+                    pthread_cond_wait(&pulse_cond, &pulse_lock);
+                pa_operation_unref(o);
+            }
+        }
+        if (success || !This->pad){
+            This->clock_lastpos = This->clock_written = This->pad = 0;
+            This->wri_offs_bytes = This->lcl_offs_bytes = This->held_bytes = 0;
+        }
+    } else {
+        ACPacket *p;
+        This->clock_written += This->pad;
+        This->pad = 0;
+
+        if ((p = This->locked_ptr)) {
+            This->locked_ptr = NULL;
+            list_add_tail(&This->packet_free_head, &p->entry);
+        }
+        list_move_tail(&This->packet_free_head, &This->packet_filled_head);
+    }
+    pthread_mutex_unlock(&pulse_lock);
+
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_SetEventHandle(IAudioClient *iface,
+        HANDLE event)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, event);
+
+    if (!event)
+        return E_INVALIDARG;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    if (!(This->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK))
+        hr = AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED;
+    else if (This->event)
+        hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
+    else
+        This->event = event;
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClient_GetService(IAudioClient *iface, REFIID riid,
+        void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    pthread_mutex_unlock(&pulse_lock);
+    if (FAILED(hr))
+        return hr;
+
+    if (IsEqualIID(riid, &IID_IAudioRenderClient)) {
+        if (This->dataflow != eRender)
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        *ppv = &This->IAudioRenderClient_iface;
+    } else if (IsEqualIID(riid, &IID_IAudioCaptureClient)) {
+        if (This->dataflow != eCapture)
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        *ppv = &This->IAudioCaptureClient_iface;
+    } else if (IsEqualIID(riid, &IID_IAudioClock)) {
+        *ppv = &This->IAudioClock_iface;
+    } else if (IsEqualIID(riid, &IID_IAudioStreamVolume)) {
+        *ppv = &This->IAudioStreamVolume_iface;
+    } else if (IsEqualIID(riid, &IID_IAudioSessionControl) ||
+               IsEqualIID(riid, &IID_IChannelAudioVolume) ||
+               IsEqualIID(riid, &IID_ISimpleAudioVolume)) {
+        if (!This->session_wrapper) {
+            This->session_wrapper = AudioSessionWrapper_Create(This);
+            if (!This->session_wrapper)
+                return E_OUTOFMEMORY;
+        }
+        if (IsEqualIID(riid, &IID_IAudioSessionControl))
+            *ppv = &This->session_wrapper->IAudioSessionControl2_iface;
+        else if (IsEqualIID(riid, &IID_IChannelAudioVolume))
+            *ppv = &This->session_wrapper->IChannelAudioVolume_iface;
+        else if (IsEqualIID(riid, &IID_ISimpleAudioVolume))
+            *ppv = &This->session_wrapper->ISimpleAudioVolume_iface;
+    }
+
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    FIXME("stub %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static const IAudioClientVtbl AudioClient_Vtbl =
+{
+    AudioClient_QueryInterface,
+    AudioClient_AddRef,
+    AudioClient_Release,
+    AudioClient_Initialize,
+    AudioClient_GetBufferSize,
+    AudioClient_GetStreamLatency,
+    AudioClient_GetCurrentPadding,
+    AudioClient_IsFormatSupported,
+    AudioClient_GetMixFormat,
+    AudioClient_GetDevicePeriod,
+    AudioClient_Start,
+    AudioClient_Stop,
+    AudioClient_Reset,
+    AudioClient_SetEventHandle,
+    AudioClient_GetService
+};
+
+static HRESULT WINAPI AudioRenderClient_QueryInterface(
+        IAudioRenderClient *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IAudioRenderClient))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    if (IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->marshal, riid, ppv);
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioRenderClient_AddRef(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioRenderClient_Release(IAudioRenderClient *iface)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    return AudioClient_Release(&This->IAudioClient_iface);
+}
+
+static void alloc_tmp_buffer(ACImpl *This, UINT32 bytes)
+{
+    if(This->tmp_buffer_bytes >= bytes)
+        return;
+
+    HeapFree(GetProcessHeap(), 0, This->tmp_buffer);
+    This->tmp_buffer = HeapAlloc(GetProcessHeap(), 0, bytes);
+    This->tmp_buffer_bytes = bytes;
+}
+
+static HRESULT WINAPI AudioRenderClient_GetBuffer(IAudioRenderClient *iface,
+        UINT32 frames, BYTE **data)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    size_t avail, req, bytes = frames * pa_frame_size(&This->ss);
+    UINT32 pad;
+    HRESULT hr = S_OK;
+    int ret = -1;
+
+    TRACE("(%p)->(%u, %p)\n", This, frames, data);
+
+    if (!data)
+        return E_POINTER;
+    *data = NULL;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr) || This->locked) {
+        pthread_mutex_unlock(&pulse_lock);
+        return FAILED(hr) ? hr : AUDCLNT_E_OUT_OF_ORDER;
+    }
+    if (!frames) {
+        pthread_mutex_unlock(&pulse_lock);
+        return S_OK;
+    }
+
+    ACImpl_GetRenderPad(This, &pad);
+    avail = This->bufsize_frames - pad;
+    if (avail < frames || bytes > This->bufsize_bytes) {
+        pthread_mutex_unlock(&pulse_lock);
+        WARN("Wanted to write %u, but only %zu available\n", frames, avail);
+        return AUDCLNT_E_BUFFER_TOO_LARGE;
+    }
+
+    if(This->local_buffer){
+        if(This->wri_offs_bytes + bytes > This->bufsize_bytes){
+            alloc_tmp_buffer(This, bytes);
+            *data = This->tmp_buffer;
+            This->locked = -frames;
+        }else{
+            *data = This->local_buffer + This->wri_offs_bytes;
+            This->locked = frames;
+        }
+    }else{
+        req = bytes;
+        ret = pa_stream_begin_write(This->stream, &This->locked_ptr, &req);
+        if (ret < 0 || req < bytes) {
+            FIXME("%p Not using pulse locked data: %i %zu/%u %u/%u\n", This, ret, req/pa_frame_size(&This->ss), frames, pad, This->bufsize_frames);
+            if (ret >= 0)
+                pa_stream_cancel_write(This->stream);
+            alloc_tmp_buffer(This, bytes);
+            *data = This->tmp_buffer;
+            This->locked_ptr = NULL;
+        } else
+            *data = This->locked_ptr;
+
+        This->locked = frames;
+    }
+
+    silence_buffer(This->ss.format, *data, bytes);
+
+    pthread_mutex_unlock(&pulse_lock);
+
+    return hr;
+}
+
+static void pulse_wrap_buffer(ACImpl *This, BYTE *buffer, UINT32 written_bytes)
+{
+    UINT32 chunk_bytes = This->bufsize_bytes - This->wri_offs_bytes;
+
+    if(written_bytes <= chunk_bytes){
+        memcpy(This->local_buffer + This->wri_offs_bytes, buffer, written_bytes);
+    }else{
+        memcpy(This->local_buffer + This->wri_offs_bytes, buffer, chunk_bytes);
+        memcpy(This->local_buffer, buffer + chunk_bytes,
+                written_bytes - chunk_bytes);
+    }
+}
+
+static HRESULT WINAPI AudioRenderClient_ReleaseBuffer(
+        IAudioRenderClient *iface, UINT32 written_frames, DWORD flags)
+{
+    ACImpl *This = impl_from_IAudioRenderClient(iface);
+    UINT32 written_bytes = written_frames * pa_frame_size(&This->ss);
+
+    TRACE("(%p)->(%u, %x)\n", This, written_frames, flags);
+
+    pthread_mutex_lock(&pulse_lock);
+    if (!This->locked || !written_frames) {
+        if (This->locked_ptr)
+            pa_stream_cancel_write(This->stream);
+        This->locked = 0;
+        This->locked_ptr = NULL;
+        pthread_mutex_unlock(&pulse_lock);
+        return written_frames ? AUDCLNT_E_OUT_OF_ORDER : S_OK;
+    }
+
+    if (This->locked < written_frames) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_INVALID_SIZE;
+    }
+
+    if(This->local_buffer){
+        BYTE *buffer;
+
+        if(This->locked >= 0)
+            buffer = This->local_buffer + This->wri_offs_bytes;
+        else
+            buffer = This->tmp_buffer;
+
+        if(flags & AUDCLNT_BUFFERFLAGS_SILENT)
+            silence_buffer(This->ss.format, buffer, written_bytes);
+
+        if(This->locked < 0)
+            pulse_wrap_buffer(This, buffer, written_bytes);
+
+        This->wri_offs_bytes += written_bytes;
+        This->wri_offs_bytes %= This->bufsize_bytes;
+
+        This->pad += written_bytes;
+        This->held_bytes += written_bytes;
+
+        if(This->held_bytes == This->pad){
+            int e;
+            UINT32 to_write = min(This->attr.tlength, written_bytes);
+
+            /* nothing in PA, so send data immediately */
+
+            TRACE("pre-writing %u bytes\n", to_write);
+
+            e = write_buffer(This, buffer, to_write, 0);
+            if(e)
+                ERR("pa_stream_write failed: 0x%x\n", e);
+
+            This->lcl_offs_bytes += to_write;
+            This->lcl_offs_bytes %= This->bufsize_bytes;
+            This->held_bytes -= to_write;
+        }
+
+    }else{
+        enum write_buffer_flags wr_flags = 0;
+
+        if (flags & AUDCLNT_BUFFERFLAGS_SILENT) wr_flags |= WINEPULSE_WRITE_SILENT;
+        if (!This->locked_ptr) wr_flags |= WINEPULSE_WRITE_NOFREE;
+
+        write_buffer(This, This->locked_ptr ? This->locked_ptr : This->tmp_buffer, written_bytes, wr_flags);
+        This->pad += written_bytes;
+    }
+
+    if (!pa_stream_is_corked(This->stream)) {
+        int success;
+        pa_operation *o;
+        o = pa_stream_trigger(This->stream, pulse_op_cb, &success);
+        if (o) {
+            while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+                pthread_cond_wait(&pulse_cond, &pulse_lock);
+            pa_operation_unref(o);
+        }
+    }
+
+    This->locked = 0;
+    This->locked_ptr = NULL;
+    TRACE("Released %u, pad %zu\n", written_frames, This->pad / pa_frame_size(&This->ss));
+    assert(This->pad <= This->bufsize_bytes);
+
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static const IAudioRenderClientVtbl AudioRenderClient_Vtbl = {
+    AudioRenderClient_QueryInterface,
+    AudioRenderClient_AddRef,
+    AudioRenderClient_Release,
+    AudioRenderClient_GetBuffer,
+    AudioRenderClient_ReleaseBuffer
+};
+
+static HRESULT WINAPI AudioCaptureClient_QueryInterface(
+        IAudioCaptureClient *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IAudioCaptureClient))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    if (IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->marshal, riid, ppv);
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioCaptureClient_AddRef(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioCaptureClient_Release(IAudioCaptureClient *iface)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetBuffer(IAudioCaptureClient *iface,
+        BYTE **data, UINT32 *frames, DWORD *flags, UINT64 *devpos,
+        UINT64 *qpcpos)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+    HRESULT hr;
+    ACPacket *packet;
+
+    TRACE("(%p)->(%p, %p, %p, %p, %p)\n", This, data, frames, flags,
+            devpos, qpcpos);
+
+    if (!data)
+       return E_POINTER;
+
+    *data = NULL;
+
+    if (!frames || !flags)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr) || This->locked) {
+        pthread_mutex_unlock(&pulse_lock);
+        return FAILED(hr) ? hr : AUDCLNT_E_OUT_OF_ORDER;
+    }
+
+    ACImpl_GetCapturePad(This, NULL);
+    if ((packet = This->locked_ptr)) {
+        *frames = This->capture_period / pa_frame_size(&This->ss);
+        *flags = 0;
+        if (packet->discont)
+            *flags |= AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY;
+        if (devpos) {
+            if (packet->discont)
+                *devpos = (This->clock_written + This->capture_period) / pa_frame_size(&This->ss);
+            else
+                *devpos = This->clock_written / pa_frame_size(&This->ss);
+        }
+        if (qpcpos)
+            *qpcpos = packet->qpcpos;
+        *data = packet->data;
+    }
+    else
+        *frames = 0;
+    This->locked = *frames;
+    pthread_mutex_unlock(&pulse_lock);
+    return *frames ? S_OK : AUDCLNT_S_BUFFER_EMPTY;
+}
+
+static HRESULT WINAPI AudioCaptureClient_ReleaseBuffer(
+        IAudioCaptureClient *iface, UINT32 done)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+
+    TRACE("(%p)->(%u)\n", This, done);
+
+    pthread_mutex_lock(&pulse_lock);
+    if (!This->locked && done) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_OUT_OF_ORDER;
+    }
+    if (done && This->locked != done) {
+        pthread_mutex_unlock(&pulse_lock);
+        return AUDCLNT_E_INVALID_SIZE;
+    }
+    if (done) {
+        ACPacket *packet = This->locked_ptr;
+        This->locked_ptr = NULL;
+        This->pad -= This->capture_period;
+        if (packet->discont)
+            This->clock_written += 2 * This->capture_period;
+        else
+            This->clock_written += This->capture_period;
+        list_add_tail(&This->packet_free_head, &packet->entry);
+    }
+    This->locked = 0;
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioCaptureClient_GetNextPacketSize(
+        IAudioCaptureClient *iface, UINT32 *frames)
+{
+    ACImpl *This = impl_from_IAudioCaptureClient(iface);
+
+    TRACE("(%p)->(%p)\n", This, frames);
+    if (!frames)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    ACImpl_GetCapturePad(This, NULL);
+    if (This->locked_ptr)
+        *frames = This->capture_period / pa_frame_size(&This->ss);
+    else
+        *frames = 0;
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static const IAudioCaptureClientVtbl AudioCaptureClient_Vtbl =
+{
+    AudioCaptureClient_QueryInterface,
+    AudioCaptureClient_AddRef,
+    AudioCaptureClient_Release,
+    AudioCaptureClient_GetBuffer,
+    AudioCaptureClient_ReleaseBuffer,
+    AudioCaptureClient_GetNextPacketSize
+};
+
+static HRESULT WINAPI AudioClock_QueryInterface(IAudioClock *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IAudioClock))
+        *ppv = iface;
+    else if (IsEqualIID(riid, &IID_IAudioClock2))
+        *ppv = &This->IAudioClock2_iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    if (IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->marshal, riid, ppv);
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioClock_AddRef(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioClock_Release(IAudioClock *iface)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioClock_GetFrequency(IAudioClock *iface, UINT64 *freq)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p)\n", This, freq);
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (SUCCEEDED(hr)) {
+        *freq = This->ss.rate;
+        if (This->share == AUDCLNT_SHAREMODE_SHARED)
+            *freq *= pa_frame_size(&This->ss);
+    }
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioClock_GetPosition(IAudioClock *iface, UINT64 *pos,
+        UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%p, %p)\n", This, pos, qpctime);
+
+    if (!pos)
+        return E_POINTER;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr)) {
+        pthread_mutex_unlock(&pulse_lock);
+        return hr;
+    }
+
+    *pos = This->clock_written;
+
+    if (This->share == AUDCLNT_SHAREMODE_EXCLUSIVE)
+        *pos /= pa_frame_size(&This->ss);
+
+    /* Make time never go backwards */
+    if (*pos < This->clock_lastpos)
+        *pos = This->clock_lastpos;
+    else
+        This->clock_lastpos = *pos;
+    pthread_mutex_unlock(&pulse_lock);
+
+    TRACE("%p Position: %u\n", This, (unsigned)*pos);
+
+    if (qpctime) {
+        LARGE_INTEGER stamp, freq;
+        QueryPerformanceCounter(&stamp);
+        QueryPerformanceFrequency(&freq);
+        *qpctime = (stamp.QuadPart * (INT64)10000000) / freq.QuadPart;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioClock_GetCharacteristics(IAudioClock *iface,
+        DWORD *chars)
+{
+    ACImpl *This = impl_from_IAudioClock(iface);
+
+    TRACE("(%p)->(%p)\n", This, chars);
+
+    if (!chars)
+        return E_POINTER;
+
+    *chars = AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ;
+
+    return S_OK;
+}
+
+static const IAudioClockVtbl AudioClock_Vtbl =
+{
+    AudioClock_QueryInterface,
+    AudioClock_AddRef,
+    AudioClock_Release,
+    AudioClock_GetFrequency,
+    AudioClock_GetPosition,
+    AudioClock_GetCharacteristics
+};
+
+static HRESULT WINAPI AudioClock2_QueryInterface(IAudioClock2 *iface,
+        REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClock_QueryInterface(&This->IAudioClock_iface, riid, ppv);
+}
+
+static ULONG WINAPI AudioClock2_AddRef(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioClock2_Release(IAudioClock2 *iface)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioClock2_GetDevicePosition(IAudioClock2 *iface,
+        UINT64 *pos, UINT64 *qpctime)
+{
+    ACImpl *This = impl_from_IAudioClock2(iface);
+    HRESULT hr = AudioClock_GetPosition(&This->IAudioClock_iface, pos, qpctime);
+    if (SUCCEEDED(hr) && This->share == AUDCLNT_SHAREMODE_SHARED)
+        *pos /= pa_frame_size(&This->ss);
+    return hr;
+}
+
+static const IAudioClock2Vtbl AudioClock2_Vtbl =
+{
+    AudioClock2_QueryInterface,
+    AudioClock2_AddRef,
+    AudioClock2_Release,
+    AudioClock2_GetDevicePosition
+};
+
+static HRESULT WINAPI AudioStreamVolume_QueryInterface(
+        IAudioStreamVolume *iface, REFIID riid, void **ppv)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IAudioStreamVolume))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    if (IsEqualIID(riid, &IID_IMarshal))
+        return IUnknown_QueryInterface(This->marshal, riid, ppv);
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioStreamVolume_AddRef(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient_AddRef(&This->IAudioClient_iface);
+}
+
+static ULONG WINAPI AudioStreamVolume_Release(IAudioStreamVolume *iface)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    return IAudioClient_Release(&This->IAudioClient_iface);
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelCount(
+        IAudioStreamVolume *iface, UINT32 *out)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+
+    TRACE("(%p)->(%p)\n", This, out);
+
+    if (!out)
+        return E_POINTER;
+
+    *out = This->ss.channels;
+
+    return S_OK;
+}
+
+struct pulse_info_cb_data {
+    UINT32 n;
+    float *levels;
+};
+
+static HRESULT WINAPI AudioStreamVolume_SetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, const float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    HRESULT hr;
+    int i;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if (!levels)
+        return E_POINTER;
+
+    if (count != This->ss.channels)
+        return E_INVALIDARG;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr))
+        goto out;
+
+    for (i = 0; i < count; ++i)
+        This->vol[i] = levels[i];
+
+out:
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetAllVolumes(
+        IAudioStreamVolume *iface, UINT32 count, float *levels)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    HRESULT hr;
+    int i;
+
+    TRACE("(%p)->(%d, %p)\n", This, count, levels);
+
+    if (!levels)
+        return E_POINTER;
+
+    if (count != This->ss.channels)
+        return E_INVALIDARG;
+
+    pthread_mutex_lock(&pulse_lock);
+    hr = pulse_stream_valid(This);
+    if (FAILED(hr))
+        goto out;
+
+    for (i = 0; i < count; ++i)
+        levels[i] = This->vol[i];
+
+out:
+    pthread_mutex_unlock(&pulse_lock);
+    return hr;
+}
+
+static HRESULT WINAPI AudioStreamVolume_SetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    HRESULT hr;
+    float volumes[PA_CHANNELS_MAX];
+
+    TRACE("(%p)->(%d, %f)\n", This, index, level);
+
+    if (level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if (index >= This->ss.channels)
+        return E_INVALIDARG;
+
+    hr = AudioStreamVolume_GetAllVolumes(iface, This->ss.channels, volumes);
+    volumes[index] = level;
+    if (SUCCEEDED(hr))
+        hr = AudioStreamVolume_SetAllVolumes(iface, This->ss.channels, volumes);
+    return hr;
+}
+
+static HRESULT WINAPI AudioStreamVolume_GetChannelVolume(
+        IAudioStreamVolume *iface, UINT32 index, float *level)
+{
+    ACImpl *This = impl_from_IAudioStreamVolume(iface);
+    float volumes[PA_CHANNELS_MAX];
+    HRESULT hr;
+
+    TRACE("(%p)->(%d, %p)\n", This, index, level);
+
+    if (!level)
+        return E_POINTER;
+
+    if (index >= This->ss.channels)
+        return E_INVALIDARG;
+
+    hr = AudioStreamVolume_GetAllVolumes(iface, This->ss.channels, volumes);
+    if (SUCCEEDED(hr))
+        *level = volumes[index];
+    return hr;
+}
+
+static const IAudioStreamVolumeVtbl AudioStreamVolume_Vtbl =
+{
+    AudioStreamVolume_QueryInterface,
+    AudioStreamVolume_AddRef,
+    AudioStreamVolume_Release,
+    AudioStreamVolume_GetChannelCount,
+    AudioStreamVolume_SetChannelVolume,
+    AudioStreamVolume_GetChannelVolume,
+    AudioStreamVolume_SetAllVolumes,
+    AudioStreamVolume_GetAllVolumes
+};
+
+static AudioSessionWrapper *AudioSessionWrapper_Create(ACImpl *client)
+{
+    AudioSessionWrapper *ret;
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(AudioSessionWrapper));
+    if (!ret)
+        return NULL;
+
+    ret->IAudioSessionControl2_iface.lpVtbl = &AudioSessionControl2_Vtbl;
+    ret->ISimpleAudioVolume_iface.lpVtbl = &SimpleAudioVolume_Vtbl;
+    ret->IChannelAudioVolume_iface.lpVtbl = &ChannelAudioVolume_Vtbl;
+
+    ret->ref = !client;
+
+    ret->client = client;
+    if (client) {
+        ret->session = client->session;
+        AudioClient_AddRef(&client->IAudioClient_iface);
+    }
+
+    return ret;
+}
+
+static HRESULT WINAPI AudioSessionControl_QueryInterface(
+        IAudioSessionControl2 *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IAudioSessionControl) ||
+        IsEqualIID(riid, &IID_IAudioSessionControl2))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI AudioSessionControl_AddRef(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionControl_Release(IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    if (!ref) {
+        if (This->client) {
+            This->client->session_wrapper = NULL;
+            AudioClient_Release(&This->client->IAudioClient_iface);
+        }
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetState(IAudioSessionControl2 *iface,
+        AudioSessionState *state)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+    ACImpl *client;
+
+    TRACE("(%p)->(%p)\n", This, state);
+
+    if (!state)
+        return NULL_PTR_ERR;
+
+    pthread_mutex_lock(&pulse_lock);
+    if (list_empty(&This->session->clients)) {
+        *state = AudioSessionStateExpired;
+        goto out;
+    }
+    LIST_FOR_EACH_ENTRY(client, &This->session->clients, ACImpl, entry) {
+        if (client->started) {
+            *state = AudioSessionStateActive;
+            goto out;
+        }
+    }
+    *state = AudioSessionStateInactive;
+
+out:
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetDisplayName(
+        IAudioSessionControl2 *iface, WCHAR **name)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, name);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDisplayName(
+        IAudioSessionControl2 *iface, const WCHAR *name, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, name, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetIconPath(
+        IAudioSessionControl2 *iface, WCHAR **path)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, path);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetIconPath(
+        IAudioSessionControl2 *iface, const WCHAR *path, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p, %s) - stub\n", This, path, debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetGroupingParam(
+        IAudioSessionControl2 *iface, GUID *group)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, group);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetGroupingParam(
+        IAudioSessionControl2 *iface, const GUID *group, const GUID *session)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%s, %s) - stub\n", This, debugstr_guid(group),
+            debugstr_guid(session));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_RegisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_UnregisterAudioSessionNotification(
+        IAudioSessionControl2 *iface, IAudioSessionEvents *events)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, events);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetSessionInstanceIdentifier(
+        IAudioSessionControl2 *iface, WCHAR **id)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    FIXME("(%p)->(%p) - stub\n", This, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionControl_GetProcessId(
+        IAudioSessionControl2 *iface, DWORD *pid)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%p)\n", This, pid);
+
+    if (!pid)
+        return E_POINTER;
+
+    *pid = GetCurrentProcessId();
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionControl_IsSystemSoundsSession(
+        IAudioSessionControl2 *iface)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)\n", This);
+
+    return S_FALSE;
+}
+
+static HRESULT WINAPI AudioSessionControl_SetDuckingPreference(
+        IAudioSessionControl2 *iface, BOOL optout)
+{
+    AudioSessionWrapper *This = impl_from_IAudioSessionControl2(iface);
+
+    TRACE("(%p)->(%d)\n", This, optout);
+
+    return S_OK;
+}
+
+static const IAudioSessionControl2Vtbl AudioSessionControl2_Vtbl =
+{
+    AudioSessionControl_QueryInterface,
+    AudioSessionControl_AddRef,
+    AudioSessionControl_Release,
+    AudioSessionControl_GetState,
+    AudioSessionControl_GetDisplayName,
+    AudioSessionControl_SetDisplayName,
+    AudioSessionControl_GetIconPath,
+    AudioSessionControl_SetIconPath,
+    AudioSessionControl_GetGroupingParam,
+    AudioSessionControl_SetGroupingParam,
+    AudioSessionControl_RegisterAudioSessionNotification,
+    AudioSessionControl_UnregisterAudioSessionNotification,
+    AudioSessionControl_GetSessionIdentifier,
+    AudioSessionControl_GetSessionInstanceIdentifier,
+    AudioSessionControl_GetProcessId,
+    AudioSessionControl_IsSystemSoundsSession,
+    AudioSessionControl_SetDuckingPreference
+};
+
+typedef struct _SessionMgr {
+    IAudioSessionManager2 IAudioSessionManager2_iface;
+
+    LONG ref;
+
+    IMMDevice *device;
+} SessionMgr;
+
+static HRESULT WINAPI AudioSessionManager_QueryInterface(IAudioSessionManager2 *iface,
+        REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IAudioSessionManager) ||
+        IsEqualIID(riid, &IID_IAudioSessionManager2))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static inline SessionMgr *impl_from_IAudioSessionManager2(IAudioSessionManager2 *iface)
+{
+    return CONTAINING_RECORD(iface, SessionMgr, IAudioSessionManager2_iface);
+}
+
+static ULONG WINAPI AudioSessionManager_AddRef(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI AudioSessionManager_Release(IAudioSessionManager2 *iface)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    ULONG ref;
+    ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) Refcount now %u\n", This, ref);
+    if (!ref)
+        HeapFree(GetProcessHeap(), 0, This);
+    return ref;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetAudioSessionControl(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        IAudioSessionControl **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %x, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if (FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if (!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = (IAudioSessionControl*)&wrapper->IAudioSessionControl2_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSimpleAudioVolume(
+        IAudioSessionManager2 *iface, const GUID *session_guid, DWORD flags,
+        ISimpleAudioVolume **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    AudioSession *session;
+    AudioSessionWrapper *wrapper;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %x, %p)\n", This, debugstr_guid(session_guid),
+            flags, out);
+
+    hr = get_audio_session(session_guid, This->device, 0, &session);
+    if (FAILED(hr))
+        return hr;
+
+    wrapper = AudioSessionWrapper_Create(NULL);
+    if (!wrapper)
+        return E_OUTOFMEMORY;
+
+    wrapper->session = session;
+
+    *out = &wrapper->ISimpleAudioVolume_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI AudioSessionManager_GetSessionEnumerator(
+        IAudioSessionManager2 *iface, IAudioSessionEnumerator **out)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, out);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterSessionNotification(
+        IAudioSessionManager2 *iface, IAudioSessionNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_RegisterDuckNotification(
+        IAudioSessionManager2 *iface, const WCHAR *session_id,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI AudioSessionManager_UnregisterDuckNotification(
+        IAudioSessionManager2 *iface,
+        IAudioVolumeDuckNotification *notification)
+{
+    SessionMgr *This = impl_from_IAudioSessionManager2(iface);
+    FIXME("(%p)->(%p) - stub\n", This, notification);
+    return E_NOTIMPL;
+}
+
+static const IAudioSessionManager2Vtbl AudioSessionManager2_Vtbl =
+{
+    AudioSessionManager_QueryInterface,
+    AudioSessionManager_AddRef,
+    AudioSessionManager_Release,
+    AudioSessionManager_GetAudioSessionControl,
+    AudioSessionManager_GetSimpleAudioVolume,
+    AudioSessionManager_GetSessionEnumerator,
+    AudioSessionManager_RegisterSessionNotification,
+    AudioSessionManager_UnregisterSessionNotification,
+    AudioSessionManager_RegisterDuckNotification,
+    AudioSessionManager_UnregisterDuckNotification
+};
+
+static HRESULT WINAPI SimpleAudioVolume_QueryInterface(
+        ISimpleAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_ISimpleAudioVolume))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI SimpleAudioVolume_AddRef(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI SimpleAudioVolume_Release(ISimpleAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMasterVolume(
+        ISimpleAudioVolume *iface, float level, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%f, %s)\n", session, level, wine_dbgstr_guid(context));
+
+    if (level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if (context)
+        FIXME("Notifications not supported yet\n");
+
+    TRACE("PulseAudio does not support session volume control\n");
+
+    pthread_mutex_lock(&pulse_lock);
+    session->master_vol = level;
+    pthread_mutex_unlock(&pulse_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMasterVolume(
+        ISimpleAudioVolume *iface, float *level)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, level);
+
+    if (!level)
+        return NULL_PTR_ERR;
+
+    *level = session->master_vol;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_SetMute(ISimpleAudioVolume *iface,
+        BOOL mute, const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%u, %s)\n", session, mute, debugstr_guid(context));
+
+    if (context)
+        FIXME("Notifications not supported yet\n");
+
+    session->mute = mute;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SimpleAudioVolume_GetMute(ISimpleAudioVolume *iface,
+        BOOL *mute)
+{
+    AudioSessionWrapper *This = impl_from_ISimpleAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, mute);
+
+    if (!mute)
+        return NULL_PTR_ERR;
+
+    *mute = session->mute;
+
+    return S_OK;
+}
+
+static const ISimpleAudioVolumeVtbl SimpleAudioVolume_Vtbl  =
+{
+    SimpleAudioVolume_QueryInterface,
+    SimpleAudioVolume_AddRef,
+    SimpleAudioVolume_Release,
+    SimpleAudioVolume_SetMasterVolume,
+    SimpleAudioVolume_GetMasterVolume,
+    SimpleAudioVolume_SetMute,
+    SimpleAudioVolume_GetMute
+};
+
+static HRESULT WINAPI ChannelAudioVolume_QueryInterface(
+        IChannelAudioVolume *iface, REFIID riid, void **ppv)
+{
+    TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IChannelAudioVolume))
+        *ppv = iface;
+    if (*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("Unknown interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI ChannelAudioVolume_AddRef(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_AddRef(&This->IAudioSessionControl2_iface);
+}
+
+static ULONG WINAPI ChannelAudioVolume_Release(IChannelAudioVolume *iface)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    return AudioSessionControl_Release(&This->IAudioSessionControl2_iface);
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelCount(
+        IChannelAudioVolume *iface, UINT32 *out)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%p)\n", session, out);
+
+    if (!out)
+        return NULL_PTR_ERR;
+
+    *out = session->channel_count;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float level,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%d, %f, %s)\n", session, index, level,
+            wine_dbgstr_guid(context));
+
+    if (level < 0.f || level > 1.f)
+        return E_INVALIDARG;
+
+    if (index >= session->channel_count)
+        return E_INVALIDARG;
+
+    if (context)
+        FIXME("Notifications not supported yet\n");
+
+    TRACE("PulseAudio does not support session volume control\n");
+
+    pthread_mutex_lock(&pulse_lock);
+    session->channel_vols[index] = level;
+    pthread_mutex_unlock(&pulse_lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetChannelVolume(
+        IChannelAudioVolume *iface, UINT32 index, float *level)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+
+    TRACE("(%p)->(%d, %p)\n", session, index, level);
+
+    if (!level)
+        return NULL_PTR_ERR;
+
+    if (index >= session->channel_count)
+        return E_INVALIDARG;
+
+    *level = session->channel_vols[index];
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_SetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, const float *levels,
+        const GUID *context)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    int i;
+
+    TRACE("(%p)->(%d, %p, %s)\n", session, count, levels,
+            wine_dbgstr_guid(context));
+
+    if (!levels)
+        return NULL_PTR_ERR;
+
+    if (count != session->channel_count)
+        return E_INVALIDARG;
+
+    if (context)
+        FIXME("Notifications not supported yet\n");
+
+    TRACE("PulseAudio does not support session volume control\n");
+
+    pthread_mutex_lock(&pulse_lock);
+    for(i = 0; i < count; ++i)
+        session->channel_vols[i] = levels[i];
+    pthread_mutex_unlock(&pulse_lock);
+    return S_OK;
+}
+
+static HRESULT WINAPI ChannelAudioVolume_GetAllVolumes(
+        IChannelAudioVolume *iface, UINT32 count, float *levels)
+{
+    AudioSessionWrapper *This = impl_from_IChannelAudioVolume(iface);
+    AudioSession *session = This->session;
+    int i;
+
+    TRACE("(%p)->(%d, %p)\n", session, count, levels);
+
+    if (!levels)
+        return NULL_PTR_ERR;
+
+    if (count != session->channel_count)
+        return E_INVALIDARG;
+
+    for(i = 0; i < count; ++i)
+        levels[i] = session->channel_vols[i];
+
+    return S_OK;
+}
+
+static const IChannelAudioVolumeVtbl ChannelAudioVolume_Vtbl =
+{
+    ChannelAudioVolume_QueryInterface,
+    ChannelAudioVolume_AddRef,
+    ChannelAudioVolume_Release,
+    ChannelAudioVolume_GetChannelCount,
+    ChannelAudioVolume_SetChannelVolume,
+    ChannelAudioVolume_GetChannelVolume,
+    ChannelAudioVolume_SetAllVolumes,
+    ChannelAudioVolume_GetAllVolumes
+};
+
+HRESULT WINAPI AUDDRV_GetAudioSessionManager(IMMDevice *device,
+        IAudioSessionManager2 **out)
+{
+    SessionMgr *This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(SessionMgr));
+    *out = NULL;
+    if (!This)
+        return E_OUTOFMEMORY;
+    This->IAudioSessionManager2_iface.lpVtbl = &AudioSessionManager2_Vtbl;
+    This->device = device;
+    This->ref = 1;
+    *out = &This->IAudioSessionManager2_iface;
+    return S_OK;
+}
+
+HRESULT WINAPI AUDDRV_GetPropValue(GUID *guid, const PROPERTYKEY *prop, PROPVARIANT *out)
+{
+    TRACE("%s, (%s,%u), %p\n", wine_dbgstr_guid(guid), wine_dbgstr_guid(&prop->fmtid), prop->pid, out);
+
+    if (IsEqualGUID(guid, &pulse_render_guid) && IsEqualPropertyKey(*prop, PKEY_AudioEndpoint_PhysicalSpeakers)) {
+        out->vt = VT_UI4;
+        out->ulVal = g_phys_speakers_mask;
+
+        return out->ulVal ? S_OK : E_FAIL;
+    }
+
+    return E_NOTIMPL;
+}
+
+
 
 /**********************************************************************
  * A-law and u-law sample manipulation functions
diff --git a/dlls/winepulse.drv/pulse.c b/dlls/winepulse.drv/pulse.c
deleted file mode 100644
index bf0451e..0000000
--- a/dlls/winepulse.drv/pulse.c
+++ /dev/null
@@ -1,3064 +0,0 @@
-/*
- * Copyright 2011-2012 Maarten Lankhorst
- * Copyright 2010-2011 Maarten Lankhorst for CodeWeavers
- * Copyright 2011 Andrew Eikum for CodeWeavers
- * Copyright 2022 Huw Davies
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#include <stdarg.h>
-#include <pthread.h>
-#include <math.h>
-#include <poll.h>
-
-#include <pulse/pulseaudio.h>
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "winternl.h"
-
-#include "mmdeviceapi.h"
-#include "initguid.h"
-#include "audioclient.h"
-
-#include "wine/debug.h"
-#include "wine/list.h"
-#include "wine/unixlib.h"
-
-#include "../mmdevapi/unixlib.h"
-
-#include "mult.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(pulse);
-
-enum phys_device_bus_type {
-    phys_device_bus_invalid = -1,
-    phys_device_bus_pci,
-    phys_device_bus_usb
-};
-
-struct pulse_stream
-{
-    EDataFlow dataflow;
-
-    pa_stream *stream;
-    pa_sample_spec ss;
-    pa_channel_map map;
-    pa_buffer_attr attr;
-
-    DWORD flags;
-    AUDCLNT_SHAREMODE share;
-    HANDLE event;
-    float vol[PA_CHANNELS_MAX];
-
-    REFERENCE_TIME def_period;
-
-    INT32 locked;
-    BOOL started;
-    SIZE_T bufsize_frames, real_bufsize_bytes, period_bytes;
-    SIZE_T peek_ofs, read_offs_bytes, lcl_offs_bytes, pa_offs_bytes;
-    SIZE_T tmp_buffer_bytes, held_bytes, peek_len, peek_buffer_len, pa_held_bytes;
-    BYTE *local_buffer, *tmp_buffer, *peek_buffer;
-    void *locked_ptr;
-    BOOL please_quit, just_started, just_underran;
-    pa_usec_t mmdev_period_usec;
-
-    INT64 clock_lastpos, clock_written;
-
-    struct list packet_free_head;
-    struct list packet_filled_head;
-};
-
-typedef struct _ACPacket
-{
-    struct list entry;
-    UINT64 qpcpos;
-    BYTE *data;
-    UINT32 discont;
-} ACPacket;
-
-typedef struct _PhysDevice {
-    struct list entry;
-    WCHAR *name;
-    enum phys_device_bus_type bus_type;
-    USHORT vendor_id, product_id;
-    EndpointFormFactor form;
-    UINT channel_mask;
-    UINT index;
-    REFERENCE_TIME min_period, def_period;
-    WAVEFORMATEXTENSIBLE fmt;
-    char pulse_name[0];
-} PhysDevice;
-
-static pa_context *pulse_ctx;
-static pa_mainloop *pulse_ml;
-
-static struct list g_phys_speakers = LIST_INIT(g_phys_speakers);
-static struct list g_phys_sources = LIST_INIT(g_phys_sources);
-
-static const REFERENCE_TIME MinimumPeriod = 30000;
-static const REFERENCE_TIME DefaultPeriod = 100000;
-
-static pthread_mutex_t pulse_mutex;
-static pthread_cond_t pulse_cond = PTHREAD_COND_INITIALIZER;
-
-static ULONG_PTR zero_bits = 0;
-
-static NTSTATUS pulse_not_implemented(void *args)
-{
-    return STATUS_SUCCESS;
-}
-
-static void pulse_lock(void)
-{
-    pthread_mutex_lock(&pulse_mutex);
-}
-
-static void pulse_unlock(void)
-{
-    pthread_mutex_unlock(&pulse_mutex);
-}
-
-static int pulse_cond_wait(void)
-{
-    return pthread_cond_wait(&pulse_cond, &pulse_mutex);
-}
-
-static void pulse_broadcast(void)
-{
-    pthread_cond_broadcast(&pulse_cond);
-}
-
-static struct pulse_stream *handle_get_stream(stream_handle h)
-{
-    return (struct pulse_stream *)(UINT_PTR)h;
-}
-
-static void dump_attr(const pa_buffer_attr *attr)
-{
-    TRACE("maxlength: %u\n", attr->maxlength);
-    TRACE("minreq: %u\n", attr->minreq);
-    TRACE("fragsize: %u\n", attr->fragsize);
-    TRACE("tlength: %u\n", attr->tlength);
-    TRACE("prebuf: %u\n", attr->prebuf);
-}
-
-static void free_phys_device_lists(void)
-{
-    static struct list *const lists[] = { &g_phys_speakers, &g_phys_sources, NULL };
-    struct list *const *list = lists;
-    PhysDevice *dev, *dev_next;
-
-    do {
-        LIST_FOR_EACH_ENTRY_SAFE(dev, dev_next, *list, PhysDevice, entry) {
-            free(dev->name);
-            free(dev);
-        }
-    } while (*(++list));
-}
-
-/* copied from kernelbase */
-static int muldiv(int a, int b, int c)
-{
-    LONGLONG ret;
-
-    if (!c) return -1;
-
-    /* We want to deal with a positive divisor to simplify the logic. */
-    if (c < 0)
-    {
-        a = -a;
-        c = -c;
-    }
-
-    /* If the result is positive, we "add" to round. else, we subtract to round. */
-    if ((a < 0 && b < 0) || (a >= 0 && b >= 0))
-        ret = (((LONGLONG)a * b) + (c / 2)) / c;
-    else
-        ret = (((LONGLONG)a * b) - (c / 2)) / c;
-
-    if (ret > 2147483647 || ret < -2147483647) return -1;
-    return ret;
-}
-
-static char *wstr_to_str(const WCHAR *wstr)
-{
-    const int len = wcslen(wstr);
-    char *str = malloc(len * 3 + 1);
-    ntdll_wcstoumbs(wstr, len + 1, str, len * 3 + 1, FALSE);
-    return str;
-}
-
-/* Following pulseaudio design here, mainloop has the lock taken whenever
- * it is handling something for pulse, and the lock is required whenever
- * doing any pa_* call that can affect the state in any way
- *
- * pa_cond_wait is used when waiting on results, because the mainloop needs
- * the same lock taken to affect the state
- *
- * This is basically the same as the pa_threaded_mainloop implementation,
- * but that cannot be used because it uses pthread_create directly
- *
- * pa_threaded_mainloop_(un)lock -> pthread_mutex_(un)lock
- * pa_threaded_mainloop_signal -> pthread_cond_broadcast
- * pa_threaded_mainloop_wait -> pthread_cond_wait
- */
-static int pulse_poll_func(struct pollfd *ufds, unsigned long nfds, int timeout, void *userdata)
-{
-    int r;
-    pulse_unlock();
-    r = poll(ufds, nfds, timeout);
-    pulse_lock();
-    return r;
-}
-
-static NTSTATUS pulse_process_attach(void *args)
-{
-    pthread_mutexattr_t attr;
-
-    pthread_mutexattr_init(&attr);
-    pthread_mutexattr_setprotocol(&attr, PTHREAD_PRIO_INHERIT);
-
-    if (pthread_mutex_init(&pulse_mutex, &attr) != 0)
-        pthread_mutex_init(&pulse_mutex, NULL);
-
-#ifdef _WIN64
-    if (NtCurrentTeb()->WowTebOffset)
-    {
-        SYSTEM_BASIC_INFORMATION info;
-
-        NtQuerySystemInformation(SystemEmulationBasicInformation, &info, sizeof(info), NULL);
-        zero_bits = (ULONG_PTR)info.HighestUserAddress | 0x7fffffff;
-    }
-#endif
-
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_process_detach(void *args)
-{
-    free_phys_device_lists();
-    if (pulse_ctx)
-    {
-        pa_context_disconnect(pulse_ctx);
-        pa_context_unref(pulse_ctx);
-    }
-    if (pulse_ml)
-        pa_mainloop_quit(pulse_ml, 0);
-
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_main_loop(void *args)
-{
-    struct main_loop_params *params = args;
-    int ret;
-    pulse_lock();
-    pulse_ml = pa_mainloop_new();
-    pa_mainloop_set_poll_func(pulse_ml, pulse_poll_func, NULL);
-    NtSetEvent(params->event, NULL);
-    pa_mainloop_run(pulse_ml, &ret);
-    pa_mainloop_free(pulse_ml);
-    pulse_unlock();
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_get_endpoint_ids(void *args)
-{
-    struct get_endpoint_ids_params *params = args;
-    struct list *list = (params->flow == eRender) ? &g_phys_speakers : &g_phys_sources;
-    struct endpoint *endpoint = params->endpoints;
-    size_t len, name_len, needed;
-    unsigned int offset;
-    PhysDevice *dev;
-
-    params->num = list_count(list);
-    offset = needed = params->num * sizeof(*params->endpoints);
-
-    LIST_FOR_EACH_ENTRY(dev, list, PhysDevice, entry) {
-        name_len = lstrlenW(dev->name) + 1;
-        len = strlen(dev->pulse_name) + 1;
-        needed += name_len * sizeof(WCHAR) + ((len + 1) & ~1);
-
-        if (needed <= params->size) {
-            endpoint->name = offset;
-            memcpy((char *)params->endpoints + offset, dev->name, name_len * sizeof(WCHAR));
-            offset += name_len * sizeof(WCHAR);
-            endpoint->device = offset;
-            memcpy((char *)params->endpoints + offset, dev->pulse_name, len);
-            offset += (len + 1) & ~1;
-            endpoint++;
-        }
-    }
-    params->default_idx = 0;
-
-    if (needed > params->size) {
-        params->size = needed;
-        params->result = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
-    } else
-        params->result = S_OK;
-    return STATUS_SUCCESS;
-}
-
-static void pulse_contextcallback(pa_context *c, void *userdata)
-{
-    switch (pa_context_get_state(c)) {
-        default:
-            FIXME("Unhandled state: %i\n", pa_context_get_state(c));
-            return;
-
-        case PA_CONTEXT_CONNECTING:
-        case PA_CONTEXT_UNCONNECTED:
-        case PA_CONTEXT_AUTHORIZING:
-        case PA_CONTEXT_SETTING_NAME:
-        case PA_CONTEXT_TERMINATED:
-            TRACE("State change to %i\n", pa_context_get_state(c));
-            return;
-
-        case PA_CONTEXT_READY:
-            TRACE("Ready\n");
-            break;
-
-        case PA_CONTEXT_FAILED:
-            WARN("Context failed: %s\n", pa_strerror(pa_context_errno(c)));
-            break;
-    }
-    pulse_broadcast();
-}
-
-static void pulse_stream_state(pa_stream *s, void *user)
-{
-    pa_stream_state_t state = pa_stream_get_state(s);
-    TRACE("Stream state changed to %i\n", state);
-    pulse_broadcast();
-}
-
-static void pulse_attr_update(pa_stream *s, void *user) {
-    const pa_buffer_attr *attr = pa_stream_get_buffer_attr(s);
-    TRACE("New attributes or device moved:\n");
-    dump_attr(attr);
-}
-
-static void pulse_underflow_callback(pa_stream *s, void *userdata)
-{
-    struct pulse_stream *stream = userdata;
-    WARN("%p: Underflow\n", userdata);
-    stream->just_underran = TRUE;
-}
-
-static void pulse_started_callback(pa_stream *s, void *userdata)
-{
-    TRACE("%p: (Re)started playing\n", userdata);
-}
-
-static void silence_buffer(pa_sample_format_t format, BYTE *buffer, UINT32 bytes)
-{
-    memset(buffer, format == PA_SAMPLE_U8 ? 0x80 : 0, bytes);
-}
-
-static int write_buffer(const struct pulse_stream *stream, BYTE *buffer, UINT32 bytes)
-{
-    const float *vol = stream->vol;
-    UINT32 i, channels, mute = 0;
-    BOOL adjust = FALSE;
-    BYTE *end;
-
-    if (!bytes) return 0;
-
-    /* Adjust the buffer based on the volume for each channel */
-    channels = stream->ss.channels;
-    for (i = 0; i < channels; i++)
-    {
-        adjust |= vol[i] != 1.0f;
-        if (vol[i] == 0.0f)
-            mute++;
-    }
-    if (mute == channels)
-    {
-        silence_buffer(stream->ss.format, buffer, bytes);
-        goto write;
-    }
-    if (!adjust) goto write;
-
-    end = buffer + bytes;
-    switch (stream->ss.format)
-    {
-#ifndef WORDS_BIGENDIAN
-#define PROCESS_BUFFER(type) do         \
-{                                       \
-    type *p = (type*)buffer;            \
-    do                                  \
-    {                                   \
-        for (i = 0; i < channels; i++)  \
-            p[i] = p[i] * vol[i];       \
-        p += i;                         \
-    } while ((BYTE*)p != end);          \
-} while (0)
-    case PA_SAMPLE_S16LE:
-        PROCESS_BUFFER(INT16);
-        break;
-    case PA_SAMPLE_S32LE:
-        PROCESS_BUFFER(INT32);
-        break;
-    case PA_SAMPLE_FLOAT32LE:
-        PROCESS_BUFFER(float);
-        break;
-#undef PROCESS_BUFFER
-    case PA_SAMPLE_S24_32LE:
-    {
-        UINT32 *p = (UINT32*)buffer;
-        do
-        {
-            for (i = 0; i < channels; i++)
-            {
-                p[i] = (INT32)((INT32)(p[i] << 8) * vol[i]);
-                p[i] >>= 8;
-            }
-            p += i;
-        } while ((BYTE*)p != end);
-        break;
-    }
-    case PA_SAMPLE_S24LE:
-    {
-        /* do it 12 bytes at a time until it is no longer possible */
-        UINT32 *q = (UINT32*)buffer;
-        BYTE *p;
-
-        i = 0;
-        while (end - (BYTE*)q >= 12)
-        {
-            UINT32 v[4], k;
-            v[0] = q[0] << 8;
-            v[1] = q[1] << 16 | (q[0] >> 16 & ~0xff);
-            v[2] = q[2] << 24 | (q[1] >> 8  & ~0xff);
-            v[3] = q[2] & ~0xff;
-            for (k = 0; k < 4; k++)
-            {
-                v[k] = (INT32)((INT32)v[k] * vol[i]);
-                if (++i == channels) i = 0;
-            }
-            *q++ = v[0] >> 8  | (v[1] & ~0xff) << 16;
-            *q++ = v[1] >> 16 | (v[2] & ~0xff) << 8;
-            *q++ = v[2] >> 24 | (v[3] & ~0xff);
-        }
-        p = (BYTE*)q;
-        while (p != end)
-        {
-            UINT32 v = (INT32)((INT32)(p[0] << 8 | p[1] << 16 | p[2] << 24) * vol[i]);
-            *p++ = v >> 8  & 0xff;
-            *p++ = v >> 16 & 0xff;
-            *p++ = v >> 24;
-            if (++i == channels) i = 0;
-        }
-        break;
-    }
-#endif
-    case PA_SAMPLE_U8:
-    {
-        UINT8 *p = (UINT8*)buffer;
-        do
-        {
-            for (i = 0; i < channels; i++)
-                p[i] = (int)((p[i] - 128) * vol[i]) + 128;
-            p += i;
-        } while ((BYTE*)p != end);
-        break;
-    }
-    case PA_SAMPLE_ALAW:
-    {
-        UINT8 *p = (UINT8*)buffer;
-        do
-        {
-            for (i = 0; i < channels; i++)
-                p[i] = mult_alaw_sample(p[i], vol[i]);
-            p += i;
-        } while ((BYTE*)p != end);
-        break;
-    }
-    case PA_SAMPLE_ULAW:
-    {
-        UINT8 *p = (UINT8*)buffer;
-        do
-        {
-            for (i = 0; i < channels; i++)
-                p[i] = mult_ulaw_sample(p[i], vol[i]);
-            p += i;
-        } while ((BYTE*)p != end);
-        break;
-    }
-    default:
-        TRACE("Unhandled format %i, not adjusting volume.\n", stream->ss.format);
-        break;
-    }
-
-write:
-    return pa_stream_write(stream->stream, buffer, bytes, NULL, 0, PA_SEEK_RELATIVE);
-}
-
-static void pulse_write_callback(pa_stream *s, size_t bytes, void *userdata)
-{
-    /* write as much data to PA as we can */
-    struct pulse_stream *stream = userdata;
-    UINT32 to_write;
-    BYTE *buf = stream->local_buffer + stream->pa_offs_bytes;
-
-    if (stream->just_underran)
-    {
-        /* prebuffer with silence if needed */
-        if(stream->pa_held_bytes < bytes){
-            to_write = bytes - stream->pa_held_bytes;
-            TRACE("prebuffering %u frames of silence\n",
-                    (int)(to_write / pa_frame_size(&stream->ss)));
-            buf = calloc(1, to_write);
-            pa_stream_write(stream->stream, buf, to_write, NULL, 0, PA_SEEK_RELATIVE);
-            free(buf);
-        }
-
-        stream->just_underran = FALSE;
-    }
-
-    buf = stream->local_buffer + stream->pa_offs_bytes;
-    TRACE("held: %lu, avail: %u\n", stream->pa_held_bytes, (UINT32)bytes);
-    bytes = min(stream->pa_held_bytes, bytes);
-
-    if (stream->pa_offs_bytes + bytes > stream->real_bufsize_bytes)
-    {
-        to_write = stream->real_bufsize_bytes - stream->pa_offs_bytes;
-        TRACE("writing small chunk of %u bytes\n", to_write);
-        write_buffer(stream, buf, to_write);
-        stream->pa_held_bytes -= to_write;
-        to_write = bytes - to_write;
-        stream->pa_offs_bytes = 0;
-        buf = stream->local_buffer;
-    }
-    else
-        to_write = bytes;
-
-    TRACE("writing main chunk of %u bytes\n", to_write);
-    write_buffer(stream, buf, to_write);
-    stream->pa_offs_bytes += to_write;
-    stream->pa_offs_bytes %= stream->real_bufsize_bytes;
-    stream->pa_held_bytes -= to_write;
-}
-
-static void pulse_op_cb(pa_stream *s, int success, void *user)
-{
-    TRACE("Success: %i\n", success);
-    *(int*)user = success;
-    pulse_broadcast();
-}
-
-static BOOL pulse_stream_valid(struct pulse_stream *stream)
-{
-    return pa_stream_get_state(stream->stream) == PA_STREAM_READY;
-}
-
-static HRESULT pulse_connect(const char *name)
-{
-    pa_context_state_t state;
-
-    if (pulse_ctx && PA_CONTEXT_IS_GOOD(pa_context_get_state(pulse_ctx)))
-        return S_OK;
-    if (pulse_ctx)
-        pa_context_unref(pulse_ctx);
-
-    pulse_ctx = pa_context_new(pa_mainloop_get_api(pulse_ml), name);
-    if (!pulse_ctx) {
-        ERR("Failed to create context\n");
-        return E_FAIL;
-    }
-
-    pa_context_set_state_callback(pulse_ctx, pulse_contextcallback, NULL);
-
-    TRACE("libpulse protocol version: %u. API Version %u\n", pa_context_get_protocol_version(pulse_ctx), PA_API_VERSION);
-    if (pa_context_connect(pulse_ctx, NULL, 0, NULL) < 0)
-        goto fail;
-
-    /* Wait for connection */
-    while ((state = pa_context_get_state(pulse_ctx)) != PA_CONTEXT_READY &&
-           state != PA_CONTEXT_FAILED && state != PA_CONTEXT_TERMINATED)
-        pulse_cond_wait();
-
-    if (state != PA_CONTEXT_READY)
-        goto fail;
-
-    TRACE("Connected to server %s with protocol version: %i.\n",
-        pa_context_get_server(pulse_ctx),
-        pa_context_get_server_protocol_version(pulse_ctx));
-    return S_OK;
-
-fail:
-    pa_context_unref(pulse_ctx);
-    pulse_ctx = NULL;
-    return E_FAIL;
-}
-
-static UINT pulse_channel_map_to_channel_mask(const pa_channel_map *map)
-{
-    int i;
-    UINT mask = 0;
-
-    for (i = 0; i < map->channels; ++i) {
-        switch (map->map[i]) {
-            default: FIXME("Unhandled channel %s\n", pa_channel_position_to_string(map->map[i])); break;
-            case PA_CHANNEL_POSITION_AUX0:
-            case PA_CHANNEL_POSITION_FRONT_LEFT: mask |= SPEAKER_FRONT_LEFT; break;
-            case PA_CHANNEL_POSITION_MONO:
-            case PA_CHANNEL_POSITION_FRONT_CENTER: mask |= SPEAKER_FRONT_CENTER; break;
-            case PA_CHANNEL_POSITION_AUX1:
-            case PA_CHANNEL_POSITION_FRONT_RIGHT: mask |= SPEAKER_FRONT_RIGHT; break;
-            case PA_CHANNEL_POSITION_REAR_LEFT: mask |= SPEAKER_BACK_LEFT; break;
-            case PA_CHANNEL_POSITION_REAR_CENTER: mask |= SPEAKER_BACK_CENTER; break;
-            case PA_CHANNEL_POSITION_REAR_RIGHT: mask |= SPEAKER_BACK_RIGHT; break;
-            case PA_CHANNEL_POSITION_LFE: mask |= SPEAKER_LOW_FREQUENCY; break;
-            case PA_CHANNEL_POSITION_SIDE_LEFT: mask |= SPEAKER_SIDE_LEFT; break;
-            case PA_CHANNEL_POSITION_SIDE_RIGHT: mask |= SPEAKER_SIDE_RIGHT; break;
-            case PA_CHANNEL_POSITION_TOP_CENTER: mask |= SPEAKER_TOP_CENTER; break;
-            case PA_CHANNEL_POSITION_TOP_FRONT_LEFT: mask |= SPEAKER_TOP_FRONT_LEFT; break;
-            case PA_CHANNEL_POSITION_TOP_FRONT_CENTER: mask |= SPEAKER_TOP_FRONT_CENTER; break;
-            case PA_CHANNEL_POSITION_TOP_FRONT_RIGHT: mask |= SPEAKER_TOP_FRONT_RIGHT; break;
-            case PA_CHANNEL_POSITION_TOP_REAR_LEFT: mask |= SPEAKER_TOP_BACK_LEFT; break;
-            case PA_CHANNEL_POSITION_TOP_REAR_CENTER: mask |= SPEAKER_TOP_BACK_CENTER; break;
-            case PA_CHANNEL_POSITION_TOP_REAR_RIGHT: mask |= SPEAKER_TOP_BACK_RIGHT; break;
-            case PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER: mask |= SPEAKER_FRONT_LEFT_OF_CENTER; break;
-            case PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER: mask |= SPEAKER_FRONT_RIGHT_OF_CENTER; break;
-        }
-    }
-
-    return mask;
-}
-
-#define MAX_DEVICE_NAME_LEN 62
-
-static WCHAR *get_device_name(const char *desc, pa_proplist *proplist)
-{
-    /*
-       Some broken apps (e.g. Split/Second with fmodex) can't handle names that
-       are too long and crash even on native. If the device desc is too long,
-       we'll attempt to incrementally build it to try to stay under the limit.
-       ( + 1 is to check against truncated buffer after ntdll_umbstowcs )
-    */
-    WCHAR buf[MAX_DEVICE_NAME_LEN + 1];
-
-    /* For monitors of sinks; this does not seem to be localized in PA either */
-    static const WCHAR monitor_of[] = {'M','o','n','i','t','o','r',' ','o','f',' '};
-
-    size_t len = strlen(desc);
-    WCHAR *name, *tmp;
-
-    if (!(name = malloc((len + 1) * sizeof(WCHAR))))
-        return NULL;
-    if (!(len = ntdll_umbstowcs(desc, len, name, len))) {
-        free(name);
-        return NULL;
-    }
-
-    if (len > MAX_DEVICE_NAME_LEN && proplist) {
-        const char *prop = pa_proplist_gets(proplist, PA_PROP_DEVICE_CLASS);
-        unsigned prop_len, rem = ARRAY_SIZE(buf);
-        BOOL monitor = FALSE;
-
-        if (prop && !strcmp(prop, "monitor")) {
-            rem -= ARRAY_SIZE(monitor_of);
-            monitor = TRUE;
-        }
-
-        prop = pa_proplist_gets(proplist, PA_PROP_DEVICE_PRODUCT_NAME);
-        if (!prop || !prop[0] ||
-            !(prop_len = ntdll_umbstowcs(prop, strlen(prop), buf, rem)) || prop_len == rem) {
-            prop = pa_proplist_gets(proplist, "alsa.card_name");
-            if (!prop || !prop[0] ||
-                !(prop_len = ntdll_umbstowcs(prop, strlen(prop), buf, rem)) || prop_len == rem)
-                prop = NULL;
-        }
-
-        if (prop) {
-            /* We know we have a name that fits within the limit now */
-            WCHAR *p = name;
-
-            if (monitor) {
-                memcpy(p, monitor_of, sizeof(monitor_of));
-                p += ARRAY_SIZE(monitor_of);
-            }
-            len = ntdll_umbstowcs(prop, strlen(prop), p, rem);
-            rem -= len;
-            p += len;
-
-            if (rem > 2) {
-                rem--;  /* space */
-
-                prop = pa_proplist_gets(proplist, PA_PROP_DEVICE_PROFILE_DESCRIPTION);
-                if (prop && prop[0] && (len = ntdll_umbstowcs(prop, strlen(prop), p + 1, rem)) && len != rem) {
-                    *p++ = ' ';
-                    p += len;
-                }
-            }
-            len = p - name;
-        }
-    }
-    name[len] = '\0';
-
-    if ((tmp = realloc(name, (len + 1) * sizeof(WCHAR))))
-        name = tmp;
-    return name;
-}
-
-static void fill_device_info(PhysDevice *dev, pa_proplist *p)
-{
-    const char *buffer;
-
-    dev->bus_type = phys_device_bus_invalid;
-    dev->vendor_id = 0;
-    dev->product_id = 0;
-
-    if (!p)
-        return;
-
-    if ((buffer = pa_proplist_gets(p, PA_PROP_DEVICE_BUS))) {
-        if (!strcmp(buffer, "usb"))
-            dev->bus_type = phys_device_bus_usb;
-        else if (!strcmp(buffer, "pci"))
-            dev->bus_type = phys_device_bus_pci;
-    }
-
-    if ((buffer = pa_proplist_gets(p, PA_PROP_DEVICE_VENDOR_ID)))
-        dev->vendor_id = strtol(buffer, NULL, 16);
-
-    if ((buffer = pa_proplist_gets(p, PA_PROP_DEVICE_PRODUCT_ID)))
-        dev->product_id = strtol(buffer, NULL, 16);
-}
-
-static void pulse_add_device(struct list *list, pa_proplist *proplist, int index, EndpointFormFactor form,
-                             UINT channel_mask, const char *pulse_name, const char *desc)
-{
-    size_t len = strlen(pulse_name);
-    PhysDevice *dev = malloc(FIELD_OFFSET(PhysDevice, pulse_name[len + 1]));
-
-    if (!dev)
-        return;
-
-    if (!(dev->name = get_device_name(desc, proplist))) {
-        free(dev);
-        return;
-    }
-    dev->form = form;
-    dev->index = index;
-    dev->channel_mask = channel_mask;
-    dev->def_period = 0;
-    dev->min_period = 0;
-    fill_device_info(dev, proplist);
-    memcpy(dev->pulse_name, pulse_name, len + 1);
-
-    list_add_tail(list, &dev->entry);
-
-    TRACE("%s\n", debugstr_w(dev->name));
-}
-
-static void pulse_phys_speakers_cb(pa_context *c, const pa_sink_info *i, int eol, void *userdata)
-{
-    struct list *speaker;
-    UINT channel_mask;
-
-    if (!i || !i->name || !i->name[0])
-        return;
-    channel_mask = pulse_channel_map_to_channel_mask(&i->channel_map);
-
-    /* For default PulseAudio render device, OR together all of the
-     * PKEY_AudioEndpoint_PhysicalSpeakers values of the sinks. */
-    speaker = list_head(&g_phys_speakers);
-    if (speaker)
-        LIST_ENTRY(speaker, PhysDevice, entry)->channel_mask |= channel_mask;
-
-    pulse_add_device(&g_phys_speakers, i->proplist, i->index, Speakers, channel_mask, i->name, i->description);
-}
-
-static void pulse_phys_sources_cb(pa_context *c, const pa_source_info *i, int eol, void *userdata)
-{
-    if (!i || !i->name || !i->name[0])
-        return;
-    pulse_add_device(&g_phys_sources, i->proplist, i->index,
-        (i->monitor_of_sink == PA_INVALID_INDEX) ? Microphone : LineLevel, 0, i->name, i->description);
-}
-
-/* For most hardware on Windows, users must choose a configuration with an even
- * number of channels (stereo, quad, 5.1, 7.1). Users can then disable
- * channels, but those channels are still reported to applications from
- * GetMixFormat! Some applications behave badly if given an odd number of
- * channels (e.g. 2.1).  Here, we find the nearest configuration that Windows
- * would report for a given channel layout. */
-static void convert_channel_map(const pa_channel_map *pa_map, WAVEFORMATEXTENSIBLE *fmt)
-{
-    UINT pa_mask = pulse_channel_map_to_channel_mask(pa_map);
-
-    TRACE("got mask for PA: 0x%x\n", pa_mask);
-
-    if (pa_map->channels == 1)
-    {
-        fmt->Format.nChannels = 1;
-        fmt->dwChannelMask = pa_mask;
-        return;
-    }
-
-    /* compare against known configurations and find smallest configuration
-     * which is a superset of the given speakers */
-
-    if (pa_map->channels <= 2 &&
-            (pa_mask & ~KSAUDIO_SPEAKER_STEREO) == 0)
-    {
-        fmt->Format.nChannels = 2;
-        fmt->dwChannelMask = KSAUDIO_SPEAKER_STEREO;
-        return;
-    }
-
-    if (pa_map->channels <= 4 &&
-            (pa_mask & ~KSAUDIO_SPEAKER_QUAD) == 0)
-    {
-        fmt->Format.nChannels = 4;
-        fmt->dwChannelMask = KSAUDIO_SPEAKER_QUAD;
-        return;
-    }
-
-    if (pa_map->channels <= 4 &&
-            (pa_mask & ~KSAUDIO_SPEAKER_SURROUND) == 0)
-    {
-        fmt->Format.nChannels = 4;
-        fmt->dwChannelMask = KSAUDIO_SPEAKER_SURROUND;
-        return;
-    }
-
-    if (pa_map->channels <= 6 &&
-            (pa_mask & ~KSAUDIO_SPEAKER_5POINT1) == 0)
-    {
-        fmt->Format.nChannels = 6;
-        fmt->dwChannelMask = KSAUDIO_SPEAKER_5POINT1;
-        return;
-    }
-
-    if (pa_map->channels <= 6 &&
-            (pa_mask & ~KSAUDIO_SPEAKER_5POINT1_SURROUND) == 0)
-    {
-        fmt->Format.nChannels = 6;
-        fmt->dwChannelMask = KSAUDIO_SPEAKER_5POINT1_SURROUND;
-        return;
-    }
-
-    if (pa_map->channels <= 8 &&
-            (pa_mask & ~KSAUDIO_SPEAKER_7POINT1) == 0)
-    {
-        fmt->Format.nChannels = 8;
-        fmt->dwChannelMask = KSAUDIO_SPEAKER_7POINT1;
-        return;
-    }
-
-    if (pa_map->channels <= 8 &&
-            (pa_mask & ~KSAUDIO_SPEAKER_7POINT1_SURROUND) == 0)
-    {
-        fmt->Format.nChannels = 8;
-        fmt->dwChannelMask = KSAUDIO_SPEAKER_7POINT1_SURROUND;
-        return;
-    }
-
-    /* oddball format, report truthfully */
-    fmt->Format.nChannels = pa_map->channels;
-    fmt->dwChannelMask = pa_mask;
-}
-
-static void pulse_probe_settings(pa_mainloop *ml, pa_context *ctx, int render, const char *pulse_name,
-                                 WAVEFORMATEXTENSIBLE *fmt, REFERENCE_TIME *def_period, REFERENCE_TIME *min_period)
-{
-    WAVEFORMATEX *wfx = &fmt->Format;
-    pa_stream *stream;
-    pa_channel_map map;
-    pa_sample_spec ss;
-    pa_buffer_attr attr;
-    int ret;
-    unsigned int length = 0;
-
-    if (pulse_name && !pulse_name[0])
-        pulse_name = NULL;
-
-    pa_channel_map_init_auto(&map, 2, PA_CHANNEL_MAP_ALSA);
-    ss.rate = 48000;
-    ss.format = PA_SAMPLE_FLOAT32LE;
-    ss.channels = map.channels;
-
-    attr.maxlength = -1;
-    attr.tlength = -1;
-    attr.minreq = attr.fragsize = pa_frame_size(&ss);
-    attr.prebuf = 0;
-
-    stream = pa_stream_new(ctx, "format test stream", &ss, &map);
-    if (stream)
-        pa_stream_set_state_callback(stream, pulse_stream_state, NULL);
-    if (!stream)
-        ret = -1;
-    else if (render)
-        ret = pa_stream_connect_playback(stream, pulse_name, &attr,
-        PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS, NULL, NULL);
-    else
-        ret = pa_stream_connect_record(stream, pulse_name, &attr, PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS);
-    if (ret >= 0) {
-        while (pa_mainloop_iterate(ml, 1, &ret) >= 0 &&
-                pa_stream_get_state(stream) == PA_STREAM_CREATING)
-        {}
-        if (pa_stream_get_state(stream) == PA_STREAM_READY) {
-            ss = *pa_stream_get_sample_spec(stream);
-            map = *pa_stream_get_channel_map(stream);
-            if (render)
-                length = pa_stream_get_buffer_attr(stream)->minreq;
-            else
-                length = pa_stream_get_buffer_attr(stream)->fragsize;
-            pa_stream_disconnect(stream);
-            while (pa_mainloop_iterate(ml, 1, &ret) >= 0 &&
-                    pa_stream_get_state(stream) == PA_STREAM_READY)
-            {}
-        }
-    }
-
-    if (stream)
-        pa_stream_unref(stream);
-
-    if (length)
-        *def_period = *min_period = pa_bytes_to_usec(10 * length, &ss);
-
-    const char* penv = getenv("STAGING_AUDIO_PERIOD");
-    int val;
-    if (!penv) {
-        if (*min_period < MinimumPeriod)
-            *min_period = MinimumPeriod;
-
-        if (*def_period < DefaultPeriod)
-            *def_period = DefaultPeriod;
-    }
-	   else if ((val = atoi(penv)) >= 0) {
-        *def_period = *min_period = val;
-        printf("Audio period set to %d.\n", val);
-    }
-
-    wfx->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
-    wfx->cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
-
-    convert_channel_map(&map, fmt);
-
-    wfx->wBitsPerSample = 8 * pa_sample_size_of_format(ss.format);
-    wfx->nSamplesPerSec = ss.rate;
-    wfx->nBlockAlign = wfx->nChannels * wfx->wBitsPerSample / 8;
-    wfx->nAvgBytesPerSec = wfx->nSamplesPerSec * wfx->nBlockAlign;
-    if (ss.format != PA_SAMPLE_S24_32LE)
-        fmt->Samples.wValidBitsPerSample = wfx->wBitsPerSample;
-    else
-        fmt->Samples.wValidBitsPerSample = 24;
-    if (ss.format == PA_SAMPLE_FLOAT32LE)
-        fmt->SubFormat = KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
-    else
-        fmt->SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
-}
-
-/* some poorly-behaved applications call audio functions during DllMain, so we
- * have to do as much as possible without creating a new thread. this function
- * sets up a synchronous connection to verify the server is running and query
- * static data. */
-static NTSTATUS pulse_test_connect(void *args)
-{
-    struct test_connect_params *params = args;
-    PhysDevice *dev;
-    pa_operation *o;
-    int ret;
-    char *name = wstr_to_str(params->name);
-    pa_mainloop *ml;
-    pa_context *ctx;
-
-    pulse_lock();
-    ml = pa_mainloop_new();
-
-    pa_mainloop_set_poll_func(ml, pulse_poll_func, NULL);
-
-    ctx = pa_context_new(pa_mainloop_get_api(ml), name);
-    free(name);
-    if (!ctx) {
-        ERR("Failed to create context\n");
-        pa_mainloop_free(ml);
-        pulse_unlock();
-        params->priority = Priority_Unavailable;
-        return STATUS_SUCCESS;
-    }
-
-    pa_context_set_state_callback(ctx, pulse_contextcallback, NULL);
-
-    TRACE("libpulse protocol version: %u. API Version %u\n", pa_context_get_protocol_version(ctx), PA_API_VERSION);
-    if (pa_context_connect(ctx, NULL, 0, NULL) < 0)
-        goto fail;
-
-    /* Wait for connection */
-    while (pa_mainloop_iterate(ml, 1, &ret) >= 0) {
-        pa_context_state_t state = pa_context_get_state(ctx);
-
-        if (state == PA_CONTEXT_FAILED || state == PA_CONTEXT_TERMINATED)
-            goto fail;
-
-        if (state == PA_CONTEXT_READY)
-            break;
-    }
-
-    if (pa_context_get_state(ctx) != PA_CONTEXT_READY)
-        goto fail;
-
-    TRACE("Test-connected to server %s with protocol version: %i.\n",
-        pa_context_get_server(ctx),
-        pa_context_get_server_protocol_version(ctx));
-
-    free_phys_device_lists();
-    list_init(&g_phys_speakers);
-    list_init(&g_phys_sources);
-
-    pulse_add_device(&g_phys_speakers, NULL, 0, Speakers, 0, "", "PulseAudio");
-    pulse_add_device(&g_phys_sources, NULL, 0, Microphone, 0, "", "PulseAudio");
-
-    o = pa_context_get_sink_info_list(ctx, &pulse_phys_speakers_cb, NULL);
-    if (o) {
-        while (pa_mainloop_iterate(ml, 1, &ret) >= 0 &&
-                pa_operation_get_state(o) == PA_OPERATION_RUNNING)
-        {}
-        pa_operation_unref(o);
-    }
-
-    o = pa_context_get_source_info_list(ctx, &pulse_phys_sources_cb, NULL);
-    if (o) {
-        while (pa_mainloop_iterate(ml, 1, &ret) >= 0 &&
-                pa_operation_get_state(o) == PA_OPERATION_RUNNING)
-        {}
-        pa_operation_unref(o);
-    }
-
-    LIST_FOR_EACH_ENTRY(dev, &g_phys_speakers, PhysDevice, entry) {
-        pulse_probe_settings(ml, ctx, 1, dev->pulse_name, &dev->fmt, &dev->def_period, &dev->min_period);
-    }
-
-    LIST_FOR_EACH_ENTRY(dev, &g_phys_sources, PhysDevice, entry) {
-        pulse_probe_settings(ml, ctx, 0, dev->pulse_name, &dev->fmt, &dev->def_period, &dev->min_period);
-    }
-
-    pa_context_unref(ctx);
-    pa_mainloop_free(ml);
-
-    pulse_unlock();
-
-    params->priority = Priority_Preferred;
-    return STATUS_SUCCESS;
-
-fail:
-    pa_context_unref(ctx);
-    pa_mainloop_free(ml);
-    pulse_unlock();
-    params->priority = Priority_Unavailable;
-    return STATUS_SUCCESS;
-}
-
-static UINT get_channel_mask(unsigned int channels)
-{
-    switch(channels) {
-    case 0:
-        return 0;
-    case 1:
-        return KSAUDIO_SPEAKER_MONO;
-    case 2:
-        return KSAUDIO_SPEAKER_STEREO;
-    case 3:
-        return KSAUDIO_SPEAKER_STEREO | SPEAKER_LOW_FREQUENCY;
-    case 4:
-        return KSAUDIO_SPEAKER_QUAD;    /* not _SURROUND */
-    case 5:
-        return KSAUDIO_SPEAKER_QUAD | SPEAKER_LOW_FREQUENCY;
-    case 6:
-        return KSAUDIO_SPEAKER_5POINT1; /* not 5POINT1_SURROUND */
-    case 7:
-        return KSAUDIO_SPEAKER_5POINT1 | SPEAKER_BACK_CENTER;
-    case 8:
-        return KSAUDIO_SPEAKER_7POINT1_SURROUND; /* Vista deprecates 7POINT1 */
-    }
-    FIXME("Unknown speaker configuration: %u\n", channels);
-    return 0;
-}
-
-static const enum pa_channel_position pulse_pos_from_wfx[] = {
-    PA_CHANNEL_POSITION_FRONT_LEFT,
-    PA_CHANNEL_POSITION_FRONT_RIGHT,
-    PA_CHANNEL_POSITION_FRONT_CENTER,
-    PA_CHANNEL_POSITION_LFE,
-    PA_CHANNEL_POSITION_REAR_LEFT,
-    PA_CHANNEL_POSITION_REAR_RIGHT,
-    PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,
-    PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,
-    PA_CHANNEL_POSITION_REAR_CENTER,
-    PA_CHANNEL_POSITION_SIDE_LEFT,
-    PA_CHANNEL_POSITION_SIDE_RIGHT,
-    PA_CHANNEL_POSITION_TOP_CENTER,
-    PA_CHANNEL_POSITION_TOP_FRONT_LEFT,
-    PA_CHANNEL_POSITION_TOP_FRONT_CENTER,
-    PA_CHANNEL_POSITION_TOP_FRONT_RIGHT,
-    PA_CHANNEL_POSITION_TOP_REAR_LEFT,
-    PA_CHANNEL_POSITION_TOP_REAR_CENTER,
-    PA_CHANNEL_POSITION_TOP_REAR_RIGHT,
-    PA_CHANNEL_POSITION_AUX0,
-    PA_CHANNEL_POSITION_AUX1
-};
-
-static HRESULT pulse_spec_from_waveformat(struct pulse_stream *stream, const WAVEFORMATEX *fmt)
-{
-    pa_channel_map_init(&stream->map);
-    stream->ss.rate = fmt->nSamplesPerSec;
-    stream->ss.format = PA_SAMPLE_INVALID;
-
-    switch(fmt->wFormatTag) {
-    case WAVE_FORMAT_IEEE_FLOAT:
-        if (!fmt->nChannels || fmt->nChannels > 2 || fmt->wBitsPerSample != 32)
-            break;
-        stream->ss.format = PA_SAMPLE_FLOAT32LE;
-        pa_channel_map_init_auto(&stream->map, fmt->nChannels, PA_CHANNEL_MAP_ALSA);
-        break;
-    case WAVE_FORMAT_PCM:
-        if (!fmt->nChannels || fmt->nChannels > 2)
-            break;
-        if (fmt->wBitsPerSample == 8)
-            stream->ss.format = PA_SAMPLE_U8;
-        else if (fmt->wBitsPerSample == 16)
-            stream->ss.format = PA_SAMPLE_S16LE;
-        else
-            return AUDCLNT_E_UNSUPPORTED_FORMAT;
-        pa_channel_map_init_auto(&stream->map, fmt->nChannels, PA_CHANNEL_MAP_ALSA);
-        break;
-    case WAVE_FORMAT_EXTENSIBLE: {
-        WAVEFORMATEXTENSIBLE *wfe = (WAVEFORMATEXTENSIBLE*)fmt;
-        UINT mask = wfe->dwChannelMask;
-        unsigned i = 0, j;
-        if (fmt->cbSize != (sizeof(*wfe) - sizeof(*fmt)) && fmt->cbSize != sizeof(*wfe))
-            break;
-        if (IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT) &&
-            (!wfe->Samples.wValidBitsPerSample || wfe->Samples.wValidBitsPerSample == 32) &&
-            fmt->wBitsPerSample == 32)
-            stream->ss.format = PA_SAMPLE_FLOAT32LE;
-        else if (IsEqualGUID(&wfe->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM)) {
-            DWORD valid = wfe->Samples.wValidBitsPerSample;
-            if (!valid)
-                valid = fmt->wBitsPerSample;
-            if (!valid || valid > fmt->wBitsPerSample)
-                break;
-            switch (fmt->wBitsPerSample) {
-                case 8:
-                    if (valid == 8)
-                        stream->ss.format = PA_SAMPLE_U8;
-                    break;
-                case 16:
-                    if (valid == 16)
-                        stream->ss.format = PA_SAMPLE_S16LE;
-                    break;
-                case 24:
-                    if (valid == 24)
-                        stream->ss.format = PA_SAMPLE_S24LE;
-                    break;
-                case 32:
-                    if (valid == 24)
-                        stream->ss.format = PA_SAMPLE_S24_32LE;
-                    else if (valid == 32)
-                        stream->ss.format = PA_SAMPLE_S32LE;
-                    break;
-                default:
-                    return AUDCLNT_E_UNSUPPORTED_FORMAT;
-            }
-        }
-        stream->map.channels = fmt->nChannels;
-        if (!mask || (mask & (SPEAKER_ALL|SPEAKER_RESERVED)))
-            mask = get_channel_mask(fmt->nChannels);
-        for (j = 0; j < ARRAY_SIZE(pulse_pos_from_wfx) && i < fmt->nChannels; ++j) {
-            if (mask & (1 << j))
-                stream->map.map[i++] = pulse_pos_from_wfx[j];
-        }
-
-        /* Special case for mono since pulse appears to map it differently */
-        if (mask == SPEAKER_FRONT_CENTER)
-            stream->map.map[0] = PA_CHANNEL_POSITION_MONO;
-
-        if (i < fmt->nChannels || (mask & SPEAKER_RESERVED)) {
-            stream->map.channels = 0;
-            ERR("Invalid channel mask: %i/%i and %x(%x)\n", i, fmt->nChannels, mask, (unsigned)wfe->dwChannelMask);
-            break;
-        }
-        break;
-        }
-    case WAVE_FORMAT_ALAW:
-    case WAVE_FORMAT_MULAW:
-        if (fmt->wBitsPerSample != 8) {
-            FIXME("Unsupported bpp %u for LAW\n", fmt->wBitsPerSample);
-            return AUDCLNT_E_UNSUPPORTED_FORMAT;
-        }
-        if (fmt->nChannels != 1 && fmt->nChannels != 2) {
-            FIXME("Unsupported channels %u for LAW\n", fmt->nChannels);
-            return AUDCLNT_E_UNSUPPORTED_FORMAT;
-        }
-        stream->ss.format = fmt->wFormatTag == WAVE_FORMAT_MULAW ? PA_SAMPLE_ULAW : PA_SAMPLE_ALAW;
-        pa_channel_map_init_auto(&stream->map, fmt->nChannels, PA_CHANNEL_MAP_ALSA);
-        break;
-    default:
-        WARN("Unhandled tag %x\n", fmt->wFormatTag);
-        return AUDCLNT_E_UNSUPPORTED_FORMAT;
-    }
-    stream->ss.channels = stream->map.channels;
-    if (!pa_channel_map_valid(&stream->map) || stream->ss.format == PA_SAMPLE_INVALID) {
-        ERR("Invalid format! Channel spec valid: %i, format: %i\n",
-            pa_channel_map_valid(&stream->map), stream->ss.format);
-        return AUDCLNT_E_UNSUPPORTED_FORMAT;
-    }
-    return S_OK;
-}
-
-static HRESULT pulse_stream_connect(struct pulse_stream *stream, const char *pulse_name, UINT32 period_bytes)
-{
-    pa_stream_flags_t flags = PA_STREAM_START_CORKED | PA_STREAM_START_UNMUTED | PA_STREAM_ADJUST_LATENCY;
-    int ret;
-    char buffer[64];
-    static LONG number;
-    pa_buffer_attr attr;
-
-    ret = InterlockedIncrement(&number);
-    sprintf(buffer, "audio stream #%i", ret);
-    stream->stream = pa_stream_new(pulse_ctx, buffer, &stream->ss, &stream->map);
-
-    if (!stream->stream) {
-        WARN("pa_stream_new returned error %i\n", pa_context_errno(pulse_ctx));
-        return AUDCLNT_E_ENDPOINT_CREATE_FAILED;
-    }
-
-    pa_stream_set_state_callback(stream->stream, pulse_stream_state, stream);
-    pa_stream_set_buffer_attr_callback(stream->stream, pulse_attr_update, stream);
-    pa_stream_set_moved_callback(stream->stream, pulse_attr_update, stream);
-
-    /* PulseAudio will fill in correct values */
-    attr.minreq = attr.fragsize = period_bytes;
-    attr.tlength = period_bytes * 3;
-    attr.maxlength = stream->bufsize_frames * pa_frame_size(&stream->ss);
-    attr.prebuf = pa_frame_size(&stream->ss);
-    dump_attr(&attr);
-
-    /* If specific device was requested, use it exactly */
-    if (pulse_name[0])
-        flags |= PA_STREAM_DONT_MOVE;
-    else
-        pulse_name = NULL;  /* use default */
-
-    if (stream->dataflow == eRender)
-        ret = pa_stream_connect_playback(stream->stream, pulse_name, &attr, flags, NULL, NULL);
-    else
-        ret = pa_stream_connect_record(stream->stream, pulse_name, &attr, flags);
-    if (ret < 0) {
-        WARN("Returns %i\n", ret);
-        return AUDCLNT_E_ENDPOINT_CREATE_FAILED;
-    }
-    while (pa_stream_get_state(stream->stream) == PA_STREAM_CREATING)
-        pulse_cond_wait();
-    if (pa_stream_get_state(stream->stream) != PA_STREAM_READY)
-        return AUDCLNT_E_ENDPOINT_CREATE_FAILED;
-
-    if (stream->dataflow == eRender) {
-        pa_stream_set_underflow_callback(stream->stream, pulse_underflow_callback, stream);
-        pa_stream_set_started_callback(stream->stream, pulse_started_callback, stream);
-        pa_stream_set_write_callback(stream->stream, pulse_write_callback, stream);
-    }
-    return S_OK;
-}
-
-static HRESULT get_device_period_helper(EDataFlow flow, const char *pulse_name, REFERENCE_TIME *def, REFERENCE_TIME *min)
-{
-    struct list *list = (flow == eRender) ? &g_phys_speakers : &g_phys_sources;
-    PhysDevice *dev;
-
-    if (!def && !min) {
-        return E_POINTER;
-    }
-
-    LIST_FOR_EACH_ENTRY(dev, list, PhysDevice, entry) {
-        if (strcmp(pulse_name, dev->pulse_name))
-            continue;
-
-        if (def)
-            *def = dev->def_period;
-        if (min)
-            *min = dev->min_period;
-        return S_OK;
-    }
-
-    return E_FAIL;
-}
-
-static NTSTATUS pulse_create_stream(void *args)
-{
-    struct create_stream_params *params = args;
-    REFERENCE_TIME period, duration = params->duration;
-    struct pulse_stream *stream;
-    unsigned int i, bufsize_bytes;
-    HRESULT hr;
-    char *name;
-
-    if (params->share == AUDCLNT_SHAREMODE_EXCLUSIVE) {
-        params->result = AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED;
-        return STATUS_SUCCESS;
-    }
-
-    pulse_lock();
-
-    name = wstr_to_str(params->name);
-    params->result = pulse_connect(name);
-    free(name);
-
-    if (FAILED(params->result))
-    {
-        pulse_unlock();
-        return STATUS_SUCCESS;
-    }
-
-    if (!(stream = calloc(1, sizeof(*stream))))
-    {
-        pulse_unlock();
-        params->result = E_OUTOFMEMORY;
-        return STATUS_SUCCESS;
-    }
-
-    stream->dataflow = params->flow;
-    for (i = 0; i < ARRAY_SIZE(stream->vol); ++i)
-        stream->vol[i] = 1.f;
-
-    hr = pulse_spec_from_waveformat(stream, params->fmt);
-    TRACE("Obtaining format returns %08x\n", (unsigned)hr);
-
-    if (FAILED(hr))
-        goto exit;
-
-    period = 0;
-    hr = get_device_period_helper(params->flow, params->device, &period, NULL);
-    if (FAILED(hr))
-        goto exit;
-
-    if (duration < 3 * period)
-        duration = 3 * period;
-
-    stream->def_period = period;
-
-    const char* denv = getenv("STAGING_AUDIO_DURATION");
-    if (denv) {
-        int val = atoi(denv);
-        duration = val;
-        printf("Audio duration set to %d.\n", val);
-    }
-
-    stream->period_bytes = pa_frame_size(&stream->ss) * muldiv(period, stream->ss.rate, 10000000);
-
-    stream->bufsize_frames = ceil((duration / 10000000.) * params->fmt->nSamplesPerSec);
-    bufsize_bytes = stream->bufsize_frames * pa_frame_size(&stream->ss);
-    stream->mmdev_period_usec = period / 10;
-
-    stream->share = params->share;
-    stream->flags = params->flags;
-    hr = pulse_stream_connect(stream, params->device, stream->period_bytes);
-    if (SUCCEEDED(hr)) {
-        UINT32 unalign;
-        const pa_buffer_attr *attr = pa_stream_get_buffer_attr(stream->stream);
-        SIZE_T size;
-
-        stream->attr = *attr;
-        /* Update frames according to new size */
-        dump_attr(attr);
-        if (stream->dataflow == eRender) {
-            size = stream->real_bufsize_bytes =
-                stream->bufsize_frames * pa_frame_size(&stream->ss);
-            if (NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->local_buffer,
-                                        zero_bits, &size, MEM_COMMIT, PAGE_READWRITE))
-                hr = E_OUTOFMEMORY;
-        } else {
-            UINT32 i, capture_packets;
-
-            if ((unalign = bufsize_bytes % stream->period_bytes))
-                bufsize_bytes += stream->period_bytes - unalign;
-            stream->bufsize_frames = bufsize_bytes / pa_frame_size(&stream->ss);
-            stream->real_bufsize_bytes = bufsize_bytes;
-
-            capture_packets = stream->real_bufsize_bytes / stream->period_bytes;
-
-            size = stream->real_bufsize_bytes + capture_packets * sizeof(ACPacket);
-            if (NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->local_buffer,
-                                        zero_bits, &size, MEM_COMMIT, PAGE_READWRITE))
-                hr = E_OUTOFMEMORY;
-            else {
-                ACPacket *cur_packet = (ACPacket*)((char*)stream->local_buffer + stream->real_bufsize_bytes);
-                BYTE *data = stream->local_buffer;
-                silence_buffer(stream->ss.format, stream->local_buffer, stream->real_bufsize_bytes);
-                list_init(&stream->packet_free_head);
-                list_init(&stream->packet_filled_head);
-                for (i = 0; i < capture_packets; ++i, ++cur_packet) {
-                    list_add_tail(&stream->packet_free_head, &cur_packet->entry);
-                    cur_packet->data = data;
-                    data += stream->period_bytes;
-                }
-            }
-        }
-    }
-
-    *params->channel_count = stream->ss.channels;
-    *params->stream = (stream_handle)(UINT_PTR)stream;
-
-exit:
-    if (FAILED(params->result = hr)) {
-        free(stream->local_buffer);
-        if (stream->stream) {
-            pa_stream_disconnect(stream->stream);
-            pa_stream_unref(stream->stream);
-        }
-        free(stream);
-    }
-
-    pulse_unlock();
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_release_stream(void *args)
-{
-    struct release_stream_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-    SIZE_T size;
-
-    if(params->timer_thread) {
-        stream->please_quit = TRUE;
-        NtWaitForSingleObject(params->timer_thread, FALSE, NULL);
-        NtClose(params->timer_thread);
-    }
-
-    pulse_lock();
-    if (PA_STREAM_IS_GOOD(pa_stream_get_state(stream->stream))) {
-        pa_stream_disconnect(stream->stream);
-        while (PA_STREAM_IS_GOOD(pa_stream_get_state(stream->stream)))
-            pulse_cond_wait();
-    }
-    pa_stream_unref(stream->stream);
-    pulse_unlock();
-
-    if (stream->tmp_buffer) {
-        size = 0;
-        NtFreeVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer,
-                            &size, MEM_RELEASE);
-    }
-    if (stream->local_buffer) {
-        size = 0;
-        NtFreeVirtualMemory(GetCurrentProcess(), (void **)&stream->local_buffer,
-                            &size, MEM_RELEASE);
-    }
-    free(stream->peek_buffer);
-    free(stream);
-    return STATUS_SUCCESS;
-}
-
-static void pulse_read(struct pulse_stream *stream)
-{
-    size_t bytes = pa_stream_readable_size(stream->stream);
-
-    TRACE("Readable total: %zu, fragsize: %u\n", bytes, pa_stream_get_buffer_attr(stream->stream)->fragsize);
-
-    bytes += stream->peek_len - stream->peek_ofs;
-
-    while (bytes >= stream->period_bytes)
-    {
-        BYTE *dst = NULL, *src;
-        size_t src_len, copy, rem = stream->period_bytes;
-
-        if (stream->started)
-        {
-            LARGE_INTEGER stamp, freq;
-            ACPacket *p, *next;
-
-            if (!(p = (ACPacket*)list_head(&stream->packet_free_head)))
-            {
-                p = (ACPacket*)list_head(&stream->packet_filled_head);
-                if (!p) return;
-                if (!p->discont) {
-                    next = (ACPacket*)p->entry.next;
-                    next->discont = 1;
-                } else
-                    p = (ACPacket*)list_tail(&stream->packet_filled_head);
-            }
-            else
-            {
-                stream->held_bytes += stream->period_bytes;
-            }
-            NtQueryPerformanceCounter(&stamp, &freq);
-            p->qpcpos = (stamp.QuadPart * (INT64)10000000) / freq.QuadPart;
-            p->discont = 0;
-            list_remove(&p->entry);
-            list_add_tail(&stream->packet_filled_head, &p->entry);
-
-            dst = p->data;
-        }
-
-        while (rem)
-        {
-            if (stream->peek_len)
-            {
-                copy = min(rem, stream->peek_len - stream->peek_ofs);
-
-                if (dst)
-                {
-                    memcpy(dst, stream->peek_buffer + stream->peek_ofs, copy);
-                    dst += copy;
-                }
-
-                rem -= copy;
-                stream->peek_ofs += copy;
-                if(stream->peek_len == stream->peek_ofs)
-                    stream->peek_len = stream->peek_ofs = 0;
-
-            }
-            else if (pa_stream_peek(stream->stream, (const void**)&src, &src_len) == 0 && src_len)
-            {
-                copy = min(rem, src_len);
-
-                if (dst) {
-                    if(src)
-                        memcpy(dst, src, copy);
-                    else
-                        silence_buffer(stream->ss.format, dst, copy);
-
-                    dst += copy;
-                }
-
-                rem -= copy;
-
-                if (copy < src_len)
-                {
-                    if (src_len > stream->peek_buffer_len)
-                    {
-                        free(stream->peek_buffer);
-                        stream->peek_buffer = malloc(src_len);
-                        stream->peek_buffer_len = src_len;
-                    }
-
-                    if(src)
-                        memcpy(stream->peek_buffer, src + copy, src_len - copy);
-                    else
-                        silence_buffer(stream->ss.format, stream->peek_buffer, src_len - copy);
-
-                    stream->peek_len = src_len - copy;
-                    stream->peek_ofs = 0;
-                }
-
-                pa_stream_drop(stream->stream);
-            }
-        }
-
-        bytes -= stream->period_bytes;
-    }
-}
-
-static NTSTATUS pulse_timer_loop(void *args)
-{
-    struct timer_loop_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-    LARGE_INTEGER delay;
-    pa_usec_t last_time;
-    UINT32 adv_bytes;
-    int success;
-    pa_operation *o;
-
-    pulse_lock();
-    delay.QuadPart = -stream->mmdev_period_usec * 10;
-    pa_stream_get_time(stream->stream, &last_time);
-    pulse_unlock();
-
-    while (!stream->please_quit)
-    {
-        pa_usec_t now, adv_usec = 0;
-        int err;
-
-        NtDelayExecution(FALSE, &delay);
-
-        pulse_lock();
-
-        delay.QuadPart = -stream->mmdev_period_usec * 10;
-
-        o = pa_stream_update_timing_info(stream->stream, pulse_op_cb, &success);
-        if (o)
-        {
-            while (pa_operation_get_state(o) == PA_OPERATION_RUNNING)
-                pulse_cond_wait();
-            pa_operation_unref(o);
-        }
-        err = pa_stream_get_time(stream->stream, &now);
-        if (err == 0)
-        {
-            TRACE("got now: %s, last time: %s\n", wine_dbgstr_longlong(now), wine_dbgstr_longlong(last_time));
-            if (stream->started && (stream->dataflow == eCapture || stream->held_bytes))
-            {
-                if(stream->just_underran)
-                {
-                    last_time = now;
-                    stream->just_started = TRUE;
-                }
-
-                if (stream->just_started)
-                {
-                    /* let it play out a period to absorb some latency and get accurate timing */
-                    pa_usec_t diff = now - last_time;
-
-                    if (diff > stream->mmdev_period_usec)
-                    {
-                        stream->just_started = FALSE;
-                        last_time = now;
-                    }
-                }
-                else
-                {
-                    INT32 adjust = last_time + stream->mmdev_period_usec - now;
-
-                    adv_usec = now - last_time;
-
-                    if(adjust > ((INT32)(stream->mmdev_period_usec / 2)))
-                        adjust = stream->mmdev_period_usec / 2;
-                    else if(adjust < -((INT32)(stream->mmdev_period_usec / 2)))
-                        adjust = -1 * stream->mmdev_period_usec / 2;
-
-                    delay.QuadPart = -(stream->mmdev_period_usec + adjust) * 10;
-
-                    last_time += stream->mmdev_period_usec;
-                }
-
-                if (stream->dataflow == eRender)
-                {
-                    pulse_write_callback(stream->stream, pa_stream_writable_size(stream->stream), stream);
-
-                    /* regardless of what PA does, advance one period */
-                    adv_bytes = min(stream->period_bytes, stream->held_bytes);
-                    stream->lcl_offs_bytes += adv_bytes;
-                    stream->lcl_offs_bytes %= stream->real_bufsize_bytes;
-                    stream->held_bytes -= adv_bytes;
-                }
-                else if(stream->dataflow == eCapture)
-                {
-                    pulse_read(stream);
-                }
-            }
-            else
-            {
-                last_time = now;
-                delay.QuadPart = -stream->mmdev_period_usec * 10;
-            }
-        }
-
-        if (stream->event)
-            NtSetEvent(stream->event, NULL);
-
-        TRACE("%p after update, adv usec: %d, held: %u, delay usec: %u\n",
-                stream, (int)adv_usec,
-                (int)(stream->held_bytes/ pa_frame_size(&stream->ss)),
-                (unsigned int)(-delay.QuadPart / 10));
-
-        pulse_unlock();
-    }
-
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_start(void *args)
-{
-    struct start_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-    int success;
-    pa_operation *o;
-
-    params->result = S_OK;
-    pulse_lock();
-    if (!pulse_stream_valid(stream))
-    {
-        pulse_unlock();
-        params->result = S_OK;
-        return STATUS_SUCCESS;
-    }
-
-    if ((stream->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) && !stream->event)
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_EVENTHANDLE_NOT_SET;
-        return STATUS_SUCCESS;
-    }
-
-    if (stream->started)
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_NOT_STOPPED;
-        return STATUS_SUCCESS;
-    }
-
-    pulse_write_callback(stream->stream, pa_stream_writable_size(stream->stream), stream);
-
-    if (pa_stream_is_corked(stream->stream))
-    {
-        o = pa_stream_cork(stream->stream, 0, pulse_op_cb, &success);
-        if (o)
-        {
-            while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
-                pulse_cond_wait();
-            pa_operation_unref(o);
-        }
-        else
-            success = 0;
-        if (!success)
-            params->result = E_FAIL;
-    }
-
-    if (SUCCEEDED(params->result))
-    {
-        stream->started = TRUE;
-        stream->just_started = TRUE;
-    }
-    pulse_unlock();
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_stop(void *args)
-{
-    struct stop_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-    pa_operation *o;
-    int success;
-
-    pulse_lock();
-    if (!pulse_stream_valid(stream))
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_DEVICE_INVALIDATED;
-        return STATUS_SUCCESS;
-    }
-
-    if (!stream->started)
-    {
-        pulse_unlock();
-        params->result = S_FALSE;
-        return STATUS_SUCCESS;
-    }
-
-    params->result = S_OK;
-    if (stream->dataflow == eRender)
-    {
-        o = pa_stream_cork(stream->stream, 1, pulse_op_cb, &success);
-        if (o)
-        {
-            while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
-                pulse_cond_wait();
-            pa_operation_unref(o);
-        }
-        else
-            success = 0;
-        if (!success)
-            params->result = E_FAIL;
-    }
-    if (SUCCEEDED(params->result))
-        stream->started = FALSE;
-    pulse_unlock();
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_reset(void *args)
-{
-    struct reset_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-
-    pulse_lock();
-    if (!pulse_stream_valid(stream))
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_DEVICE_INVALIDATED;
-        return STATUS_SUCCESS;
-    }
-
-    if (stream->started)
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_NOT_STOPPED;
-        return STATUS_SUCCESS;
-    }
-
-    if (stream->locked)
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_BUFFER_OPERATION_PENDING;
-        return STATUS_SUCCESS;
-    }
-
-    if (stream->dataflow == eRender)
-    {
-        /* If there is still data in the render buffer it needs to be removed from the server */
-        int success = 0;
-        if (stream->held_bytes)
-        {
-            pa_operation *o = pa_stream_flush(stream->stream, pulse_op_cb, &success);
-            if (o)
-            {
-                while (pa_operation_get_state(o) == PA_OPERATION_RUNNING)
-                    pulse_cond_wait();
-                pa_operation_unref(o);
-            }
-        }
-        if (success || !stream->held_bytes)
-        {
-            stream->clock_lastpos = stream->clock_written = 0;
-            stream->pa_offs_bytes = stream->lcl_offs_bytes = 0;
-            stream->held_bytes = stream->pa_held_bytes = 0;
-        }
-    }
-    else
-    {
-        ACPacket *p;
-        stream->clock_written += stream->held_bytes;
-        stream->held_bytes = 0;
-
-        if ((p = stream->locked_ptr))
-        {
-            stream->locked_ptr = NULL;
-            list_add_tail(&stream->packet_free_head, &p->entry);
-        }
-        list_move_tail(&stream->packet_free_head, &stream->packet_filled_head);
-    }
-    pulse_unlock();
-    params->result = S_OK;
-    return STATUS_SUCCESS;
-}
-
-static BOOL alloc_tmp_buffer(struct pulse_stream *stream, SIZE_T bytes)
-{
-    SIZE_T size;
-
-    if (stream->tmp_buffer_bytes >= bytes)
-        return TRUE;
-
-    if (stream->tmp_buffer)
-    {
-        size = 0;
-        NtFreeVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer,
-                            &size, MEM_RELEASE);
-        stream->tmp_buffer = NULL;
-        stream->tmp_buffer_bytes = 0;
-    }
-    if (NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer,
-                                zero_bits, &bytes, MEM_COMMIT, PAGE_READWRITE))
-        return FALSE;
-
-    stream->tmp_buffer_bytes = bytes;
-    return TRUE;
-}
-
-static UINT32 pulse_render_padding(struct pulse_stream *stream)
-{
-    return stream->held_bytes / pa_frame_size(&stream->ss);
-}
-
-static UINT32 pulse_capture_padding(struct pulse_stream *stream)
-{
-    ACPacket *packet = stream->locked_ptr;
-    if (!packet && !list_empty(&stream->packet_filled_head))
-    {
-        packet = (ACPacket*)list_head(&stream->packet_filled_head);
-        stream->locked_ptr = packet;
-        list_remove(&packet->entry);
-    }
-    return stream->held_bytes / pa_frame_size(&stream->ss);
-}
-
-static NTSTATUS pulse_get_render_buffer(void *args)
-{
-    struct get_render_buffer_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-    size_t bytes;
-    UINT32 wri_offs_bytes;
-
-    pulse_lock();
-    if (!pulse_stream_valid(stream))
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_DEVICE_INVALIDATED;
-        return STATUS_SUCCESS;
-    }
-
-    if (stream->locked)
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_OUT_OF_ORDER;
-        return STATUS_SUCCESS;
-    }
-
-    if (!params->frames)
-    {
-        pulse_unlock();
-        *params->data = NULL;
-        params->result = S_OK;
-        return STATUS_SUCCESS;
-    }
-
-    if (stream->held_bytes / pa_frame_size(&stream->ss) + params->frames > stream->bufsize_frames)
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_BUFFER_TOO_LARGE;
-        return STATUS_SUCCESS;
-    }
-
-    bytes = params->frames * pa_frame_size(&stream->ss);
-    wri_offs_bytes = (stream->lcl_offs_bytes + stream->held_bytes) % stream->real_bufsize_bytes;
-    if (wri_offs_bytes + bytes > stream->real_bufsize_bytes)
-    {
-        if (!alloc_tmp_buffer(stream, bytes))
-        {
-            pulse_unlock();
-            params->result = E_OUTOFMEMORY;
-            return STATUS_SUCCESS;
-        }
-        *params->data = stream->tmp_buffer;
-        stream->locked = -bytes;
-    }
-    else
-    {
-        *params->data = stream->local_buffer + wri_offs_bytes;
-        stream->locked = bytes;
-    }
-
-    silence_buffer(stream->ss.format, *params->data, bytes);
-
-    pulse_unlock();
-    params->result = S_OK;
-    return STATUS_SUCCESS;
-}
-
-static void pulse_wrap_buffer(struct pulse_stream *stream, BYTE *buffer, UINT32 written_bytes)
-{
-    UINT32 wri_offs_bytes = (stream->lcl_offs_bytes + stream->held_bytes) % stream->real_bufsize_bytes;
-    UINT32 chunk_bytes = stream->real_bufsize_bytes - wri_offs_bytes;
-
-    if (written_bytes <= chunk_bytes)
-    {
-        memcpy(stream->local_buffer + wri_offs_bytes, buffer, written_bytes);
-    }
-    else
-    {
-        memcpy(stream->local_buffer + wri_offs_bytes, buffer, chunk_bytes);
-        memcpy(stream->local_buffer, buffer + chunk_bytes, written_bytes - chunk_bytes);
-    }
-}
-
-static NTSTATUS pulse_release_render_buffer(void *args)
-{
-    struct release_render_buffer_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-    UINT32 written_bytes;
-    BYTE *buffer;
-
-    pulse_lock();
-    if (!stream->locked || !params->written_frames)
-    {
-        stream->locked = 0;
-        pulse_unlock();
-        params->result = params->written_frames ? AUDCLNT_E_OUT_OF_ORDER : S_OK;
-        return STATUS_SUCCESS;
-    }
-
-    if (params->written_frames * pa_frame_size(&stream->ss) >
-        (stream->locked >= 0 ? stream->locked : -stream->locked))
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_INVALID_SIZE;
-        return STATUS_SUCCESS;
-    }
-
-    if (stream->locked >= 0)
-        buffer = stream->local_buffer + (stream->lcl_offs_bytes + stream->held_bytes) % stream->real_bufsize_bytes;
-    else
-        buffer = stream->tmp_buffer;
-
-    written_bytes = params->written_frames * pa_frame_size(&stream->ss);
-    if (params->flags & AUDCLNT_BUFFERFLAGS_SILENT)
-        silence_buffer(stream->ss.format, buffer, written_bytes);
-
-    if (stream->locked < 0)
-        pulse_wrap_buffer(stream, buffer, written_bytes);
-
-    stream->held_bytes += written_bytes;
-    stream->pa_held_bytes += written_bytes;
-    if (stream->pa_held_bytes > stream->real_bufsize_bytes)
-    {
-        stream->pa_offs_bytes += stream->pa_held_bytes - stream->real_bufsize_bytes;
-        stream->pa_offs_bytes %= stream->real_bufsize_bytes;
-        stream->pa_held_bytes = stream->real_bufsize_bytes;
-    }
-    stream->clock_written += written_bytes;
-    stream->locked = 0;
-
-    /* push as much data as we can to pulseaudio too */
-    pulse_write_callback(stream->stream, pa_stream_writable_size(stream->stream), stream);
-
-    TRACE("Released %u, held %lu\n", params->written_frames, stream->held_bytes / pa_frame_size(&stream->ss));
-
-    pulse_unlock();
-    params->result = S_OK;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_get_capture_buffer(void *args)
-{
-    struct get_capture_buffer_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-    ACPacket *packet;
-
-    pulse_lock();
-    if (!pulse_stream_valid(stream))
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_DEVICE_INVALIDATED;
-        return STATUS_SUCCESS;
-    }
-    if (stream->locked)
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_OUT_OF_ORDER;
-        return STATUS_SUCCESS;
-    }
-
-    pulse_capture_padding(stream);
-    if ((packet = stream->locked_ptr))
-    {
-        *params->frames = stream->period_bytes / pa_frame_size(&stream->ss);
-        *params->flags = 0;
-        if (packet->discont)
-            *params->flags |= AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY;
-        if (params->devpos)
-        {
-            if (packet->discont)
-                *params->devpos = (stream->clock_written + stream->period_bytes) / pa_frame_size(&stream->ss);
-            else
-                *params->devpos = stream->clock_written / pa_frame_size(&stream->ss);
-        }
-        if (params->qpcpos)
-            *params->qpcpos = packet->qpcpos;
-        *params->data = packet->data;
-    }
-    else
-        *params->frames = 0;
-    stream->locked = *params->frames;
-    pulse_unlock();
-    params->result =  *params->frames ? S_OK : AUDCLNT_S_BUFFER_EMPTY;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_release_capture_buffer(void *args)
-{
-    struct release_capture_buffer_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-
-    pulse_lock();
-    if (!stream->locked && params->done)
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_OUT_OF_ORDER;
-        return STATUS_SUCCESS;
-    }
-    if (params->done && stream->locked != params->done)
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_INVALID_SIZE;
-        return STATUS_SUCCESS;
-    }
-    if (params->done)
-    {
-        ACPacket *packet = stream->locked_ptr;
-        stream->locked_ptr = NULL;
-        stream->held_bytes -= stream->period_bytes;
-        if (packet->discont)
-            stream->clock_written += 2 * stream->period_bytes;
-        else
-            stream->clock_written += stream->period_bytes;
-        list_add_tail(&stream->packet_free_head, &packet->entry);
-    }
-    stream->locked = 0;
-    pulse_unlock();
-    params->result = S_OK;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_is_format_supported(void *args)
-{
-    struct is_format_supported_params *params = args;
-    WAVEFORMATEXTENSIBLE in;
-    WAVEFORMATEXTENSIBLE *out;
-    const WAVEFORMATEX *fmt = &in.Format;
-    const BOOLEAN exclusive = params->share == AUDCLNT_SHAREMODE_EXCLUSIVE;
-
-    params->result = S_OK;
-
-    if (!params->fmt_in || (params->share == AUDCLNT_SHAREMODE_SHARED && !params->fmt_out))
-        params->result = E_POINTER;
-    else if (params->share != AUDCLNT_SHAREMODE_SHARED && params->share != AUDCLNT_SHAREMODE_EXCLUSIVE)
-        params->result = E_INVALIDARG;
-    else {
-        memcpy(&in, params->fmt_in, params->fmt_in->wFormatTag == WAVE_FORMAT_EXTENSIBLE ?
-                                    sizeof(in) : sizeof(in.Format));
-
-        if (fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
-            if (fmt->cbSize < sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX))
-                params->result = E_INVALIDARG;
-            else if (fmt->nAvgBytesPerSec == 0 || fmt->nBlockAlign == 0 ||
-                    (in.Samples.wValidBitsPerSample > fmt->wBitsPerSample))
-                params->result = E_INVALIDARG;
-            else if (fmt->nChannels == 0)
-                params->result = AUDCLNT_E_UNSUPPORTED_FORMAT;
-        }
-    }
-
-    if (FAILED(params->result))
-        return STATUS_SUCCESS;
-
-    if (exclusive)
-        out = &in;
-    else {
-        out = params->fmt_out;
-        memcpy(out, fmt, fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE ?
-                         sizeof(*out) : sizeof((*out).Format));
-    }
-
-    switch (fmt->wFormatTag) {
-    case WAVE_FORMAT_EXTENSIBLE: {
-        if ((fmt->cbSize != sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX) &&
-             fmt->cbSize != sizeof(WAVEFORMATEXTENSIBLE)) ||
-             fmt->nBlockAlign != fmt->wBitsPerSample / 8 * fmt->nChannels ||
-             in.Samples.wValidBitsPerSample > fmt->wBitsPerSample ||
-             fmt->nAvgBytesPerSec != fmt->nBlockAlign * fmt->nSamplesPerSec) {
-            params->result = E_INVALIDARG;
-            break;
-        }
-
-        if (exclusive) {
-            UINT32 mask = 0, i, channels = 0;
-
-            if (!(in.dwChannelMask & (SPEAKER_ALL | SPEAKER_RESERVED))) {
-                for (i = 1; !(i & SPEAKER_RESERVED); i <<= 1) {
-                    if (i & in.dwChannelMask) {
-                        mask |= i;
-                        ++channels;
-                    }
-                }
-
-                if (channels != fmt->nChannels || (in.dwChannelMask & ~mask)) {
-                    params->result = AUDCLNT_E_UNSUPPORTED_FORMAT;
-                    break;
-                }
-            } else {
-                params->result = AUDCLNT_E_UNSUPPORTED_FORMAT;
-                break;
-            }
-        }
-
-        if (IsEqualGUID(&in.SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)) {
-            if (fmt->wBitsPerSample != 32) {
-                params->result = E_INVALIDARG;
-                break;
-            }
-
-            if (in.Samples.wValidBitsPerSample != fmt->wBitsPerSample) {
-                params->result = S_FALSE;
-                out->Samples.wValidBitsPerSample = fmt->wBitsPerSample;
-            }
-        } else if (IsEqualGUID(&in.SubFormat, &KSDATAFORMAT_SUBTYPE_PCM)) {
-            if (!fmt->wBitsPerSample || fmt->wBitsPerSample > 32 || fmt->wBitsPerSample % 8) {
-                params->result = E_INVALIDARG;
-                break;
-            }
-
-            if (in.Samples.wValidBitsPerSample != fmt->wBitsPerSample &&
-               !(fmt->wBitsPerSample == 32 &&
-                in.Samples.wValidBitsPerSample == 24)) {
-                params->result = S_FALSE;
-                out->Samples.wValidBitsPerSample = fmt->wBitsPerSample;
-                break;
-            }
-        } else {
-            params->result = AUDCLNT_E_UNSUPPORTED_FORMAT;
-            break;
-        }
-
-        break;
-    }
-    case WAVE_FORMAT_ALAW:
-    case WAVE_FORMAT_MULAW:
-        if (fmt->wBitsPerSample != 8) {
-            params->result = E_INVALIDARG;
-            break;
-        }
-    /* Fall-through */
-    case WAVE_FORMAT_IEEE_FLOAT:
-        if (fmt->wFormatTag == WAVE_FORMAT_IEEE_FLOAT && fmt->wBitsPerSample != 32) {
-            params->result = E_INVALIDARG;
-            break;
-        }
-    /* Fall-through */
-    case WAVE_FORMAT_PCM: {
-        if (fmt->wFormatTag == WAVE_FORMAT_PCM &&
-           (!fmt->wBitsPerSample || fmt->wBitsPerSample > 32 || fmt->wBitsPerSample % 8)) {
-            params->result = E_INVALIDARG;
-            break;
-        }
-
-        if (fmt->nChannels > 2) {
-            params->result = AUDCLNT_E_UNSUPPORTED_FORMAT;
-            break;
-        }
-
-        /* fmt->cbSize, fmt->nBlockAlign and fmt->nAvgBytesPerSec seem to be
-         * ignored, invalid values are happily accepted. */
-        break;
-    }
-    default:
-        params->result = AUDCLNT_E_UNSUPPORTED_FORMAT;
-        break;
-    }
-
-    if (exclusive) { /* This driver does not support exclusive mode. */
-        if (params->result == S_OK)
-            params->result = params->flow == eCapture ?
-                                             AUDCLNT_E_UNSUPPORTED_FORMAT :
-                                             AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED;
-        else if (params->result == S_FALSE)
-            params->result = AUDCLNT_E_UNSUPPORTED_FORMAT;
-    }
-
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_get_mix_format(void *args)
-{
-    struct get_mix_format_params *params = args;
-    struct list *list = (params->flow == eRender) ? &g_phys_speakers : &g_phys_sources;
-    PhysDevice *dev;
-
-    LIST_FOR_EACH_ENTRY(dev, list, PhysDevice, entry) {
-        if (strcmp(params->device, dev->pulse_name))
-            continue;
-
-        *params->fmt = dev->fmt;
-        params->result = S_OK;
-
-        return STATUS_SUCCESS;
-    }
-
-    params->result = E_FAIL;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_get_device_period(void *args)
-{
-    struct get_device_period_params *params = args;
-
-    params->result = get_device_period_helper(params->flow, params->device, params->def_period, params->min_period);
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_get_buffer_size(void *args)
-{
-    struct get_buffer_size_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-
-    params->result = S_OK;
-
-    pulse_lock();
-    if (!pulse_stream_valid(stream))
-        params->result = AUDCLNT_E_DEVICE_INVALIDATED;
-    else
-        *params->frames = stream->bufsize_frames;
-    pulse_unlock();
-
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_get_latency(void *args)
-{
-    struct get_latency_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-    const pa_buffer_attr *attr;
-    REFERENCE_TIME lat;
-
-    pulse_lock();
-    if (!pulse_stream_valid(stream)) {
-        pulse_unlock();
-        params->result = AUDCLNT_E_DEVICE_INVALIDATED;
-        return STATUS_SUCCESS;
-    }
-    attr = pa_stream_get_buffer_attr(stream->stream);
-    if (stream->dataflow == eRender)
-        lat = attr->minreq / pa_frame_size(&stream->ss);
-    else
-        lat = attr->fragsize / pa_frame_size(&stream->ss);
-    *params->latency = (lat * 10000000) / stream->ss.rate + stream->def_period;
-    pulse_unlock();
-    TRACE("Latency: %u ms\n", (unsigned)(*params->latency / 10000));
-    params->result = S_OK;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_get_current_padding(void *args)
-{
-    struct get_current_padding_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-
-    pulse_lock();
-    if (!pulse_stream_valid(stream))
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_DEVICE_INVALIDATED;
-        return STATUS_SUCCESS;
-    }
-
-    if (stream->dataflow == eRender)
-        *params->padding = pulse_render_padding(stream);
-    else
-        *params->padding = pulse_capture_padding(stream);
-    pulse_unlock();
-
-    TRACE("%p Pad: %u ms (%u)\n", stream, muldiv(*params->padding, 1000, stream->ss.rate),
-          *params->padding);
-    params->result = S_OK;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_get_next_packet_size(void *args)
-{
-    struct get_next_packet_size_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-
-    pulse_lock();
-    pulse_capture_padding(stream);
-    if (stream->locked_ptr)
-        *params->frames = stream->period_bytes / pa_frame_size(&stream->ss);
-    else
-        *params->frames = 0;
-    pulse_unlock();
-    params->result = S_OK;
-
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_get_frequency(void *args)
-{
-    struct get_frequency_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-
-    pulse_lock();
-    if (!pulse_stream_valid(stream))
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_DEVICE_INVALIDATED;
-        return STATUS_SUCCESS;
-    }
-
-    *params->freq = stream->ss.rate;
-    if (stream->share == AUDCLNT_SHAREMODE_SHARED)
-        *params->freq *= pa_frame_size(&stream->ss);
-    pulse_unlock();
-    params->result = S_OK;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_get_position(void *args)
-{
-    struct get_position_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-
-    pulse_lock();
-    if (!pulse_stream_valid(stream))
-    {
-        pulse_unlock();
-        params->result = AUDCLNT_E_DEVICE_INVALIDATED;
-        return STATUS_SUCCESS;
-    }
-
-    *params->pos = stream->clock_written - stream->held_bytes;
-
-    if (stream->share == AUDCLNT_SHAREMODE_EXCLUSIVE || params->device)
-        *params->pos /= pa_frame_size(&stream->ss);
-
-    /* Make time never go backwards */
-    if (*params->pos < stream->clock_lastpos)
-        *params->pos = stream->clock_lastpos;
-    else
-        stream->clock_lastpos = *params->pos;
-    pulse_unlock();
-
-    TRACE("%p Position: %u\n", stream, (unsigned)*params->pos);
-
-    if (params->qpctime)
-    {
-        LARGE_INTEGER stamp, freq;
-        NtQueryPerformanceCounter(&stamp, &freq);
-        *params->qpctime = (stamp.QuadPart * (INT64)10000000) / freq.QuadPart;
-    }
-
-    params->result = S_OK;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_set_volumes(void *args)
-{
-    struct set_volumes_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-    unsigned int i;
-
-    for (i = 0; i < stream->ss.channels; i++)
-        stream->vol[i] = params->volumes[i] * params->master_volume * params->session_volumes[i];
-
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_set_event_handle(void *args)
-{
-    struct set_event_handle_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-    HRESULT hr = S_OK;
-
-    pulse_lock();
-    if (!pulse_stream_valid(stream))
-        hr = AUDCLNT_E_DEVICE_INVALIDATED;
-    else if (!(stream->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK))
-        hr = AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED;
-    else if (stream->event)
-        hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
-    else
-        stream->event = params->event;
-    pulse_unlock();
-
-    params->result = hr;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_is_started(void *args)
-{
-    struct is_started_params *params = args;
-    struct pulse_stream *stream = handle_get_stream(params->stream);
-
-    pulse_lock();
-    params->result = pulse_stream_valid(stream) && stream->started ? S_OK : S_FALSE;
-    pulse_unlock();
-
-    return STATUS_SUCCESS;
-}
-
-static BOOL get_device_path(PhysDevice *dev, struct get_prop_value_params *params)
-{
-    const GUID *guid = params->guid;
-    PROPVARIANT *out = params->value;
-    UINT serial_number;
-    char path[128];
-    int len;
-
-    /* As hardly any audio devices have serial numbers, Windows instead
-       appears to use a persistent random number. We emulate this here
-       by instead using the last 8 hex digits of the GUID. */
-    serial_number = (guid->Data4[4] << 24) | (guid->Data4[5] << 16) | (guid->Data4[6] << 8) | guid->Data4[7];
-
-    switch (dev->bus_type) {
-    case phys_device_bus_pci:
-        len = sprintf(path, "{1}.HDAUDIO\\FUNC_01&VEN_%04X&DEV_%04X\\%u&%08X", dev->vendor_id, dev->product_id, dev->index, serial_number);
-        break;
-    case phys_device_bus_usb:
-        len = sprintf(path, "{1}.USB\\VID_%04X&PID_%04X\\%u&%08X", dev->vendor_id, dev->product_id, dev->index, serial_number);
-        break;
-    default:
-        len = sprintf(path, "{1}.ROOT\\MEDIA\\%04u", dev->index);
-        break;
-    }
-
-    if (*params->buffer_size < ++len * sizeof(WCHAR)) {
-        params->result = E_NOT_SUFFICIENT_BUFFER;
-        *params->buffer_size = len * sizeof(WCHAR);
-        return FALSE;
-    }
-
-    out->vt = VT_LPWSTR;
-    out->pwszVal = params->buffer;
-
-    ntdll_umbstowcs(path, len, out->pwszVal, len);
-
-    params->result = S_OK;
-
-    return TRUE;
-}
-
-static NTSTATUS pulse_get_prop_value(void *args)
-{
-    static const GUID PKEY_AudioEndpoint_GUID = {
-        0x1da5d803, 0xd492, 0x4edd, {0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e}
-    };
-    static const PROPERTYKEY devicepath_key = { /* undocumented? - {b3f8fa53-0004-438e-9003-51a46e139bfc},2 */
-        {0xb3f8fa53, 0x0004, 0x438e, {0x90, 0x03, 0x51, 0xa4, 0x6e, 0x13, 0x9b, 0xfc}}, 2
-    };
-    struct get_prop_value_params *params = args;
-    struct list *list = (params->flow == eRender) ? &g_phys_speakers : &g_phys_sources;
-    PhysDevice *dev;
-
-    LIST_FOR_EACH_ENTRY(dev, list, PhysDevice, entry) {
-        if (strcmp(params->device, dev->pulse_name))
-            continue;
-        if (IsEqualPropertyKey(*params->prop, devicepath_key)) {
-            get_device_path(dev, params);
-            return STATUS_SUCCESS;
-        } else if (IsEqualGUID(&params->prop->fmtid, &PKEY_AudioEndpoint_GUID)) {
-            switch (params->prop->pid) {
-            case 0:   /* FormFactor */
-                params->value->vt = VT_UI4;
-                params->value->ulVal = dev->form;
-                params->result = S_OK;
-                return STATUS_SUCCESS;
-            case 3:   /* PhysicalSpeakers */
-                if (!dev->channel_mask)
-                    goto fail;
-                params->value->vt = VT_UI4;
-                params->value->ulVal = dev->channel_mask;
-                params->result = S_OK;
-                return STATUS_SUCCESS;
-            }
-        }
-
-        params->result = E_NOTIMPL;
-        return STATUS_SUCCESS;
-    }
-
-fail:
-    params->result = E_FAIL;
-    return STATUS_SUCCESS;
-}
-
-const unixlib_entry_t __wine_unix_call_funcs[] =
-{
-    pulse_process_attach,
-    pulse_process_detach,
-    pulse_main_loop,
-    pulse_get_endpoint_ids,
-    pulse_create_stream,
-    pulse_release_stream,
-    pulse_start,
-    pulse_stop,
-    pulse_reset,
-    pulse_timer_loop,
-    pulse_get_render_buffer,
-    pulse_release_render_buffer,
-    pulse_get_capture_buffer,
-    pulse_release_capture_buffer,
-    pulse_is_format_supported,
-    pulse_get_mix_format,
-    pulse_get_device_period,
-    pulse_get_buffer_size,
-    pulse_get_latency,
-    pulse_get_current_padding,
-    pulse_get_next_packet_size,
-    pulse_get_frequency,
-    pulse_get_position,
-    pulse_set_volumes,
-    pulse_set_event_handle,
-    pulse_test_connect,
-    pulse_is_started,
-    pulse_get_prop_value,
-    pulse_not_implemented,
-    pulse_not_implemented,
-    pulse_not_implemented,
-    pulse_not_implemented,
-    pulse_not_implemented,
-    pulse_not_implemented,
-};
-
-C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == funcs_count);
-
-#ifdef _WIN64
-
-typedef UINT PTR32;
-
-static NTSTATUS pulse_wow64_main_loop(void *args)
-{
-    struct
-    {
-        PTR32 event;
-    } *params32 = args;
-    struct main_loop_params params =
-    {
-        .event = ULongToHandle(params32->event)
-    };
-    return pulse_main_loop(&params);
-}
-
-static NTSTATUS pulse_wow64_get_endpoint_ids(void *args)
-{
-    struct
-    {
-        EDataFlow flow;
-        PTR32 endpoints;
-        unsigned int size;
-        HRESULT result;
-        unsigned int num;
-        unsigned int default_idx;
-    } *params32 = args;
-    struct get_endpoint_ids_params params =
-    {
-        .flow = params32->flow,
-        .endpoints = ULongToPtr(params32->endpoints),
-        .size = params32->size
-    };
-    pulse_get_endpoint_ids(&params);
-    params32->size = params.size;
-    params32->result = params.result;
-    params32->num = params.num;
-    params32->default_idx = params.default_idx;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_wow64_create_stream(void *args)
-{
-    struct
-    {
-        PTR32 name;
-        PTR32 device;
-        EDataFlow flow;
-        AUDCLNT_SHAREMODE share;
-        DWORD flags;
-        REFERENCE_TIME duration;
-        REFERENCE_TIME period;
-        PTR32 fmt;
-        HRESULT result;
-        PTR32 channel_count;
-        PTR32 stream;
-    } *params32 = args;
-    struct create_stream_params params =
-    {
-        .name = ULongToPtr(params32->name),
-        .device = ULongToPtr(params32->device),
-        .flow = params32->flow,
-        .share = params32->share,
-        .flags = params32->flags,
-        .duration = params32->duration,
-        .period = params32->period,
-        .fmt = ULongToPtr(params32->fmt),
-        .channel_count = ULongToPtr(params32->channel_count),
-        .stream = ULongToPtr(params32->stream)
-    };
-    pulse_create_stream(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_wow64_release_stream(void *args)
-{
-    struct
-    {
-        stream_handle stream;
-        PTR32 timer_thread;
-        HRESULT result;
-    } *params32 = args;
-    struct release_stream_params params =
-    {
-        .stream = params32->stream,
-        .timer_thread = ULongToHandle(params32->timer_thread)
-    };
-    pulse_release_stream(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_wow64_get_render_buffer(void *args)
-{
-    struct
-    {
-        stream_handle stream;
-        UINT32 frames;
-        HRESULT result;
-        PTR32 data;
-    } *params32 = args;
-    BYTE *data = NULL;
-    struct get_render_buffer_params params =
-    {
-        .stream = params32->stream,
-        .frames = params32->frames,
-        .data = &data
-    };
-    pulse_get_render_buffer(&params);
-    params32->result = params.result;
-    *(unsigned int *)ULongToPtr(params32->data) = PtrToUlong(data);
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_wow64_get_capture_buffer(void *args)
-{
-    struct
-    {
-        stream_handle stream;
-        HRESULT result;
-        PTR32 data;
-        PTR32 frames;
-        PTR32 flags;
-        PTR32 devpos;
-        PTR32 qpcpos;
-    } *params32 = args;
-    BYTE *data = NULL;
-    struct get_capture_buffer_params params =
-    {
-        .stream = params32->stream,
-        .data = &data,
-        .frames = ULongToPtr(params32->frames),
-        .flags = ULongToPtr(params32->flags),
-        .devpos = ULongToPtr(params32->devpos),
-        .qpcpos = ULongToPtr(params32->qpcpos)
-    };
-    pulse_get_capture_buffer(&params);
-    params32->result = params.result;
-    *(unsigned int *)ULongToPtr(params32->data) = PtrToUlong(data);
-    return STATUS_SUCCESS;
-};
-
-static NTSTATUS pulse_wow64_is_format_supported(void *args)
-{
-    struct
-    {
-        PTR32 device;
-        EDataFlow flow;
-        AUDCLNT_SHAREMODE share;
-        PTR32 fmt_in;
-        PTR32 fmt_out;
-        HRESULT result;
-    } *params32 = args;
-    struct is_format_supported_params params =
-    {
-        .device = ULongToPtr(params32->device),
-        .flow = params32->flow,
-        .share = params32->share,
-        .fmt_in = ULongToPtr(params32->fmt_in),
-        .fmt_out = ULongToPtr(params32->fmt_out)
-    };
-    pulse_is_format_supported(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_wow64_get_mix_format(void *args)
-{
-    struct
-    {
-        PTR32 device;
-        EDataFlow flow;
-        PTR32 fmt;
-        HRESULT result;
-    } *params32 = args;
-    struct get_mix_format_params params =
-    {
-        .device = ULongToPtr(params32->device),
-        .flow = params32->flow,
-        .fmt = ULongToPtr(params32->fmt),
-    };
-    pulse_get_mix_format(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_wow64_get_device_period(void *args)
-{
-    struct
-    {
-        PTR32 device;
-        EDataFlow flow;
-        HRESULT result;
-        PTR32 def_period;
-        PTR32 min_period;
-    } *params32 = args;
-    struct get_device_period_params params =
-    {
-        .device = ULongToPtr(params32->device),
-        .flow = params32->flow,
-        .def_period = ULongToPtr(params32->def_period),
-        .min_period = ULongToPtr(params32->min_period),
-    };
-    pulse_get_device_period(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_wow64_get_buffer_size(void *args)
-{
-    struct
-    {
-        stream_handle stream;
-        HRESULT result;
-        PTR32 frames;
-    } *params32 = args;
-    struct get_buffer_size_params params =
-    {
-        .stream = params32->stream,
-        .frames = ULongToPtr(params32->frames)
-    };
-    pulse_get_buffer_size(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_wow64_get_latency(void *args)
-{
-    struct
-    {
-        stream_handle stream;
-        HRESULT result;
-        PTR32 latency;
-    } *params32 = args;
-    struct get_latency_params params =
-    {
-        .stream = params32->stream,
-        .latency = ULongToPtr(params32->latency)
-    };
-    pulse_get_latency(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_wow64_get_current_padding(void *args)
-{
-    struct
-    {
-        stream_handle stream;
-        HRESULT result;
-        PTR32 padding;
-    } *params32 = args;
-    struct get_current_padding_params params =
-    {
-        .stream = params32->stream,
-        .padding = ULongToPtr(params32->padding)
-    };
-    pulse_get_current_padding(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_wow64_get_next_packet_size(void *args)
-{
-    struct
-    {
-        stream_handle stream;
-        HRESULT result;
-        PTR32 frames;
-    } *params32 = args;
-    struct get_next_packet_size_params params =
-    {
-        .stream = params32->stream,
-        .frames = ULongToPtr(params32->frames)
-    };
-    pulse_get_next_packet_size(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_wow64_get_frequency(void *args)
-{
-    struct
-    {
-        stream_handle stream;
-        HRESULT result;
-        PTR32 freq;
-    } *params32 = args;
-    struct get_frequency_params params =
-    {
-        .stream = params32->stream,
-        .freq = ULongToPtr(params32->freq)
-    };
-    pulse_get_frequency(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_wow64_get_position(void *args)
-{
-    struct
-    {
-        stream_handle stream;
-        BOOL device;
-        HRESULT result;
-        PTR32 pos;
-        PTR32 qpctime;
-    } *params32 = args;
-    struct get_position_params params =
-    {
-        .stream = params32->stream,
-        .device = params32->device,
-        .pos = ULongToPtr(params32->pos),
-        .qpctime = ULongToPtr(params32->qpctime)
-    };
-    pulse_get_position(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_wow64_set_volumes(void *args)
-{
-    struct
-    {
-        stream_handle stream;
-        float master_volume;
-        PTR32 volumes;
-        PTR32 session_volumes;
-    } *params32 = args;
-    struct set_volumes_params params =
-    {
-        .stream = params32->stream,
-        .master_volume = params32->master_volume,
-        .volumes = ULongToPtr(params32->volumes),
-        .session_volumes = ULongToPtr(params32->session_volumes),
-    };
-    return pulse_set_volumes(&params);
-}
-
-static NTSTATUS pulse_wow64_set_event_handle(void *args)
-{
-    struct
-    {
-        stream_handle stream;
-        PTR32 event;
-        HRESULT result;
-    } *params32 = args;
-    struct set_event_handle_params params =
-    {
-        .stream = params32->stream,
-        .event = ULongToHandle(params32->event)
-    };
-    pulse_set_event_handle(&params);
-    params32->result = params.result;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_wow64_test_connect(void *args)
-{
-    struct
-    {
-        PTR32 name;
-        enum driver_priority priority;
-    } *params32 = args;
-    struct test_connect_params params =
-    {
-        .name = ULongToPtr(params32->name),
-    };
-    pulse_test_connect(&params);
-    params32->priority = params.priority;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS pulse_wow64_get_prop_value(void *args)
-{
-    struct propvariant32
-    {
-        WORD vt;
-        WORD pad1, pad2, pad3;
-        union
-        {
-            ULONG ulVal;
-            PTR32 ptr;
-            ULARGE_INTEGER uhVal;
-        };
-    } *value32;
-    struct
-    {
-        PTR32 device;
-        EDataFlow flow;
-        PTR32 guid;
-        PTR32 prop;
-        HRESULT result;
-        PTR32 value;
-        PTR32 buffer; /* caller allocated buffer to hold value's strings */
-        PTR32 buffer_size;
-    } *params32 = args;
-    PROPVARIANT value;
-    struct get_prop_value_params params =
-    {
-        .device = ULongToPtr(params32->device),
-        .flow = params32->flow,
-        .guid = ULongToPtr(params32->guid),
-        .prop = ULongToPtr(params32->prop),
-        .value = &value,
-        .buffer = ULongToPtr(params32->buffer),
-        .buffer_size = ULongToPtr(params32->buffer_size)
-    };
-    pulse_get_prop_value(&params);
-    params32->result = params.result;
-    if (SUCCEEDED(params.result))
-    {
-        value32 = UlongToPtr(params32->value);
-        value32->vt = value.vt;
-        switch (value.vt)
-        {
-        case VT_UI4:
-            value32->ulVal = value.ulVal;
-            break;
-        case VT_LPWSTR:
-            value32->ptr = params32->buffer;
-            break;
-        default:
-            FIXME("Unhandled vt %04x\n", value.vt);
-        }
-    }
-    return STATUS_SUCCESS;
-}
-
-const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
-{
-    pulse_process_attach,
-    pulse_process_detach,
-    pulse_wow64_main_loop,
-    pulse_wow64_get_endpoint_ids,
-    pulse_wow64_create_stream,
-    pulse_wow64_release_stream,
-    pulse_start,
-    pulse_stop,
-    pulse_reset,
-    pulse_timer_loop,
-    pulse_wow64_get_render_buffer,
-    pulse_release_render_buffer,
-    pulse_wow64_get_capture_buffer,
-    pulse_release_capture_buffer,
-    pulse_wow64_is_format_supported,
-    pulse_wow64_get_mix_format,
-    pulse_wow64_get_device_period,
-    pulse_wow64_get_buffer_size,
-    pulse_wow64_get_latency,
-    pulse_wow64_get_current_padding,
-    pulse_wow64_get_next_packet_size,
-    pulse_wow64_get_frequency,
-    pulse_wow64_get_position,
-    pulse_wow64_set_volumes,
-    pulse_wow64_set_event_handle,
-    pulse_wow64_test_connect,
-    pulse_is_started,
-    pulse_wow64_get_prop_value,
-    pulse_not_implemented,
-    pulse_not_implemented,
-    pulse_not_implemented,
-    pulse_not_implemented,
-    pulse_not_implemented,
-    pulse_not_implemented,
-};
-
-C_ASSERT(ARRAYSIZE(__wine_unix_call_wow64_funcs) == funcs_count);
-
-#endif /* _WIN64 */
diff --git a/dlls/winepulse.drv/winepulse.drv.spec b/dlls/winepulse.drv/winepulse.drv.spec
index 11111111111..11111111111 100644
--- a/dlls/winepulse.drv/winepulse.drv.spec
+++ b/dlls/winepulse.drv/winepulse.drv.spec
@@ -1,6 +1,9 @@
 # MMDevAPI driver functions
-@ stdcall -private get_device_guid(long ptr ptr) get_device_guid
-@ stdcall -private get_device_name_from_guid(ptr ptr ptr) get_device_name_from_guid
+@ stdcall -private GetPriority() AUDDRV_GetPriority
+@ stdcall -private GetEndpointIDs(long ptr ptr ptr ptr) AUDDRV_GetEndpointIDs
+@ stdcall -private GetAudioEndpoint(ptr ptr ptr) AUDDRV_GetAudioEndpoint
+@ stdcall -private GetAudioSessionManager(ptr ptr) AUDDRV_GetAudioSessionManager
+@ stdcall -private GetPropValue(ptr ptr ptr) AUDDRV_GetPropValue
 
 # WinMM driver functions
 @ stdcall -private DriverProc(long long long long long) winealsa.drv.DriverProc
diff --git a/include/Makefile.in b/include/Makefile.in
index 11111111111..11111111111 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -923,6 +923,7 @@ SOURCES = \
 	wine/strmbase.h \
 	wine/svcctl.idl \
 	wine/test.h \
+	wine/unicode.h \
 	wine/unixlib.h \
 	wine/vulkan.h \
 	wine/vulkan_driver.h \
diff --git a/include/Makefile.in.orig b/include/Makefile.in.orig
new file mode 100644
index 11111111111..11111111111
--- /dev/null
+++ b/include/Makefile.in.orig
@@ -0,0 +1,1032 @@
+SOURCES = \
+	accctrl.h \
+	access.idl \
+	aclapi.h \
+	aclui.h \
+	activation.idl \
+	activaut.idl \
+	activdbg.idl \
+	activeds.h \
+	activscp.idl \
+	adserr.h \
+	adshlp.h \
+	advpub.h \
+	af_irda.h \
+	amaudio.h \
+	amsi.idl \
+	amstream.idl \
+	amva.h \
+	amvideo.idl \
+	appcompatapi.h \
+	appmgmt.h \
+	appmodel.h \
+	appnotify.h \
+	asferr.h \
+	asptlb.idl \
+	asyncinfo.idl \
+	asynot.idl \
+	asysta.idl \
+	atlbase.h \
+	atlcom.h \
+	atliface.idl \
+	atlthunk.h \
+	atlwin.h \
+	audevcod.h \
+	audioclient.idl \
+	audiopolicy.idl \
+	audiosessiontypes.h \
+	austream.idl \
+	authz.h \
+	aviriff.h \
+	avrt.h \
+	axcore.idl \
+	axextend.idl \
+	axextendenums.h \
+	basetsd.h \
+	basetyps.h \
+	bcrypt.h \
+	bdaiface.idl \
+	bdaiface_enums.h \
+	bdatypes.h \
+	binres.idl \
+	bits.idl \
+	bits1_5.idl \
+	bits2_0.idl \
+	bits2_5.idl \
+	bits3_0.idl \
+	bits5_0.idl \
+	bitsmsg.h \
+	bluetoothapis.h \
+	bthsdpdef.h \
+	cderr.h \
+	cdosys.idl \
+	cfg.h \
+	cfgmgr32.h \
+	cguid.h \
+	chprst.idl \
+	cierror.h \
+	clusapi.h \
+	cmdbas.idl \
+	cmdpre.idl \
+	cmdprp.idl \
+	cmdstrm.idl \
+	cmdtxt.idl \
+	cmdwpr.idl \
+	cmnquery.idl \
+	codecapi.h \
+	colinf.idl \
+	colordlg.h \
+	colrst.idl \
+	combaseapi.h \
+	comcat.idl \
+	commctrl.h \
+	commctrl.rh \
+	commdlg.h \
+	commoncontrols.idl \
+	compobj.h \
+	comsvcs.idl \
+	concurrencysal.h \
+	config.h.in \
+	consoleapi.h \
+	control.idl \
+	cor.idl \
+	cordebug.idl \
+	corerror.h \
+	corhdr.h \
+	corsym.idl \
+	cpl.h \
+	crtrow.idl \
+	cryptdlg.h \
+	cryptuiapi.h \
+	ctfutb.idl \
+	ctxtcall.idl \
+	custcntl.h \
+	cvconst.h \
+	cvttyp.idl \
+	d2d1.idl \
+	d2d1_1.idl \
+	d2d1_2.idl \
+	d2d1_3.idl \
+	d2d1effectauthor.idl \
+	d2d1effects.idl \
+	d2d1effects_1.idl \
+	d2d1effects_2.idl \
+	d2dbasetypes.h \
+	d2derr.h \
+	d3d.h \
+	d3d10.idl \
+	d3d10_1.idl \
+	d3d10_1shader.h \
+	d3d10effect.h \
+	d3d10misc.h \
+	d3d10sdklayers.idl \
+	d3d10shader.h \
+	d3d11.idl \
+	d3d11_1.idl \
+	d3d11_2.idl \
+	d3d11_3.idl \
+	d3d11_4.idl \
+	d3d11on12.idl \
+	d3d11sdklayers.idl \
+	d3d11shader.h \
+	d3d12.idl \
+	d3d12sdklayers.idl \
+	d3d12shader.idl \
+	d3d12video.idl \
+	d3d8.h \
+	d3d8caps.h \
+	d3d8types.h \
+	d3d9.h \
+	d3d9caps.h \
+	d3d9types.h \
+	d3dcaps.h \
+	d3dcommon.idl \
+	d3dcompiler.h \
+	d3dhal.h \
+	d3dkmdt.h \
+	d3drm.h \
+	d3drmdef.h \
+	d3drmobj.h \
+	d3drmwin.h \
+	d3dtypes.h \
+	d3dukmdt.h \
+	d3dvec.inl \
+	d3dx10.h \
+	d3dx10async.h \
+	d3dx10core.h \
+	d3dx10math.h \
+	d3dx10mesh.h \
+	d3dx10tex.h \
+	d3dx11.h \
+	d3dx11async.h \
+	d3dx11core.idl \
+	d3dx11tex.h \
+	d3dx9.h \
+	d3dx9anim.h \
+	d3dx9core.h \
+	d3dx9effect.h \
+	d3dx9math.h \
+	d3dx9math.inl \
+	d3dx9mesh.h \
+	d3dx9shader.h \
+	d3dx9shape.h \
+	d3dx9tex.h \
+	d3dx9xof.h \
+	davclnt.h \
+	dbccmd.idl \
+	dbcses.idl \
+	dbdsad.idl \
+	dbgeng.h \
+	dbghelp.h \
+	dbinit.idl \
+	dbprop.idl \
+	dbs.idl \
+	dbt.h \
+	dciddi.h \
+	dciman.h \
+	dcommon.idl \
+	dcomp.idl \
+	dcompanimation.idl \
+	dcomptypes.idl \
+	dde.h \
+	dde.rh \
+	ddeml.h \
+	ddk/compstui.h \
+	ddk/csq.h \
+	ddk/d3dkmthk.h \
+	ddk/fltkernel.h \
+	ddk/hidclass.h \
+	ddk/hidpddi.h \
+	ddk/hidpi.h \
+	ddk/hidport.h \
+	ddk/hidsdi.h \
+	ddk/hidtypes.h \
+	ddk/mountmgr.h \
+	ddk/ndis.h \
+	ddk/ntddcdvd.h \
+	ddk/ntddk.h \
+	ddk/ntddser.h \
+	ddk/ntddtape.h \
+	ddk/ntifs.h \
+	ddk/usb.h \
+	ddk/usb100.h \
+	ddk/usb200.h \
+	ddk/usbdlib.h \
+	ddk/usbioctl.h \
+	ddk/usbiodef.h \
+	ddk/wdf.h \
+	ddk/wdfchildlist.h \
+	ddk/wdfdevice.h \
+	ddk/wdfdriver.h \
+	ddk/wdffuncenum.h \
+	ddk/wdfglobals.h \
+	ddk/wdfio.h \
+	ddk/wdfobject.h \
+	ddk/wdftimer.h \
+	ddk/wdftypes.h \
+	ddk/wdm.h \
+	ddk/winddi.h \
+	ddk/winddiui.h \
+	ddk/winsplp.h \
+	ddk/wsk.h \
+	ddraw.h \
+	ddrawgdi.h \
+	ddrawi.h \
+	ddstream.idl \
+	delayloadhandler.h \
+	devenum.idl \
+	devguid.h \
+	devicetopology.idl \
+	devpkey.h \
+	devpropdef.h \
+	dhcpcsdk.h \
+	dhtmldid.h \
+	dhtmled.idl \
+	difxapi.h \
+	digitalv.h \
+	dimm.idl \
+	dinput.h \
+	dinputd.h \
+	directmanipulation.idl \
+	dispdib.h \
+	dispex.idl \
+	dlgs.h \
+	dls1.h \
+	dls2.h \
+	dmdls.h \
+	dmerror.h \
+	dmksctrl.h \
+	dmo.h \
+	dmodshow.idl \
+	dmoreg.h \
+	dmort.h \
+	dmplugin.h \
+	dmusbuff.h \
+	dmusicc.h \
+	dmusicf.h \
+	dmusici.h \
+	dmusics.h \
+	docobj.idl \
+	docobjectservice.idl \
+	documenttarget.idl \
+	downloadmgr.idl \
+	dpaddr.h \
+	dpfilter.h \
+	dplay.h \
+	dplay8.h \
+	dplobby.h \
+	dplobby8.h \
+	dpnathlp.h \
+	driverspecs.h \
+	drmexternals.idl \
+	dsclient.h \
+	dsconf.h \
+	dsgetdc.h \
+	dshow.h \
+	dsound.h \
+	dsrole.h \
+	dvdif.idl \
+	dvdmedia.h \
+	dvoice.h \
+	dwmapi.h \
+	dwrite.idl \
+	dwrite_1.idl \
+	dwrite_2.idl \
+	dwrite_3.idl \
+	dxcore.h \
+	dxcore_interface.h \
+	dxdiag.h \
+	dxerr8.h \
+	dxerr9.h \
+	dxfile.h \
+	dxgi.idl \
+	dxgi1_2.idl \
+	dxgi1_3.idl \
+	dxgi1_4.idl \
+	dxgi1_5.idl \
+	dxgi1_6.idl \
+	dxgicommon.idl \
+	dxgidebug.idl \
+	dxgiformat.idl \
+	dxgitype.idl \
+	dxva.h \
+	dxva2api.idl \
+	dyngraph.idl \
+	endpointvolume.idl \
+	errorrep.h \
+	errors.h \
+	errrec.idl \
+	evcode.h \
+	eventtoken.idl \
+	evntprov.h \
+	evntrace.h \
+	evr.idl \
+	evr9.idl \
+	excpt.h \
+	exdisp.idl \
+	exdispid.h \
+	exposeenums2managed.h \
+	fci.h \
+	fdi.h \
+	featurestagingapi.h \
+	fileapi.h \
+	filter.idl \
+	fltdefs.h \
+	fontsub.h \
+	fusion.idl \
+	gameux.idl \
+	gamingtcui.h \
+	gdiplus.h \
+	gdipluscolor.h \
+	gdipluscolormatrix.h \
+	gdipluseffects.h \
+	gdiplusenums.h \
+	gdiplusflat.h \
+	gdiplusgpstubs.h \
+	gdiplusimaging.h \
+	gdiplusinit.h \
+	gdiplusmem.h \
+	gdiplusmetaheader.h \
+	gdipluspixelformats.h \
+	gdiplustypes.h \
+	getdts.idl \
+	guiddef.h \
+	hidusage.h \
+	highlevelmonitorconfigurationapi.h \
+	hlguids.h \
+	hlink.idl \
+	hrtfapoapi.idl \
+	hstring.idl \
+	htiface.idl \
+	htiframe.idl \
+	htmlhelp.h \
+	http.h \
+	httprequest.idl \
+	httprequestid.h \
+	i_cryptasn1tls.h \
+	iads.idl \
+	icftypes.idl \
+	icm.h \
+	icmpapi.h \
+	icodecapi.idl \
+	idispids.h \
+	ieautomation.idl \
+	iextag.idl \
+	ifdef.h \
+	ifmib.h \
+	iimgctx.idl \
+	imagehlp.h \
+	ime.h \
+	imm.h \
+	immdev.h \
+	imnact.idl \
+	imnxport.idl \
+	in6addr.h \
+	inaddr.h \
+	indexsrv.idl \
+	initguid.h \
+	inputscope.idl \
+	inseng.idl \
+	inspectable.idl \
+	interactioncontext.h \
+	intshcut.h \
+	ioringapi.h \
+	ip2string.h \
+	ipexport.h \
+	iphlpapi.h \
+	ipifcons.h \
+	ipmib.h \
+	iprtrmib.h \
+	iptypes.h \
+	isguids.h \
+	ivectorchangedeventargs.idl \
+	kbd.h \
+	knownfolders.h \
+	ks.h \
+	ksguid.h \
+	ksmedia.h \
+	ksuuids.h \
+	libloaderapi.h \
+	lm.h \
+	lmaccess.h \
+	lmapibuf.h \
+	lmat.h \
+	lmbrowsr.h \
+	lmcons.h \
+	lmerr.h \
+	lmjoin.h \
+	lmmsg.h \
+	lmserver.h \
+	lmshare.h \
+	lmstats.h \
+	lmuse.h \
+	lmuseflg.h \
+	lmwksta.h \
+	loadperf.h \
+	lowlevelmonitorconfigurationapi.h \
+	lzexpand.h \
+	mapi.h \
+	mapicode.h \
+	mapidefs.h \
+	mapiform.h \
+	mapiguid.h \
+	mapitags.h \
+	mapiutil.h \
+	mapival.h \
+	mapix.h \
+	mciavi.h \
+	mcx.h \
+	mediaerr.h \
+	mediaobj.idl \
+	medparam.idl \
+	memoryapi.h \
+	metahost.idl \
+	mfapi.h \
+	mfd3d12.idl \
+	mferror.h \
+	mfidl.idl \
+	mfmediaengine.idl \
+	mfobjects.idl \
+	mfplay.idl \
+	mfreadwrite.idl \
+	mftransform.idl \
+	midles.h \
+	mimeinfo.idl \
+	mimeole.idl \
+	minidumpapiset.h \
+	minmax.h \
+	minschannel.h \
+	mlang.idl \
+	mmc.idl \
+	mmddk.h \
+	mmdeviceapi.idl \
+	mmreg.h \
+	mmstream.idl \
+	mmsystem.h \
+	mpegtype.idl \
+	mprapi.h \
+	mprerror.h \
+	msacm.h \
+	msacmdlg.h \
+	msacmdrv.h \
+	msado15_backcompat.idl \
+	msasn1.h \
+	mscat.h \
+	mscoree.idl \
+	msctf.idl \
+	msdadc.idl \
+	msdaguid.h \
+	msdasc.idl \
+	msdasql.h \
+	mshtmcid.h \
+	mshtmdid.h \
+	mshtmhst.idl \
+	mshtml.idl \
+	msi.h \
+	msidefs.h \
+	msident.idl \
+	msinkaut.idl \
+	msiquery.h \
+	msopc.idl \
+	mssip.h \
+	msstkppg.h \
+	mstask.idl \
+	mstcpip.h \
+	msvcrt/assert.h \
+	msvcrt/complex.h \
+	msvcrt/conio.h \
+	msvcrt/corecrt.h \
+	msvcrt/corecrt_io.h \
+	msvcrt/corecrt_malloc.h \
+	msvcrt/corecrt_startup.h \
+	msvcrt/corecrt_stdio_config.h \
+	msvcrt/corecrt_wctype.h \
+	msvcrt/corecrt_wdirect.h \
+	msvcrt/corecrt_wio.h \
+	msvcrt/corecrt_wprocess.h \
+	msvcrt/corecrt_wstdio.h \
+	msvcrt/corecrt_wstdlib.h \
+	msvcrt/corecrt_wstring.h \
+	msvcrt/corecrt_wtime.h \
+	msvcrt/crtdbg.h \
+	msvcrt/crtdefs.h \
+	msvcrt/ctype.h \
+	msvcrt/direct.h \
+	msvcrt/dirent.h \
+	msvcrt/dos.h \
+	msvcrt/eh.h \
+	msvcrt/errno.h \
+	msvcrt/fcntl.h \
+	msvcrt/fenv.h \
+	msvcrt/float.h \
+	msvcrt/fpieee.h \
+	msvcrt/intrin.h \
+	msvcrt/inttypes.h \
+	msvcrt/io.h \
+	msvcrt/limits.h \
+	msvcrt/locale.h \
+	msvcrt/malloc.h \
+	msvcrt/math.h \
+	msvcrt/mbctype.h \
+	msvcrt/mbstring.h \
+	msvcrt/memory.h \
+	msvcrt/process.h \
+	msvcrt/search.h \
+	msvcrt/setjmp.h \
+	msvcrt/share.h \
+	msvcrt/signal.h \
+	msvcrt/stdarg.h \
+	msvcrt/stdbool.h \
+	msvcrt/stddef.h \
+	msvcrt/stdint.h \
+	msvcrt/stdio.h \
+	msvcrt/stdlib.h \
+	msvcrt/string.h \
+	msvcrt/sys/locking.h \
+	msvcrt/sys/stat.h \
+	msvcrt/sys/timeb.h \
+	msvcrt/sys/types.h \
+	msvcrt/sys/unistd.h \
+	msvcrt/sys/utime.h \
+	msvcrt/time.h \
+	msvcrt/uchar.h \
+	msvcrt/unistd.h \
+	msvcrt/vadefs.h \
+	msvcrt/wchar.h \
+	msvcrt/wctype.h \
+	mswsock.h \
+	msxml.idl \
+	msxml2.idl \
+	msxml2did.h \
+	msxml6.idl \
+	msxml6did.h \
+	msxmldid.h \
+	mtxdm.h \
+	mulres.idl \
+	multimon.h \
+	namespaceapi.h \
+	natupnp.idl \
+	nb30.h \
+	ncrypt.h \
+	ndisguid.h \
+	ndrtypes.h \
+	netcfgx.idl \
+	netcon.idl \
+	netevent.h \
+	netfw.idl \
+	netioapi.h \
+	netiodef.h \
+	netlistmgr.idl \
+	newdev.h \
+	nldef.h \
+	npapi.h \
+	nserror.h \
+	nspapi.h \
+	ntddcdrm.h \
+	ntddkbd.h \
+	ntddmou.h \
+	ntddndis.h \
+	ntddscsi.h \
+	ntddstor.h \
+	ntddvdeo.h \
+	ntdef.h \
+	ntdsapi.h \
+	ntgdi.h \
+	ntifs.h \
+	ntioring_x.h \
+	ntlsa.h \
+	ntquery.h \
+	ntsecapi.h \
+	ntsecpkg.h \
+	ntstatus.h \
+	ntuser.h \
+	oaidl.idl \
+	objbase.h \
+	objectarray.idl \
+	objidl.idl \
+	objidlbase.idl \
+	objsafe.idl \
+	objsel.h \
+	ocidl.idl \
+	ocmm.idl \
+	odbcinst.h \
+	ole2.h \
+	ole2ver.h \
+	oleacc.idl \
+	oleauto.h \
+	olectl.h \
+	oledb.idl \
+	oledberr.h \
+	oledlg.h \
+	oleidl.idl \
+	opcbase.idl \
+	opcobjectmodel.idl \
+	opcparturi.idl \
+	opnrst.idl \
+	optary.idl \
+	patchapi.h \
+	pathcch.h \
+	pdh.h \
+	pdhmsg.h \
+	perflib.h \
+	perhist.idl \
+	physicalmonitorenumerationapi.h \
+	pktdef.h \
+	poppack.h \
+	powrprof.h \
+	prntvpt.h \
+	processthreadsapi.h \
+	profinfo.h \
+	proofofpossessioncookieinfo.idl \
+	propidl.idl \
+	propkey.h \
+	propkeydef.h \
+	propsys.idl \
+	propvarutil.h \
+	prsht.h \
+	psapi.h \
+	pshpack1.h \
+	pshpack2.h \
+	pshpack4.h \
+	pshpack8.h \
+	pstore.idl \
+	qedit.idl \
+	qos2.h \
+	ras.h \
+	rasdlg.h \
+	raserror.h \
+	realtimeapiset.h \
+	reason.h \
+	regstr.h \
+	relogger.idl \
+	restartmanager.h \
+	restrictederrorinfo.idl \
+	richedit.h \
+	richole.idl \
+	rmxfguid.h \
+	rmxftmpl.x \
+	roapi.h \
+	roerrorapi.h \
+	rometadataresolution.h \
+	roparameterizediid.idl \
+	row.idl \
+	rowchg.idl \
+	rowpos.idl \
+	rowpsc.idl \
+	rpc.h \
+	rpcasync.h \
+	rpcdce.h \
+	rpcdcep.h \
+	rpcndr.h \
+	rpcnterr.h \
+	rpcproxy.h \
+	rpcsal.h \
+	rstbas.idl \
+	rstchg.idl \
+	rstinf.idl \
+	rstloc.idl \
+	rstnot.idl \
+	rstupd.idl \
+	rtutils.h \
+	rtworkq.idl \
+	sal.h \
+	sapi.idl \
+	sapiaut.idl \
+	sapiddk.idl \
+	scarderr.h \
+	schannel.h \
+	schemadef.h \
+	schnlsp.h \
+	sddl.h \
+	sdkddkver.h \
+	secext.h \
+	security.h \
+	sensapi.h \
+	sensevts.idl \
+	servprov.idl \
+	sesprp.idl \
+	setupapi.h \
+	sfc.h \
+	shdeprecated.idl \
+	shdispid.h \
+	shellapi.h \
+	shellscalingapi.h \
+	shimgdata.idl \
+	shldisp.idl \
+	shlguid.h \
+	shlobj.h \
+	shlwapi.h \
+	shobjidl.idl \
+	shobjidl_core.idl \
+	shtypes.idl \
+	sipbase.h \
+	slerror.h \
+	slpublic.h \
+	snmp.h \
+	socketapi.h \
+	softpub.h \
+	spatialaudioclient.idl \
+	specstrings.h \
+	specstrings_strict.h \
+	sperror.h \
+	sql.h \
+	sqlext.h \
+	sqltypes.h \
+	sqlucode.h \
+	srcrst.idl \
+	srrestoreptapi.h \
+	sspi.h \
+	stamp-h.in \
+	stdole32.idl \
+	stgprop.h \
+	sti.h \
+	storage.h \
+	strmif.idl \
+	strongname.h \
+	strsafe.h \
+	structuredquerycondition.idl \
+	svcguid.h \
+	svrapi.h \
+	synchapi.h \
+	systemmediatransportcontrolsinterop.idl \
+	t2embapi.h \
+	tapi.h \
+	taskschd.idl \
+	tbs.h \
+	tchar.h \
+	tcpestats.h \
+	tcpmib.h \
+	textserv.h \
+	textstor.idl \
+	threadpoolapiset.h \
+	thumbcache.idl \
+	timezoneapi.h \
+	tlhelp32.h \
+	tlogstg.idl \
+	tmschema.h \
+	tom.idl \
+	tpcshrd.h \
+	traffic.h \
+	transact.idl \
+	trnjoi.idl \
+	trnlcl.idl \
+	trnobj.idl \
+	twain.h \
+	txcoord.idl \
+	txdtc.idl \
+	udpmib.h \
+	uianimation.idl \
+	uiautomation.h \
+	uiautomationclient.idl \
+	uiautomationcore.idl \
+	uiautomationcoreapi.h \
+	uiribbon.idl \
+	uiviewsettingsinterop.idl \
+	unexposeenums2managed.h \
+	unknwn.idl \
+	urlhist.idl \
+	urlmon.idl \
+	userenv.h \
+	usp10.h \
+	uuids.h \
+	uxtheme.h \
+	vdmdbg.h \
+	ver.h \
+	verrsrc.h \
+	vfw.h \
+	vfwmsgs.h \
+	videoacc.idl \
+	virtdisk.h \
+	vmr9.idl \
+	vmrender.idl \
+	vsbackup.idl \
+	vss.idl \
+	vsstyle.h \
+	vssym32.h \
+	vswriter.idl \
+	wbemcli.idl \
+	wbemdisp.idl \
+	wbemprov.idl \
+	wct.h \
+	wdbgexts.h \
+	weakreference.idl \
+	webservices.h \
+	werapi.h \
+	wfext.h \
+	wia.h \
+	wia_lh.idl \
+	wia_xp.idl \
+	wiadef.h \
+	wimgapi.h \
+	winapifamily.h \
+	winbase.h \
+	winber.h \
+	wincodec.idl \
+	wincodecsdk.idl \
+	wincon.h \
+	wincontypes.h \
+	wincred.h \
+	wincrypt.h \
+	windef.h \
+	windns.h \
+	windot11.h \
+	windows.applicationmodel.core.idl \
+	windows.applicationmodel.idl \
+	windows.devices.bluetooth.idl \
+	windows.devices.enumeration.idl \
+	windows.devices.geolocation.idl \
+	windows.devices.haptics.idl \
+	windows.devices.power.idl \
+	windows.devices.radios.idl \
+	windows.devices.usb.idl \
+	windows.foundation.collections.idl \
+	windows.foundation.idl \
+	windows.foundation.metadata.idl \
+	windows.foundation.numerics.idl \
+	windows.gaming.input.custom.idl \
+	windows.gaming.input.forcefeedback.idl \
+	windows.gaming.input.idl \
+	windows.gaming.ui.idl \
+	windows.globalization.idl \
+	windows.graphics.capture.idl \
+	windows.graphics.capture.interop.idl \
+	windows.graphics.directx.direct3d11.idl \
+	windows.graphics.directx.idl \
+	windows.graphics.effects.idl \
+	windows.graphics.holographic.idl \
+	windows.h \
+	windows.management.deployment.idl \
+	windows.media.capture.idl \
+	windows.media.closedcaptioning.idl \
+	windows.media.devices.idl \
+	windows.media.effects.idl \
+	windows.media.idl \
+	windows.media.render.idl \
+	windows.media.speechrecognition.idl \
+	windows.media.speechsynthesis.idl \
+	windows.networking.connectivity.idl \
+	windows.networking.idl \
+	windows.perception.spatial.idl \
+	windows.perception.spatial.surfaces.idl \
+	windows.security.credentials.idl \
+	windows.security.credentials.ui.idl \
+	windows.security.cryptography.idl \
+	windows.security.isolation.idl \
+	windows.storage.fileproperties.idl \
+	windows.storage.idl \
+	windows.storage.search.idl \
+	windows.storage.streams.idl \
+	windows.system.idl \
+	windows.system.power.idl \
+	windows.system.profile.systemmanufacturers.idl \
+	windows.system.threading.idl \
+	windows.system.userprofile.idl \
+	windows.ui.composition.idl \
+	windows.ui.composition.interop.idl \
+	windows.ui.core.idl \
+	windows.ui.idl \
+	windows.ui.viewmanagement.idl \
+	windows.ui.xaml.hosting.desktopwindowxamlsource.idl \
+	windowscontracts.idl \
+	windowsx.h \
+	wine/afd.h \
+	wine/asm.h \
+	wine/atsvc.idl \
+	wine/condrv.h \
+	wine/dcetypes.idl \
+	wine/debug.h \
+	wine/dplaysp.h \
+	wine/epm.idl \
+	wine/exception.h \
+	wine/fil_data.idl \
+	wine/gdi_driver.h \
+	wine/glu.h \
+	wine/heap.h \
+	wine/hid.h \
+	wine/http.h \
+	wine/iaccessible2.idl \
+	wine/irot.idl \
+	wine/irpcss.idl \
+	wine/itss.idl \
+	wine/list.h \
+	wine/mfinternal.idl \
+	wine/mmsystem16.h \
+	wine/mscvpdb.h \
+	wine/mssign.h \
+	wine/nsi.h \
+	wine/orpc.idl \
+	wine/plugplay.idl \
+	wine/rbtree.h \
+	wine/schrpc.idl \
+	wine/server.h \
+	wine/server_protocol.h \
+	wine/strmbase.h \
+	wine/svcctl.idl \
+	wine/test.h \
+	wine/unixlib.h \
+	wine/vulkan.h \
+	wine/vulkan_driver.h \
+	wine/wgl.h \
+	wine/wgl_driver.h \
+	wine/winbase16.h \
+	wine/windef16.h \
+	wine/wine_common_ver.rc \
+	wine/wined3d.h \
+	wine/winedxgi.idl \
+	wine/wingdi16.h \
+	wine/winnet16.h \
+	wine/winuser16.h \
+	winerror.h \
+	winevt.h \
+	wingdi.h \
+	winhttp.h \
+	wininet.h \
+	winineti.h \
+	winioctl.h \
+	winldap.h \
+	winnetwk.h \
+	winnls.h \
+	winnls32.h \
+	winnt.h \
+	winnt.rh \
+	winperf.h \
+	winppi.h \
+	winreg.h \
+	winresrc.h \
+	winsafer.h \
+	winscard.h \
+	winsmcrd.h \
+	winsnmp.h \
+	winsock.h \
+	winsock2.h \
+	winspool.h \
+	winstring.h \
+	winsvc.h \
+	winsxs.idl \
+	wintab.h \
+	wintabx.h \
+	winternl.h \
+	wintrust.h \
+	winusb.h \
+	winuser.h \
+	winuser.rh \
+	winver.h \
+	wlanapi.h \
+	wldp.h \
+	wmcodecdsp.idl \
+	wmdrmsdk.idl \
+	wmistr.h \
+	wmium.h \
+	wmiutils.idl \
+	wmp.idl \
+	wmpids.h \
+	wmprealestate.idl \
+	wmpservices.idl \
+	wmsbuffer.idl \
+	wmsdk.h \
+	wmsdkidl.idl \
+	wmsecure.idl \
+	wnaspi32.h \
+	wofapi.h \
+	wownt16.h \
+	wownt32.h \
+	wpcapi.idl \
+	ws2def.h \
+	ws2ipdef.h \
+	ws2spi.h \
+	ws2tcpip.h \
+	wsdapi.h \
+	wsdbase.idl \
+	wsddisco.idl \
+	wsdtypes.h \
+	wsdutil.h \
+	wsdxml.idl \
+	wsdxmldom.h \
+	wshisotp.h \
+	wsipx.h \
+	wsnwlink.h \
+	wspiapi.h \
+	wtsapi32.h \
+	wtypes.idl \
+	wuapi.idl \
+	x3daudio.h \
+	xact.h \
+	xact2wb.h \
+	xact3.h \
+	xact3wb.h \
+	xamlom.idl \
+	xapo.idl \
+	xapofx.h \
+	xaudio2.idl \
+	xaudio2fx.idl \
+	xcmc.h \
+	xinput.h \
+	xmldom.h \
+	xmldom.idl \
+	xmldomdid.h \
+	xmldso.idl \
+	xmldsodid.h \
+	xmllite.idl \
+	xpsobjectmodel.idl \
+	xpsobjectmodel_1.idl \
+	zmouse.h
diff --git a/include/wine/test.h b/include/wine/test.h
index 11111111111..11111111111 100644
--- a/include/wine/test.h
+++ b/include/wine/test.h
@@ -28,6 +28,13 @@
 #include <winbase.h>
 #include <wine/debug.h>
 
+#ifdef __WINE_CONFIG_H
+#error config.h should not be used in Wine tests
+#endif
+#ifdef __WINE_WINE_UNICODE_H
+#error wine/unicode.h should not be used in Wine tests
+#endif
+
 #ifndef INVALID_FILE_ATTRIBUTES
 #define INVALID_FILE_ATTRIBUTES  (~0u)
 #endif
diff --git a/include/wine/unicode.h b/include/wine/unicode.h
new file mode 100644
index 11111111111..11111111111
--- /dev/null
+++ b/include/wine/unicode.h
@@ -0,0 +1,178 @@
+/*
+ * Wine internal Unicode definitions
+ *
+ * Copyright 2000 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep install
+#endif
+
+#ifndef __WINE_WINE_UNICODE_H
+#define __WINE_WINE_UNICODE_H
+
+#include <stdarg.h>
+
+#include <windef.h>
+#include <winbase.h>
+#include <winnls.h>
+#include <winternl.h>
+
+#ifdef __WINE_USE_MSVCRT
+#error This file should not be used with msvcrt headers
+#endif
+
+#ifndef WINE_UNICODE_INLINE
+#define WINE_UNICODE_INLINE static FORCEINLINE
+#endif
+
+WINE_UNICODE_INLINE WCHAR tolowerW( WCHAR ch )
+{
+    return RtlDowncaseUnicodeChar( ch );
+}
+
+WINE_UNICODE_INLINE WCHAR toupperW( WCHAR ch )
+{
+    return RtlUpcaseUnicodeChar( ch );
+}
+
+WINE_UNICODE_INLINE int isspaceW( WCHAR wc )
+{
+    unsigned short type;
+    GetStringTypeW( CT_CTYPE1, &wc, 1, &type );
+    return type & C1_SPACE;
+}
+
+WINE_UNICODE_INLINE unsigned int strlenW( const WCHAR *str )
+{
+    const WCHAR *s = str;
+    while (*s) s++;
+    return s - str;
+}
+
+WINE_UNICODE_INLINE WCHAR *strcpyW( WCHAR *dst, const WCHAR *src )
+{
+    WCHAR *p = dst;
+    while ((*p++ = *src++));
+    return dst;
+}
+
+WINE_UNICODE_INLINE WCHAR *strcatW( WCHAR *dst, const WCHAR *src )
+{
+    strcpyW( dst + strlenW(dst), src );
+    return dst;
+}
+
+WINE_UNICODE_INLINE WCHAR *strrchrW( const WCHAR *str, WCHAR ch )
+{
+    WCHAR *ret = NULL;
+    do { if (*str == ch) ret = (WCHAR *)(ULONG_PTR)str; } while (*str++);
+    return ret;
+}
+
+WINE_UNICODE_INLINE int strcmpiW( const WCHAR *str1, const WCHAR *str2 )
+{
+    for (;;)
+    {
+        int ret = tolowerW(*str1) - tolowerW(*str2);
+        if (ret || !*str1) return ret;
+        str1++;
+        str2++;
+    }
+}
+
+WINE_UNICODE_INLINE int strncmpiW( const WCHAR *str1, const WCHAR *str2, int n )
+{
+    int ret = 0;
+    for ( ; n > 0; n--, str1++, str2++)
+        if ((ret = tolowerW(*str1) - tolowerW(*str2)) || !*str1) break;
+    return ret;
+}
+
+WINE_UNICODE_INLINE LONG strtolW( LPCWSTR s, LPWSTR *end, INT base )
+{
+    BOOL negative = FALSE, empty = TRUE;
+    LONG ret = 0;
+
+    if (base < 0 || base == 1 || base > 36) return 0;
+    if (end) *end = (WCHAR *)s;
+    while (isspaceW(*s)) s++;
+
+    if (*s == '-')
+    {
+        negative = TRUE;
+        s++;
+    }
+    else if (*s == '+') s++;
+
+    if ((base == 0 || base == 16) && s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))
+    {
+        base = 16;
+        s += 2;
+    }
+    if (base == 0) base = s[0] != '0' ? 10 : 8;
+
+    while (*s)
+    {
+        int v;
+
+        if ('0' <= *s && *s <= '9') v = *s - '0';
+        else if ('A' <= *s && *s <= 'Z') v = *s - 'A' + 10;
+        else if ('a' <= *s && *s <= 'z') v = *s - 'a' + 10;
+        else break;
+        if (v >= base) break;
+        if (negative) v = -v;
+        s++;
+        empty = FALSE;
+
+        if (!negative && (ret > MAXLONG / base || ret * base > MAXLONG - v))
+            ret = MAXLONG;
+        else if (negative && (ret < (LONG)MINLONG / base || ret * base < (LONG)(MINLONG - v)))
+            ret = MINLONG;
+        else
+            ret = ret * base + v;
+    }
+
+    if (end && !empty) *end = (WCHAR *)s;
+    return ret;
+}
+
+NTSYSAPI int __cdecl _vsnwprintf(WCHAR*,size_t,const WCHAR*,__ms_va_list);
+
+static inline int WINAPIV snprintfW( WCHAR *str, size_t len, const WCHAR *format, ...)
+{
+    int retval;
+    __ms_va_list valist;
+    __ms_va_start(valist, format);
+    retval = _vsnwprintf(str, len, format, valist);
+    __ms_va_end(valist);
+    return retval;
+}
+
+static inline int WINAPIV sprintfW( WCHAR *str, const WCHAR *format, ...)
+{
+    int retval;
+    __ms_va_list valist;
+    __ms_va_start(valist, format);
+    retval = _vsnwprintf(str, MAXLONG, format, valist);
+    __ms_va_end(valist);
+    return retval;
+}
+
+#undef WINE_UNICODE_INLINE
+
+#endif  /* __WINE_WINE_UNICODE_H */
diff --git a/tools/makedep.c b/tools/makedep.c
index 11111111111..11111111111 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -201,6 +201,7 @@ struct makefile
     const char     *staticlib;
     const char     *importlib;
     const char     *unixlib;
+    int             use_msvcrt;
     int             data_only;
     int             is_win16;
     int             is_exe;
@@ -605,17 +606,6 @@ static int is_multiarch( unsigned int arch )
 }
 
 
-/*******************************************************************
- *         is_using_msvcrt
- *
- * Check if the files of a makefile use msvcrt by default.
- */
-static int is_using_msvcrt( struct makefile *make )
-{
-    return make->module || make->testdll;
-}
-
-
 /*******************************************************************
  *         arch_module_name
  */
@@ -874,7 +864,7 @@ static struct incl_file *add_generated_source( struct makefile *make, const char
     file->basename = xstrdup( filename ? filename : name );
     file->filename = obj_dir_path( make, file->basename );
     file->file->flags = FLAG_GENERATED;
-    file->use_msvcrt = is_using_msvcrt( make );
+    file->use_msvcrt = make->use_msvcrt;
     list_add_tail( &make->sources, &file->entry );
     if (make == include_makefile)
     {
@@ -1648,7 +1638,7 @@ static struct incl_file *add_src_file( struct makefile *make, const char *name,
     memset( file, 0, sizeof(*file) );
     file->name = xstrdup(name);
     file->arch = arch;
-    file->use_msvcrt = is_using_msvcrt( make );
+    file->use_msvcrt = make->use_msvcrt;
     file->is_external = !!make->extlib;
     list_add_tail( &make->sources, &file->entry );
     if (make == include_makefile)
@@ -1846,12 +1836,13 @@ static void add_generated_sources( struct makefile *make )
     unsigned int i, arch;
     struct incl_file *source, *next, *file, *dlldata = NULL;
     struct strarray objs = get_expanded_make_var_array( make, "EXTRA_OBJS" );
+    int multiarch = archs.count > 1 && make->use_msvcrt;
 
     LIST_FOR_EACH_ENTRY_SAFE( source, next, &make->sources, struct incl_file, entry )
     {
         for (arch = 0; arch < archs.count; arch++)
         {
-            if (!is_multiarch( arch )) continue;
+            if (!arch != !multiarch) continue;
             if (source->file->flags & FLAG_IDL_CLIENT)
             {
                 file = add_generated_source( make, replace_extension( source->name, ".idl", "_c.c" ), NULL, arch );
@@ -1970,7 +1961,7 @@ static void add_generated_sources( struct makefile *make )
     {
         for (arch = 0; arch < archs.count; arch++)
         {
-            if (!is_multiarch( arch )) continue;
+            if (!arch != !multiarch) continue;
             file = add_generated_source( make, "testlist.o", "testlist.c", arch );
             add_dependency( file->file, "wine/test.h", INCL_NORMAL );
             add_all_includes( make, file, file->file );
@@ -2224,6 +2215,7 @@ static int is_crt_module( const char *file )
  */
 static const char *get_default_crt( const struct makefile *make )
 {
+    if (!make->use_msvcrt) return NULL;
     if (make->module && is_crt_module( make->module )) return NULL;  /* don't add crt import to crt dlls */
     return !make->testdll && (!make->staticlib || make->extlib) ? "ucrtbase" : "msvcrt";
 }
@@ -2380,7 +2372,6 @@ static struct strarray get_source_defines( struct makefile *make, struct incl_fi
         strarray_add( &ret, strmake( "-I%s", root_src_dir_path( "include/msvcrt" )));
         for (i = 0; i < make->include_paths.count; i++)
             strarray_add( &ret, strmake( "-I%s", make->include_paths.str[i] ));
-        strarray_add( &ret, get_crt_define( make ));
     }
     strarray_addall( &ret, make->define_args );
     strarray_addall( &ret, get_expanded_file_local_var( make, obj, "EXTRADEFS" ));
@@ -2440,9 +2431,7 @@ static void output_winegcc_command( struct makefile *make, unsigned int arch )
         output_filename( tools_path( make, "winebuild" ));
     }
     output_filenames( target_flags[arch] );
-    if (arch) return;
-    output_filename( "-mno-cygwin" );
-    output_filenames( lddll_flags );
+    if (!arch) output_filenames( lddll_flags );
 }
 
 
@@ -2734,13 +2723,13 @@ static void output_source_asm_one_arch( struct makefile *make, struct incl_file
     if (arch)
     {
         if (source->file->flags & FLAG_C_UNIX) return;
-        if (!is_using_msvcrt( make ) && !make->staticlib && !(source->file->flags & FLAG_C_IMPLIB)) return;
+        if (!make->use_msvcrt && !make->staticlib && !(source->file->flags & FLAG_C_IMPLIB)) return;
     }
     else if (source->file->flags & FLAG_C_UNIX)
     {
         if (!*dll_ext) return;
     }
-    else if (archs.count > 1 && is_using_msvcrt( make ) &&
+    else if (archs.count > 1 && make->use_msvcrt &&
              !(source->file->flags & FLAG_C_IMPLIB) &&
              (!make->staticlib || make->extlib)) return;
 
@@ -2945,6 +2934,7 @@ static void output_source_idl( struct makefile *make, struct incl_file *source,
     struct strarray multiarch_targets[MAX_ARCHS] = { empty_strarray };
     const char *dest;
     unsigned int i, arch;
+    int multiarch;
 
     if (find_include_file( make, strmake( "%s.h", obj ))) source->file->flags |= FLAG_IDL_HEADER;
     if (!source->file->flags) return;
@@ -2968,9 +2958,10 @@ static void output_source_idl( struct makefile *make, struct incl_file *source,
     for (i = 0; i < ARRAY_SIZE(idl_outputs); i++)
     {
         if (!(source->file->flags & idl_outputs[i].flag)) continue;
+        multiarch = (make->use_msvcrt && archs.count > 1);
         for (arch = 0; arch < archs.count; arch++)
         {
-            if (!is_multiarch( arch )) continue;
+            if (!arch != !multiarch) continue;
             if (make->disabled[arch]) continue;
             dest = strmake( "%s%s%s", arch_dirs[arch], obj, idl_outputs[i].ext );
             if (!find_src_file( make, dest )) strarray_add( &make->clean_files, dest );
@@ -3292,13 +3283,13 @@ static void output_source_one_arch( struct makefile *make, struct incl_file *sou
     if (arch)
     {
         if (source->file->flags & FLAG_C_UNIX) return;
-        if (!is_using_msvcrt( make ) && !make->staticlib && !(source->file->flags & FLAG_C_IMPLIB)) return;
+        if (!make->use_msvcrt && !make->staticlib && !(source->file->flags & FLAG_C_IMPLIB)) return;
     }
     else if (source->file->flags & FLAG_C_UNIX)
     {
         if (!unix_lib_supported) return;
     }
-    else if (archs.count > 1 && is_using_msvcrt( make ))
+    else if (archs.count > 1 && make->use_msvcrt)
     {
         if (!so_dll_supported) return;
         if (!(source->file->flags & FLAG_C_IMPLIB) && (!make->staticlib || make->extlib)) return;
@@ -3497,6 +3488,12 @@ static void output_module( struct makefile *make, unsigned int arch )
         strarray_addall( &all_libs, add_import_libs( make, &dep_libs, default_imports, IMPORT_TYPE_DEFAULT, arch ) );
         if (!arch) strarray_addall( &all_libs, libs );
 
+        if (!make->use_msvcrt)
+        {
+            strarray_addall( &all_libs, get_expanded_make_var_array( make, "UNIX_LIBS" ));
+            strarray_addall( &all_libs, libs );
+        }
+
         if (delay_load_flags[arch])
         {
             for (i = 0; i < make->delayimports.count; i++)
@@ -3690,7 +3687,7 @@ static void output_test_module( struct makefile *make, unsigned int arch )
     output( ": %s", obj_dir_path( make, testmodule ));
     if (parent)
     {
-        char *parent_module = arch_module_name( make->testdll, arch );
+        char *parent_module = arch_module_name( make->testdll, parent->use_msvcrt ? arch : 0 );
         output_filename( obj_dir_path( parent, parent_module ));
         if (parent->unixlib) output_filename( obj_dir_path( parent, parent->unixlib ));
     }
@@ -3943,11 +3940,15 @@ static void output_sources( struct makefile *make )
     }
     else if (make->module)
     {
-        for (arch = 0; arch < archs.count; arch++)
+        if (!make->use_msvcrt) output_module( make, 0 );
+        else
         {
-            if (is_multiarch( arch )) output_module( make, arch );
-            if (make->importlib && (is_multiarch( arch ) || !is_native_arch_disabled( make )))
-                output_import_lib( make, arch );
+            for (arch = 0; arch < archs.count; arch++)
+            {
+                if (is_multiarch( arch )) output_module( make, arch );
+                if (make->importlib && (is_multiarch( arch ) || !is_native_arch_disabled( make )))
+                    output_import_lib( make, arch );
+            }
         }
         if (make->unixlib) output_unix_lib( make );
         if (make->is_exe && !make->is_win16 && unix_lib_supported && strendswith( make->module, ".exe" ))
@@ -4408,9 +4409,13 @@ static void load_sources( struct makefile *make )
     }
     make->is_win16   = strarray_exists( &make->extradllflags, "-m16" );
     make->data_only  = strarray_exists( &make->extradllflags, "-Wb,--data-only" );
+    make->use_msvcrt = (make->module || make->testdll || make->is_win16) &&
+                       !strarray_exists( &make->extradllflags, "-mcygwin" );
     make->is_exe     = strarray_exists( &make->extradllflags, "-mconsole" ) ||
                        strarray_exists( &make->extradllflags, "-mwindows" );
 
+    if (make->use_msvcrt) strarray_add_uniq( &make->extradllflags, "-mno-cygwin" );
+
     if (make->module)
     {
         /* add default install rules if nothing was specified */
@@ -4480,6 +4485,8 @@ static void load_sources( struct makefile *make )
 
     add_generated_sources( make );
 
+    if (make->use_msvcrt) strarray_add( &make->define_args, get_crt_define( make ));
+
     LIST_FOR_EACH_ENTRY( file, &make->includes, struct incl_file, entry ) parse_file( make, file, 0 );
     LIST_FOR_EACH_ENTRY( file, &make->sources, struct incl_file, entry ) get_dependencies( file, file );
 
diff --git a/tools/makedep.c.orig b/tools/makedep.c.orig
index 11111111111..11111111111 100644
--- a/tools/makedep.c.orig
+++ b/tools/makedep.c.orig
@@ -150,6 +150,7 @@ static const char *fontforge;
 static const char *convert;
 static const char *flex;
 static const char *bison;
+static const char *nasm;
 static const char *ar;
 static const char *ranlib;
 static const char *rsvg;
@@ -217,6 +218,8 @@ struct makefile
     struct strarray font_files;
     struct strarray debug_files;
     struct strarray dlldata_files;
+    struct strarray chksum_targets;
+    struct strarray chksum_files;
     struct strarray phony_targets;
     struct strarray dependencies;
     struct strarray object_files[MAX_ARCHS];
@@ -1065,6 +1068,27 @@ static void parse_idl_file( struct file *source, FILE *file )
     }
 }
 
+
+/*******************************************************************
+ *         parse_asm_file
+ */
+static void parse_asm_file( struct file *source, FILE *file )
+{
+    char *buffer;
+
+    input_line = 0;
+    while ((buffer = get_line( file )))
+    {
+        buffer = skip_spaces( buffer );
+        if (*buffer++ != '%') return;
+        buffer = skip_spaces( buffer );
+
+        if (!strncmp( buffer, "include", 7 ))
+            parse_include_directive( source, buffer + 7 );
+    }
+}
+
+
 /*******************************************************************
  *         parse_c_file
  */
@@ -1190,6 +1214,7 @@ static const struct
     void (*parse)( struct file *file, FILE *f );
 } parse_functions[] =
 {
+    { ".asm", parse_asm_file },
     { ".c",   parse_c_file },
     { ".h",   parse_c_file },
     { ".inl", parse_c_file },
@@ -1616,12 +1641,13 @@ static void parse_file( struct makefile *make, struct incl_file *source, int src
  *
  * Add a source file to the list.
  */
-static struct incl_file *add_src_file( struct makefile *make, const char *name )
+static struct incl_file *add_src_file( struct makefile *make, const char *name, unsigned int arch )
 {
     struct incl_file *file = xmalloc( sizeof(*file) );
 
     memset( file, 0, sizeof(*file) );
     file->name = xstrdup(name);
+    file->arch = arch;
     file->use_msvcrt = is_using_msvcrt( make );
     file->is_external = !!make->extlib;
     list_add_tail( &make->sources, &file->entry );
@@ -2550,7 +2576,10 @@ static void output_install_rules( struct makefile *make, enum install_rules rule
     for (i = 0; i < files.count; i += 2)
     {
         const char *file = files.str[i];
-        switch (*files.str[i + 1])
+        const char *dest = strmake( "$(DESTDIR)%s", files.str[i + 1] + 1 );
+        char type = *files.str[i + 1];
+
+        switch (type)
         {
         case '0': case '1': case '2': case '3': case '4':
         case '5': case '6': case '7': case '8': case '9': /* arch-dependent program */
@@ -2563,12 +2592,27 @@ static void output_install_rules( struct makefile *make, enum install_rules rule
             strarray_add_uniq( &targets, tools_dir_path( make, file ));
             break;
         }
+
+        if (rules == INSTALL_LIB)
+            strarray_add_uniq( &make->chksum_files, dest );
     }
 
-    output( "%s %s::", obj_dir_path( make, "install" ), obj_dir_path( make, install_targets[rules] ));
+    if (rules == INSTALL_LIB)
+    {
+        char *tgt = strmake( "%s_", obj_dir_path( make, install_targets[rules] ));
+        output( "%s::", tgt );
+        strarray_add_uniq( &make->chksum_targets, tgt );
+    }
+    else
+        output( "%s %s::", obj_dir_path( make, "install" ), obj_dir_path( make, install_targets[rules] ));
     output_filenames( targets );
     output( "\n" );
     output_install_commands( make, files );
+    if (rules == INSTALL_LIB)
+    {
+        char *tgt = obj_dir_path( make, install_targets[rules] );
+        output( "%s %s:: %s_ genchksums\n", obj_dir_path( make, "install" ), tgt, tgt);
+    }
     strarray_add_uniq( &make->phony_targets, obj_dir_path( make, "install" ));
     strarray_add_uniq( &make->phony_targets, obj_dir_path( make, install_targets[rules] ));
 }
@@ -2675,6 +2719,89 @@ static void output_po_files( struct makefile *make )
 }
 
 
+/*******************************************************************
+ *         output_source_asm
+ */
+static void output_source_asm_one_arch( struct makefile *make, struct incl_file *source, const char *obj,
+                                        struct strarray defines, struct strarray *targets,
+                                        unsigned int arch, int is_dll_src )
+{
+    const char *obj_name;
+    char buffer[64];
+
+    if (make->disabled[arch] && !(source->file->flags & FLAG_C_IMPLIB)) return;
+
+    if (arch)
+    {
+        if (source->file->flags & FLAG_C_UNIX) return;
+        if (!is_using_msvcrt( make ) && !make->staticlib && !(source->file->flags & FLAG_C_IMPLIB)) return;
+    }
+    else if (source->file->flags & FLAG_C_UNIX)
+    {
+        if (!*dll_ext) return;
+    }
+    else if (archs.count > 1 && is_using_msvcrt( make ) &&
+             !(source->file->flags & FLAG_C_IMPLIB) &&
+             (!make->staticlib || make->extlib)) return;
+
+    obj_name = strmake( "%s%s.o", source->arch ? "" : arch_dirs[arch], obj );
+    strarray_add( targets, obj_name );
+
+    if (source->file->flags & FLAG_C_UNIX)
+        strarray_add( &make->unixobj_files, obj_name );
+    else if (source->file->flags & FLAG_C_IMPLIB)
+        strarray_add( &make->implib_files[arch], obj_name );
+    else if (!is_dll_src)
+        strarray_add( &make->object_files[arch], obj_name );
+    else
+        strarray_add( &make->clean_files, obj_name );
+
+    output( "%s: %s\n", obj_dir_path( make, obj_name ), source->filename );
+    if (strendswith( source->name, ".asm" ))
+        output( "\t%s%s -o$@", cmd_prefix( "NASM" ), nasm );
+    else
+        output( "\t%s%s -c -o $@", cmd_prefix( "CC" ), arch_make_variable( "CC", arch ) );
+    output_filenames( defines );
+    output_filenames( cpp_flags );
+    output_filenames( get_expanded_make_var_array( make, "EXTRAASMFLAGS" ));
+    output_filenames( get_expanded_file_local_var( make, obj, "EXTRAASMFLAGS" ));
+    strcpy( buffer, archs.str[arch] );
+    strcat( buffer, "_" );
+    strcat( buffer, "EXTRAASMFLAGS" );
+    output_filenames( get_expanded_make_var_array( make, buffer ));
+    output_filenames( get_expanded_file_local_var( make, obj, buffer ));
+    output( " %s\n", source->filename );
+}
+
+
+/*******************************************************************
+ *         output_source_asm
+ */
+static void output_source_asm( struct makefile *make, struct incl_file *source, const char *obj )
+{
+    struct strarray defines = get_source_defines( make, source, obj );
+    struct strarray targets = empty_strarray;
+    int is_dll_src = (make->testdll && strendswith( source->name, ".asm" ) &&
+                      find_src_file( make, replace_extension( source->name, ".asm", ".spec" )));
+    unsigned int arch;
+
+    for (arch = 0; arch < archs.count; arch++)
+        if (!source->arch || source->arch == arch)
+            output_source_asm_one_arch( make, source, obj, defines, &targets, arch, is_dll_src );
+
+    if (source->file->flags & FLAG_GENERATED)
+        strarray_add( &make->clean_files, source->basename );
+
+    if (targets.count && source->dependencies.count)
+    {
+        output_filenames_obj_dir( make, targets );
+        output( ":" );
+        output_filenames( source->dependencies );
+        output( "\n" );
+    }
+}
+
+
 /*******************************************************************
  *         output_source_y
  */
@@ -3215,6 +3342,7 @@ static void output_source_one_arch( struct makefile *make, struct incl_file *sou
 
     output_filenames( cpp_flags );
     output_filename( arch_make_variable( "CFLAGS", arch ));
+    output_filename( arch_make_variable( strmake( "%s_CFLAGS", basename( obj ) ), arch ));
     output( "\n" );
 
     if (make->testdll && strendswith( source->name, ".c" ) &&
@@ -3279,6 +3407,7 @@ static const struct
     void (*fn)( struct makefile *make, struct incl_file *source, const char *obj );
 } output_source_funcs[] =
 {
+    { "asm", output_source_asm },
     { "y", output_source_y },
     { "l", output_source_l },
     { "h", output_source_h },
@@ -3408,6 +3537,7 @@ static void output_module( struct makefile *make, unsigned int arch )
     if (debug_file) output_filename( strmake( "-Wl,--debug-file,%s", obj_dir_path( make, debug_file )));
     output_filenames( all_libs );
     output_filename( arch_make_variable( "LDFLAGS", arch ));
+    output_filename( "-Wl,--file-alignment,4096" );
     output( "\n" );
 
     if (!make->data_only && !arch && unix_lib_supported) output_fake_module( make, spec_file );
@@ -3491,8 +3621,11 @@ static void output_static_lib( struct makefile *make, unsigned int arch )
     if (!arch) output_filenames_obj_dir( make, make->unixobj_files );
     output( "\n" );
     if (!make->extlib)
+    {
+        strarray_add( &make->all_targets, name );
         add_install_rule( make, make->staticlib, arch, name,
                           strmake( "d%s%s", arch_install_dirs[arch], make->staticlib ));
+    }
 }
 
 
@@ -3653,6 +3786,8 @@ static void output_subdirs( struct makefile *make )
         strarray_addall( &subclean, get_removable_dirs( submakes[i]->clean_files ));
         strarray_addall( &subclean, get_removable_dirs( submakes[i]->distclean_files ));
         strarray_add( &makefile_deps, src_dir_path( submakes[i], "Makefile.in" ));
+        strarray_addall_uniq( &make->chksum_targets, submakes[i]->chksum_targets );
+        strarray_addall_uniq( &make->chksum_files, submakes[i]->chksum_files );
         strarray_addall_uniq( &make->phony_targets, submakes[i]->phony_targets );
         strarray_addall_uniq( &make->uninstall_files, submakes[i]->uninstall_files );
         strarray_addall_uniq( &dependencies, submakes[i]->dependencies );
@@ -3886,6 +4021,25 @@ static void output_sources( struct makefile *make )
 }
 
 
+/*******************************************************************
+ *         output_sources
+ */
+static void output_genchksums( struct makefile *make )
+{
+    char *install_sh = root_src_dir_path( "tools/install-sh" );
+    char *genchksums = tools_path( make, "genchksums" );
+    unsigned int i;
+
+    output( "genchksums:: %s", genchksums );
+    output_filenames( make->chksum_targets );
+    output( "\n\t%s -m 755 $(INSTALL_DATA_FLAGS) -d $(DESTDIR)$(datadir)/wine\n", install_sh);
+    output( "\n\techo");
+    for (i = 0; i < make->chksum_files.count; i++)
+        output_filename( make->chksum_files.str[i] );
+    output( " | \\\n\t%s >$(DESTDIR)$(datadir)/wine/chksums.bin\n", genchksums);
+}
+
+
 /*******************************************************************
  *         create_temp_file
  */
@@ -4159,6 +4313,7 @@ static void output_top_makefile( struct makefile *make )
     if (silent_rules) output_silent_rules();
     for (i = 0; i < subdirs.count; i++) output_sources( submakes[i] );
     output_sources( make );
+    output_genchksums( make );
     /* disable implicit rules */
     output( ".SUFFIXES:\n" );
 
@@ -4207,6 +4362,7 @@ static void load_sources( struct makefile *make )
         "IDL_SRCS",
         "BISON_SRCS",
         "LEX_SRCS",
+        "ASM_SRCS",
         "HEADER_SRCS",
         "XTEMPLATE_SRCS",
         "SVG_SRCS",
@@ -4307,7 +4463,19 @@ static void load_sources( struct makefile *make )
     for (var = source_vars; *var; var++)
     {
         value = get_expanded_make_var_array( make, *var );
-        for (i = 0; i < value.count; i++) add_src_file( make, value.str[i] );
+        for (i = 0; i < value.count; i++) add_src_file( make, value.str[i], 0 );
+    }
+    for (var = source_vars; *var; var++)
+    {
+        for (arch = 1; arch < archs.count; arch++)
+        {
+            char buffer[64];
+            strcpy( buffer, archs.str[arch] );
+            strcat( buffer, "_" );
+            strcat( buffer, *var );
+            value = get_expanded_make_var_array( make, buffer );
+            for (i = 0; i < value.count; i++) add_src_file( make, value.str[i], arch );
+        }
     }
 
     add_generated_sources( make );
@@ -4438,6 +4606,7 @@ int main( int argc, char *argv[] )
     convert            = get_expanded_make_variable( top_makefile, "CONVERT" );
     flex               = get_expanded_make_variable( top_makefile, "FLEX" );
     bison              = get_expanded_make_variable( top_makefile, "BISON" );
+    nasm               = get_expanded_make_variable( top_makefile, "NASM" );
     ar                 = get_expanded_make_variable( top_makefile, "AR" );
     ranlib             = get_expanded_make_variable( top_makefile, "RANLIB" );
     rsvg               = get_expanded_make_variable( top_makefile, "RSVG" );
